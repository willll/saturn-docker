diff -crBN --binary sbl6/segalib/clib/per_x1.c sbl6_patch/segalib/clib/per_x1.c
*** sbl6/segalib/clib/per_x1.c	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/clib/per_x1.c	1996-02-08 05:30:32.000000000 -0500
***************
*** 0 ****
--- 1,740 ----
+ /****************************************
+ *			include files				*
+ ****************************************/
+ #include	"per_x.h"
+ 
+ /****************************************
+ *		declare private objects			*
+ ****************************************/
+ static trigger_t	GetTriggerDigital( const SysDevice	*device );
+ static trigger_t	GetTriggerAnalog( const SysDevice	*device );
+ static trigger_t	GetTriggerPointer( const SysDevice	*device );
+ static trigger_t	GetTriggerKeyboard( const SysDevice	*device );
+ static trigger_t	GetTriggerMD3B( const SysDevice	*device );
+ static trigger_t	GetTriggerMD6B( const SysDevice	*device );
+ static trigger_t	GetTriggerMDMouse( const SysDevice	*device );
+ static trigger_t	GetTriggerUnknown( const SysDevice	*device );
+ 
+ static trigger_handler_t	GetTrigger[] = {
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerDigital, GetTriggerDigital,
+ 	GetTriggerDigital, GetTriggerDigital, GetTriggerDigital, GetTriggerDigital,
+ 	GetTriggerDigital, GetTriggerDigital, GetTriggerDigital, GetTriggerDigital,
+ 	GetTriggerDigital, GetTriggerDigital, GetTriggerDigital, GetTriggerDigital,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerAnalog, GetTriggerAnalog,
+ 	GetTriggerAnalog, GetTriggerAnalog, GetTriggerAnalog, GetTriggerAnalog,
+ 	GetTriggerAnalog, GetTriggerAnalog, GetTriggerAnalog, GetTriggerAnalog,
+ 	GetTriggerAnalog, GetTriggerAnalog, GetTriggerAnalog, GetTriggerAnalog,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerPointer, GetTriggerPointer,
+ 	GetTriggerPointer, GetTriggerPointer, GetTriggerPointer, GetTriggerPointer,
+ 	GetTriggerPointer, GetTriggerPointer, GetTriggerPointer, GetTriggerPointer,
+ 	GetTriggerPointer, GetTriggerPointer, GetTriggerPointer, GetTriggerPointer,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerKeyboard, GetTriggerKeyboard,
+ 	GetTriggerKeyboard, GetTriggerKeyboard, GetTriggerKeyboard, GetTriggerKeyboard,
+ 	GetTriggerKeyboard, GetTriggerKeyboard, GetTriggerKeyboard, GetTriggerKeyboard,
+ 	GetTriggerKeyboard, GetTriggerKeyboard, GetTriggerKeyboard, GetTriggerKeyboard,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerMD3B, GetTriggerMD6B, GetTriggerMDMouse,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ 	GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown, GetTriggerUnknown,
+ };
+ 
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		PER_SetTriggerHandler( id, handler );							*
+ *																		*
+ *		指定のＩＤを持つペリフェラル用のトリガハンドラを設定します。	*
+ *																		*
+ *				・・・・・												*
+ *		ここでは「指定のＩＤを持つデバイス用のハンドラを設定している」	*
+ *		ということに注目してください。「指定のタイプ」ではありません	*
+ *		ので、注意してください。										*
+ *																		*
+ *		ここで設定した関数（ハンドラ）は、PER_GetTrigger() に指定の		*
+ *		ＩＤを持つデバイス情報が渡されたときに、コールされます。		*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		int					id;											*
+ *		trigger_handler_t	handler;									*
+ *																		*
+ *		<id> は、サターンペリフェラルＩＤ								*
+ *		<handler> は、トリガハンドラ									*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		GetTrigger	influence	トリガハンドラのテーブル				*
+ *																		*
+ *																		*
+ ************************************************************************/
+ void	PER_SetTriggerHandler( int	id, trigger_handler_t	handler ){
+ 	GetTrigger[id] = handler;
+ }
+ 
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		handler = PER_GetTriggerHandler( id );							*
+ *																		*
+ *		指定のＩＤを持つペリフェラル用のトリガハンドラを得ます。		*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		int		id;														*
+ *																		*
+ *		サターンペリフェラルＩＤ										*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_handler_t	handler;									*
+ *																		*
+ *		トリガハンドラ													*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		GetTrigger	reference	トリガハンドラのテーブル				*
+ *																		*
+ *																		*
+ ************************************************************************/
+ trigger_handler_t	PER_GetTriggerHandler( int	id ){
+ 	return	GetTrigger[id];
+ }
+ 
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerDigital( &device );							*
+ *																		*
+ *		デジタルデバイスからトリガ情報を得ます。						*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerDigital( const SysDevice	*device ){
+ 	const SysDevDigital	*this = ( const SysDevDigital * )device;
+ 	
+ 	trigger_t	data_l = ( trigger_t )( ~this->data[1] ) & 0x00ff;
+ 	trigger_t	data_h = ( trigger_t )( ~this->data[0] ) & 0x00ff;
+ 	
+ 	return	( trigger_t )(( data_h << 8 ) | data_l );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerAnalog( &device );							*
+ *																		*
+ *		アナログデバイスからトリガ情報を得ます。						*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerAnalog( const SysDevice	*device ){
+ 	const SysDevAnalog	*this = ( const SysDevAnalog * )device;
+ 	
+ 	trigger_t	data_l = ( trigger_t )( ~this->data[1] ) & 0x00ff;
+ 	trigger_t	data_h = ( trigger_t )( ~this->data[0] ) & 0x00ff;
+ 	
+ 	return	( trigger_t )(( data_h << 8 ) | data_l );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerPointer( &device );							*
+ *																		*
+ *		ポインティングデバイスからトリガ情報を得ます。					*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerPointer( const SysDevice	*device ){
+ 	const SysDevPointer	*this = ( const SysDevPointer * )device;
+ 	
+ 	trigger_t	data_h = ( trigger_t )( this->status & PT_TRIGGER );
+ 	
+ 	return	( trigger_t )( data_h << 8 );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerKeyboard( &device );						*
+ *																		*
+ *		キーボードデバイスからトリガ情報を得ます。						*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerKeyboard( const SysDevice	*device ){
+ 	const SysDevKeyboard	*this = ( const SysDevKeyboard * )device;
+ 	
+ 	trigger_t	data_l = ( trigger_t )( ~this->data[1] ) & 0x00ff;
+ 	trigger_t	data_h = ( trigger_t )( ~this->data[0] ) & 0x00ff;
+ 	
+ 	return	( trigger_t )(( data_h << 8 ) | data_l );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerMD3B( &device );							*
+ *																		*
+ *		メガドライブ用３ボタンパッドからトリガ情報を得ます。			*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerMD3B( const SysDevice	*device ){
+ 	const struct DevMD3B	*this = ( const struct DevMD3B * )device;
+ 	
+ 	trigger_t	data_h = ( trigger_t )( ~this->data[0] ) & 0x00ff;
+ 	
+ 	return	( trigger_t )( data_h << 8 );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerMD6B( &device );							*
+ *																		*
+ *		メガドライブ用６ボタンパッドからトリガ情報を得ます。			*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerMD6B( const SysDevice	*device ){
+ 	const struct DevMD6B	*this = ( const struct DevMD6B * )device;
+ 	
+ 	trigger_t	data_l = ( trigger_t )( ~this->data[1] ) & 0x00ff;
+ 	trigger_t	data_h = ( trigger_t )( ~this->data[0] ) & 0x00ff;
+ 	
+ 	return	( trigger_t )(( data_h << 8 ) | data_l );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerMDMouse( &device );							*
+ *																		*
+ *		メガドライブ用マウス（なぜか、サターン用のシャトルマウスも）	*
+ *		からトリガ情報を得ます。										*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerMDMouse( const SysDevice	*device ){
+ 	const struct DevMDMouse	*this = ( const struct DevMDMouse * )device;
+ 	
+ 	trigger_t	data_h = ( trigger_t )( this->status & PT_TRIGGER );
+ 	
+ 	return	( trigger_t )( data_h << 8 );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		trigger = GetTriggerUnknown( &device );							*
+ *																		*
+ *		不明なデバイスからトリガ情報を得ます。							*
+ *																		*
+ *		常に 0 を返します。												*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		常に 0 を返します。												*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ static trigger_t	GetTriggerUnknown( const SysDevice	*device ){
+ 	return	0;
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		trigger = PER_GetTrigger( device );								*
+ *																		*
+ *		デバイスの種類に応じてトリガ情報を得ます。						*
+ *																		*
+ *		PER_SetTriggerHandler() によって登録されているＩＤを持つデバ	*
+ *		イスからトリガ情報を取り出すには、同じく PER_SetTriggerHandler()*
+ *		によって登録されている関数（ハンドラ）を用います。そういった	*
+ *		ものがない場合には、デフォルトで用意されている関数（ハンドラ）	*
+ *		を用います。この場合、予め対応している入力ペリフェラルは下記	*
+ *		のものだけですので、それ以外の入力ペリフェラルからトリガ情報	*
+ *		を得たい場合には、PER_SetTriggerHandler() を使用してください。	*
+ *																		*
+ *		デフォルトで対応している入力ペリフェラル						*
+ *		デジタルデバイス												*
+ *			サターンペリフェラルＩＤとして 0x02 - 0x0f を返すもの		*
+ *		アナログデバイス												*
+ *			サターンペリフェラルＩＤとして 0x12 - 0x1f を返すもの		*
+ *		ポインティングデバイス											*
+ *			サターンペリフェラルＩＤとして 0x22 - 0x2f を返すもの		*
+ *		キーボードデバイス												*
+ *			サターンペリフェラルＩＤとして 0x33 - 0x3f を返すもの		*
+ *		メガドライブ用３Ｂパッド										*
+ *			サターンペリフェラルＩＤとして 0xe1 を返すもの				*
+ *		メガドライブ用６Ｂパッド										*
+ *			サターンペリフェラルＩＤとして 0xe2 を返すもの				*
+ *		メガドライブ用マウス											*
+ *			サターンペリフェラルＩＤとして 0xe3 を返すもの				*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevice	*device;										*
+ *																		*
+ *		デバイス情報													*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	trigger;											*
+ *																		*
+ *		トリガ情報を返します。											*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ trigger_t	PER_GetTrigger( const SysDevice	*this ){
+ 	trigger_t	trigger = 0;
+ 	
+ 	if( this != NULL ){
+ 		int					id = PER_GetID( this );
+ 		trigger_handler_t	handler = PER_GetTriggerHandler( id );
+ 		
+ 		if( handler != NULL )
+ 			trigger = handler( this );
+ 	}
+ 	
+ 	return	trigger;
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		edge = PER_GetEdge( t1, t2 );									*
+ *																		*
+ *		トリガのエッジ情報を得ます。									*
+ *																		*
+ *		エッジ情報とは <t1> と <t2> の２つのタイミングのあいだで変化	*
+ *		したトリガの情報のことをいいます。								*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		trigger_t	t1;													*
+ *		trigger_t	t2;													*
+ *																		*
+ *		<t1> と <t2> はトリガ情報。										*
+ *		<t1> と <t2> の時間的な順序は問いません。						*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	edge;												*
+ *																		*
+ *		トリガのエッジ情報を返します。									*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ trigger_t	PER_GetEdge( trigger_t	t1, trigger_t	t2 ){
+ 	return	( trigger_t )( t1 ^ t2 );
+ }
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		edge = PER_GetPressEdge( prev, current );						*
+ *																		*
+ *		トリガのプレスエッジ（押下エッジ）情報を得ます。				*
+ *																		*
+ *		プレスエッジ情報とは <prev> と <current> の２つのタイミング		*
+ *		のあいだにリリース状態からプレス状態に変化したトリガの情報の	*
+ *		ことをいいます。												*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		trigger_t	prev;												*
+ *		trigger_t	current;											*
+ *																		*
+ *		<prev> と <current> は共にトリガ情報。							*
+ *		時間的に（ <prev> ＜ <current> ）という関係を期待しています。	*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	edge;												*
+ *																		*
+ *		トリガのプレスエッジ情報を返します。							*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ trigger_t	PER_GetPressEdge( trigger_t	prev, trigger_t	current ){
+ 	trigger_t	edge = PER_GetEdge( prev, current );
+ 	
+ 	return	( trigger_t )( current & edge );
+ }
+ 
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		edge = PER_GetReleaseEdge( prev, current );						*
+ *																		*
+ *		トリガのリリースエッジ（解放エッジ）情報を得ます。				*
+ *																		*
+ *		リリースエッジ情報とは <prev> と <current> の２つのタイミン		*
+ *		グのあいだにプレス状態からリリース状態に変化したトリガの情報	*
+ *		のことをいいます。												*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		trigger_t	prev;												*
+ *		trigger_t	current;											*
+ *																		*
+ *		<prev> と <current> は共にトリガ情報。							*
+ *		時間的に（ <prev> ＜ <current> ）という関係を期待しています。	*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		trigger_t	edge;												*
+ *																		*
+ *		トリガのリリースエッジ情報を返します。							*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ trigger_t	PER_GetReleaseEdge( trigger_t	prev, trigger_t	current ){
+ 	trigger_t	edge = PER_GetEdge( prev, current );
+ 	
+ 	return	( trigger_t )( ~current & edge );
+ }
+ 
+ #define	ANALOG_ILLEGAL	0xff
+ #define	ANALOG_ORIGIN	0x7f
+ 
+ /*@*/
+ /************************************************************************
+ *																		*
+ *	【synopsis】														*
+ *																		*
+ *		#include	"per_x.h"											*
+ *																		*
+ *		PER_GetAnalogXYZ( analog, &x, &y, &z );							*
+ *																		*
+ *		アナログデバイスからＸＹＺ方向のＡ／Ｄコンバータの出力値を得	*
+ *		ます。															*
+ *																		*
+ *																		*
+ *	【parameters】														*
+ *																		*
+ *		const SysDevAnalog	*analog;									*
+ *		int		*x;														*
+ *		int		*y;														*
+ *		int		*z;														*
+ *																		*
+ *		<analog> はアナログデバイス情報。								*
+ *		<x> <y> <z> はそれぞれＸＹＺ方向のＡ／Ｄコンバータの出力値。	*
+ *																		*
+ *		<x> <y> <z> に NULL を渡すとそこには何も返されません。			*
+ *																		*
+ *		<x> には（右）-127 〜 +127（左）が返されます。					*
+ *		<y> には（上）-127 〜 +127（下）が返されます。					*
+ *		<z> には（下）-127 〜 +127（上）が返されます。					*
+ *																		*
+ *																		*
+ *	【return value】													*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ *	【influence/reference objects】										*
+ *																		*
+ *		なし															*
+ *																		*
+ *																		*
+ ************************************************************************/
+ void	PER_GetAnalogXYZ( const SysDevAnalog	*this, int	*x, int	*y, int	*z ){
+ 	int		ax = 0;
+ 	int		ay = 0;
+ 	int		az = 0;
+ 	
+ 	if( this->ax != ANALOG_ILLEGAL )
+ 		ax = ( int )this->ax - ANALOG_ORIGIN;
+ 	if( this->ay != ANALOG_ILLEGAL )
+ 		ay = ( int )this->ay - ANALOG_ORIGIN;
+ 	if( this->az != ANALOG_ILLEGAL )
+ 		az = ( int )this->az - ANALOG_ORIGIN;
+ 	
+ 	if( x != NULL )
+ 		*x = ax;
+ 	if( y != NULL )
+ 		*y = ay;
+ 	if( z != NULL )
+ 		*z = az;
+ }
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/clib/per_x2.c sbl6_patch/segalib/clib/per_x2.c
*** sbl6/segalib/clib/per_x2.c	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/clib/per_x2.c	1996-02-08 05:30:32.000000000 -0500
***************
*** 0 ****
--- 1,76 ----
+ /****************************************
+ *			include files				*
+ ****************************************/
+ #include	"sega_xpt.h"
+ #include	"sega_per.h"
+ #include	"per_x.h"
+ 
+ /****************************************
+ *		declare private objects			*
+ ****************************************/
+ static SysPort	PortData[_MAX_PORT];
+ 
+ static Uint8		per_buff[SZ_BUFFER];
+ static PerGetPer	*per_data;
+ static PerMulInfo	*mul_info;
+ 
+ SysPort	*PER_OpenPort( void ){
+ 	PER_LInit( PER_KD_PER, _MAX_PORT*_MAX_PERIPHERAL, SZ_PERIPHERAL, per_buff, 0 );
+ 	
+ 	return	PortData;
+ }
+ 
+ void	PER_GetPort( SysPort	*port ){
+ 	SysPeripheral	*peripheral;
+ 	
+ 	PER_LGetPer( &per_data, &mul_info );
+ 	
+ 	peripheral = ( SysPeripheral * )per_data;
+ 	
+ 	port[0].id          = ( mul_info[0].id | mul_info[0].con );
+ 	port[0].connectable = mul_info[0].con;
+ 	port[0].peripheral  = peripheral;
+ 	
+ 	port[1].id          = ( mul_info[1].id | mul_info[1].con );
+ 	port[1].connectable = mul_info[1].con;
+ 	if( mul_info[0].con == 0 )
+ 		port[1].peripheral  = &peripheral[1];
+ 	else
+ 		port[1].peripheral  = &peripheral[mul_info[0].con];
+ }
+ 
+ const SysDevice	*PER_GetDeviceA( const SysPort	*port, Uint32	n ){
+ 	const SysDevice	*device = NULL;
+ 	
+ 	if( n < port->connectable ){
+ 		const SysDevice	*dev = ( const SysDevice * )port->peripheral[n];
+ 		
+ 		if( PER_GetID( dev ) != ID_UNCONNECTED )
+ 			device = dev;
+ 	}
+ 	
+ 	return	device;
+ }
+ 
+ const SysDevice	*PER_GetDeviceR( const SysPort	*port, Uint32	n ){
+ 	const SysDevice	*device = NULL;
+ 	Uint32	connecters = 0;
+ 	Uint32	i;
+ 	
+ 	for( i = 0; i < port->connectable; i++ ){
+ 		const SysDevice	*dev = ( const SysDevice * )port->peripheral[i];
+ 		
+ 		if( PER_GetID( dev ) != ID_UNCONNECTED ){
+ 			if( connecters == n ){
+ 				device = dev;
+ 				break;
+ 			}
+ 			
+ 			connecters++;
+ 		}
+ 	}
+ 	
+ 	return	device;
+ }
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/clib/per_x3.src sbl6_patch/segalib/clib/per_x3.src
*** sbl6/segalib/clib/per_x3.src	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/clib/per_x3.src	1996-02-08 05:30:32.000000000 -0500
***************
*** 0 ****
--- 1,75 ----
+ 	
+ 	.SECTION	SEGA_P,CODE,ALIGN=4
+ ;/*@*/
+ ;/***********************************************************************
+ ;*																		*
+ ;*	【synopsis】														*
+ ;*																		*
+ ;*		#include	"per_x.h"											*
+ ;*																		*
+ ;*		trigger = PER_DisguiseTrigger( assignment, trigger );			*
+ ;*																		*
+ ;*		トリガ情報<trigger> をアサインテーブル<assignment> に従って		*
+ ;*		変換します。<assignment> に NULL を指定すると、なんの変換も		*
+ ;*		せずに <trigger> をそのまま返します。							*
+ ;*																		*
+ ;*		アサインテーブルとはトリガ情報の配列で、配列のインデックスが	*
+ ;*		トリガ情報のビット番号に対応するテーブルのことです。			*
+ ;*		例えば <trigger> の 0 ビット目と 4 ビット目が TRUE だった場		*
+ ;*		合の戻り値は ( assignment[0] | assignment[4] ) になります。		*
+ ;*																		*
+ ;*		普通は assignment[] の各メンバには、ただ１つのトリガを対応さ	*
+ ;*		せます。１つのメンバに複数のトリガを対応させた場合には、１つ	*
+ ;*		のトリガが押されただけで、複数のトリガが押されたかのように振	*
+ ;*		る舞うので注意が必要です。										*
+ ;*																		*
+ ;*																		*
+ ;*	【parameters】														*
+ ;*																		*
+ ;*		const assignment_t	*assignment;								*
+ ;*		trigger_t		trigger;										*
+ ;*																		*
+ ;*		<assignment> は、トリガ情報のアサインテーブル					*
+ ;*		<trigger> は、トリガ情報										*
+ ;*																		*
+ ;*		<assignment> に NULL を渡すと何の変換もせずに <trigger> を		*
+ ;*		そのまま返します。												*
+ ;*																		*
+ ;*																		*
+ ;*	【return value】													*
+ ;*																		*
+ ;*		trigger_t	trigger;											*
+ ;*																		*
+ ;*		トリガ情報を返します。											*
+ ;*																		*
+ ;*																		*
+ ;*	【influence/reference objects】										*
+ ;*																		*
+ ;*		なし															*
+ ;*																		*
+ ;*																		*
+ ;***********************************************************************/
+ 	.GLOBAL	_PER_DisguiseTrigger
+ _PER_DisguiseTrigger:
+ 	tst		r4,r4
+ 	bt/s	L02
+ 	mov		r5,r0
+ 	
+ 	bra		L01
+ 	mov		#0,r0
+ L00:
+ 	mov.w	@r4+,r2
+ 	bf/s	L01
+ 	extu.w	r2,r2
+ 	or		r2,r0
+ L01:
+ 	tst		r5,r5
+ 	bf/s	L00
+ 	shlr	r5
+ 	
+ L02:
+ 	rts
+ 	nop
+ 
+ 	.END
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/cmp/cmplrunb.c sbl6_patch/segalib/cmp/cmplrunb.c
*** sbl6/segalib/cmp/cmplrunb.c	1996-02-08 05:23:04.000000000 -0500
--- sbl6_patch/segalib/cmp/cmplrunb.c	2023-01-04 18:47:04.000000000 -0500
***************
*** 33,41 ****
  Sint32 CMP_DecRunlenByte(void *_inp, void **_outp, Sint32 outbufsize)
  {
  	char	*inp, *outp;
! 	Sint32	orgfsize,		/* 圧縮前ファイルサイズ[byte]	*/
! 			outsize,		/* 出力データサイズ[byte] 		*/
! 			outcnt,			/* 出力データカウンタ	 		*/
  			runlen,         /* ラン長 						*/
  			retval;         /* 戻り値						*/
  	Uint16	header;			/* 圧縮ファイルヘッダ	 		*/
--- 33,41 ----
  Sint32 CMP_DecRunlenByte(void *_inp, void **_outp, Sint32 outbufsize)
  {
  	char	*inp, *outp;
! 	Sint32	orgfsize = 0,		/* 圧縮前ファイルサイズ[byte]	*/
! 			outsize = 0,	/* 出力データサイズ[byte] 		*/
! 			outcnt,		/* 出力データカウンタ	 		*/
  			runlen,         /* ラン長 						*/
  			retval;         /* 戻り値						*/
  	Uint16	header;			/* 圧縮ファイルヘッダ	 		*/
***************
*** 81,84 ****
  	*_outp = outp;
  	return retval;
  }
! 
\ No newline at end of file
--- 81,84 ----
  	*_outp = outp;
  	return retval;
  }
! 
diff -crBN --binary sbl6/segalib/cmp/cmplrund.c sbl6_patch/segalib/cmp/cmplrund.c
*** sbl6/segalib/cmp/cmplrund.c	1996-02-08 05:23:04.000000000 -0500
--- sbl6_patch/segalib/cmp/cmplrund.c	2023-01-04 18:33:50.000000000 -0500
***************
*** 20,27 ****
  {
  	Uint8	*tmp;
  	Uint32	*inp, *outp;
! 	Sint32	orgfsize,		/* 圧縮前ファイルサイズ[byte]			*/
! 			outsize,		/* 出力データサイズ[byte] 				*/
  			boundary_offset,/* 出力データサイズを４バイトバウンダリ	*/
  							/* に揃える為に付加したバイト数。		*/
  			outcnt,			/* 出力データカウンタ	 				*/
--- 20,27 ----
  {
  	Uint8	*tmp;
  	Uint32	*inp, *outp;
! 	Sint32	orgfsize = 0,		/* 圧縮前ファイルサイズ[byte]			*/
! 			outsize = 0,		/* 出力データサイズ[byte] 				*/
  			boundary_offset,/* 出力データサイズを４バイトバウンダリ	*/
  							/* に揃える為に付加したバイト数。		*/
  			outcnt,			/* 出力データカウンタ	 				*/
***************
*** 74,77 ****
  	*_outp = (void *)tmp;
  	return retval;
  }
! 
\ No newline at end of file
--- 74,77 ----
  	*_outp = (void *)tmp;
  	return retval;
  }
! 
diff -crBN --binary sbl6/segalib/cmp/cmplrunw.c sbl6_patch/segalib/cmp/cmplrunw.c
*** sbl6/segalib/cmp/cmplrunw.c	1996-02-08 05:23:04.000000000 -0500
--- sbl6_patch/segalib/cmp/cmplrunw.c	2023-01-04 18:48:16.000000000 -0500
***************
*** 20,27 ****
  {
  	Uint8	*tmp;
  	Uint16	*inp, *outp;
! 	Sint32	orgfsize,		/* 圧縮前ファイルサイズ[byte]			*/
! 			outsize,		/* 出力データサイズ[byte] 				*/
  			boundary_offset,/* 出力データサイズを４バイトバウンダリ	*/
  							/* に揃える為に付加したバイト数。		*/
  			outcnt,			/* 出力データカウンタ	 				*/
--- 20,27 ----
  {
  	Uint8	*tmp;
  	Uint16	*inp, *outp;
! 	Sint32	orgfsize = 0,		/* 圧縮前ファイルサイズ[byte]			*/
! 			outsize = 0,	/* 出力データサイズ[byte] 				*/
  			boundary_offset,/* 出力データサイズを４バイトバウンダリ	*/
  							/* に揃える為に付加したバイト数。		*/
  			outcnt,			/* 出力データカウンタ	 				*/
***************
*** 74,77 ****
  	*_outp = (void *)tmp;
  	return retval;
  }
! 
\ No newline at end of file
--- 74,77 ----
  	*_outp = (void *)tmp;
  	return retval;
  }
! 
diff -crBN --binary sbl6/segalib/csh/csh_main.c sbl6_patch/segalib/csh/csh_main.c
*** sbl6/segalib/csh/csh_main.c	1996-02-08 05:23:06.000000000 -0500
--- sbl6_patch/segalib/csh/csh_main.c	2023-01-30 18:08:56.000000000 -0500
***************
*** 1,4 ****
! /*------------------------------------------------------------------------
   *  FILE:	csh_main.c
   *      $Author: $Y.K
   *      $Date: $1994-05-10
--- 1,4 ----
! 	/*------------------------------------------------------------------------
   *  FILE:	csh_main.c
   *      $Author: $Y.K
   *      $Date: $1994-05-10
***************
*** 65,70 ****
--- 65,71 ----
  /****************************************************************************/
  /*	キャッシュの全クリア													*/
  /****************************************************************************/
+ #ifndef SGL
  void CSH_AllClr(void)
  {
  	Uint32 way;									/*	アクセスウェイ制御変数	*/
***************
*** 82,87 ****
--- 83,93 ----
  	}											/*	end for way				*/
  	CSH_SET_ENABLE(CSH_ENABLE);					/*	キャッシュイネーブル	*/
  }
+ #else
+ 
+ //extern void CSH_AllClr(void);
+ 
+ #endif
  
  /****************************************************************************/
  /*	対象領域の連想パージ													*/
***************
*** 129,132 ****
  /****************************************************************************/
  /*	End of File																*/
  /****************************************************************************/
! 
\ No newline at end of file
--- 135,138 ----
  /****************************************************************************/
  /*	End of File																*/
  /****************************************************************************/
! 
diff -crBN --binary sbl6/segalib/dma/dma_cpum.c sbl6_patch/segalib/dma/dma_cpum.c
*** sbl6/segalib/dma/dma_cpum.c	1996-02-08 05:23:16.000000000 -0500
--- sbl6_patch/segalib/dma/dma_cpum.c	2021-11-14 20:07:08.000000000 -0500
***************
*** 39,44 ****
--- 39,45 ----
   * C VIRTUAL TYPES DEFINITIONS
   */
  #include "sega_xpt.h"
+ #include "sega_csh.h"
  
  /*
   * USER SUPPLIED INCLUDE FILES
***************
*** 371,374 ****
      return(DMA_CPU_END);                    /* 正常終了をリターン            */
  }
  
! 
\ No newline at end of file
--- 372,375 ----
      return(DMA_CPU_END);                    /* 正常終了をリターン            */
  }
  
! 
diff -crBN --binary sbl6/segalib/dma/dma_scu0.c sbl6_patch/segalib/dma/dma_scu0.c
*** sbl6/segalib/dma/dma_scu0.c	1996-02-08 05:23:18.000000000 -0500
--- sbl6_patch/segalib/dma/dma_scu0.c	2023-01-04 19:04:44.000000000 -0500
***************
*** 315,328 ****
--- 315,334 ----
              now_vector_num = INT_SCU_DMA2;
              intr_func = DMA_ScuIntFunc2;
              break;
+          default:
+             // Error case, should crash ?
+             now_vector_num = 0;
      }
      dma_scu_vector[ch] = INT_GetScuFunc(now_vector_num);
                                                          /* ベクタ待避SCU     */
      dma_vector[ch] = INT_GetFunc(now_vector_num);
                                                          /* ベクタ待避        */
      dma_int_status[ch] = DMA_SCU_MV;
+     #pragma GCC diagnostic push
+     #pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
      INT_SetScuFunc(now_vector_num, intr_func);        /* ベクタ登録        */
      INT_SetFunc(now_vector_num, NULL);          /* SCU割り込み関数の再登録   */
+     #pragma GCC diagnostic pop
  
      /* 割り込みベクタ登録 (end)***********************************************/
  
***************
*** 439,442 ****
  void DMA_ScuIntFunc2(void){
      INTR_FUNC(DMA_SCU_CH2, INT_SCU_DMA2);   /* DMAチャネル別終了割り込み処理 */
  }
! 
\ No newline at end of file
--- 445,448 ----
  void DMA_ScuIntFunc2(void){
      INTR_FUNC(DMA_SCU_CH2, INT_SCU_DMA2);   /* DMAチャネル別終了割り込み処理 */
  }
! 
diff -crBN --binary sbl6/segalib/dma/dma_scu1.c sbl6_patch/segalib/dma/dma_scu1.c
*** sbl6/segalib/dma/dma_scu1.c	1996-02-08 05:23:18.000000000 -0500
--- sbl6_patch/segalib/dma/dma_scu1.c	2021-11-14 20:08:26.000000000 -0500
***************
*** 35,40 ****
--- 35,41 ----
  /*
   * C STANDARD LIBRARY FUNCTIONS/MACROS DEFINES
   */
+ #include <string.h>
  
  /*
   * C VIRTUAL TYPES DEFINITIONS
***************
*** 238,241 ****
      }
  }
  
! 
\ No newline at end of file
--- 239,242 ----
      }
  }
  
! 
diff -crBN --binary sbl6/segalib/gfs/gfs.c sbl6_patch/segalib/gfs/gfs.c
*** sbl6/segalib/gfs/gfs.c	2021-11-14 19:22:22.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs.c	2023-01-07 14:48:10.000000000 -0500
***************
*** 28,33 ****
--- 28,34 ----
  #include    "gfs_dir.h"
  #include    "gfs_trn.h"
  #include    "gfs_cdc.h"
+ #include    "gfs_buf.h"
  
  
  #if !defined(USE_SGL)
***************
*** 1275,1282 ****
   *****************************************************************************/
  Sint32 GFS_NwExecServer(GfsHn *now_gfs)
  {
!     GfsSvr      *svr;
!     Sint32      stat, i;
  
      svr = &MNG_SVR(gfs_mng_ptr);
      for (i = 0; i < SVR_NFILE(svr); ++i) {
--- 1276,1283 ----
   *****************************************************************************/
  Sint32 GFS_NwExecServer(GfsHn *now_gfs)
  {
!     GfsSvr      *svr = NULL;
!     Sint32      stat = 0, i;
  
      svr = &MNG_SVR(gfs_mng_ptr);
      for (i = 0; i < SVR_NFILE(svr); ++i) {
***************
*** 1334,1339 ****
--- 1335,1341 ----
      }
      flow = &GFS_FILE_FLOW(gfs);
      dtsrc = &GFS_FLW_DTSRC(flow);
+     (void)dtsrc;
      old_mode = GFS_FLW_GMODE(flow);
      GFS_FLW_GMODE(flow) = gmode;
      ret = gfs_mngSetErrCode(GFS_ERR_OK);
***************
*** 1377,1382 ****
--- 1379,1385 ----
      }
      flow = &GFS_FILE_FLOW(gfs);
      dtsrc = &GFS_FLW_DTSRC(flow);
+     (void)dtsrc;
      trans = &GFS_FILE_TRANS(gfs);
      old_mode = GFTR_SetMode(trans, tmode);
      ret = gfs_mngSetErrCode(GFS_ERR_OK);
***************
*** 1999,2004 ****
--- 2002,2008 ----
          return NULL;
      }
      gftr = GFTR_Setup(&GFS_FILE_TRANS(gfs));
+     (void)gftr;
  #if defined(DEBUG_LIB)
      if (dirrec != NULL) {
          /* ソースバッファの設定 */
***************
*** 2235,2240 ****
--- 2239,2245 ----
      Bool        flag;
      GfsTrans    *trn = &GFS_FILE_TRANS(gfs);
  
+     (void)trn;
      /* 他のファイルが転送中か調べる */
      if ((MNG_TRANS(gfs_mng_ptr) != gfs)&&(MNG_TRANS(gfs_mng_ptr) != NULL)) {
          return GFS_SVR_BUSY;
***************
*** 2401,2406 ****
--- 2406,2412 ----
      GfsFlow     *flow = &GFS_FILE_FLOW(gfs);
      GfsTrans    *tran = &GFS_FILE_TRANS(gfs);
  
+     (void)tran;
      GFS_GetFileInfo(gfs, NULL, NULL, NULL, &atr);
      if ((GFS_FLW_STAT(flow) == GFS_FIN_END)&&
          ((GFBF_GetNumData(gfs) == 0)||(atr & GFS_ATR_CDDA))) {
diff -crBN --binary sbl6/segalib/gfs/gfs_cdb.c sbl6_patch/segalib/gfs/gfs_cdb.c
*** sbl6/segalib/gfs/gfs_cdb.c	1996-02-08 05:23:30.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_cdb.c	2023-01-04 18:51:36.000000000 -0500
***************
*** 259,265 ****
  Sint32 GFCB_Seek(GfsFlow *flow, Sint32 off, Sint32 org)
  {
      Sint32      nsct;
-     Sint32      ret;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
      if (off < 0) {
--- 259,264 ----
***************
*** 336,342 ****
   *****************************************************************************/
  GfdpHn GFCB_GetSrcPack(GfsFlow *flow, Sint32 usct)
  {
!     Sint32      len, ret, nsct;
      Sint32      sctsiz, fsct, lastsiz;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
      GfdpHn      dpk = &MNG_SRCPK(gfs_mng_ptr);
--- 335,341 ----
   *****************************************************************************/
  GfdpHn GFCB_GetSrcPack(GfsFlow *flow, Sint32 usct)
  {
!     Sint32      len, nsct;
      Sint32      sctsiz, fsct, lastsiz;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
      GfdpHn      dpk = &MNG_SRCPK(gfs_mng_ptr);
***************
*** 400,408 ****
  void GFCB_RtnPk(GfsFlow *flow, GfdpHn dpk, Sint32 nsct)
  {
      Sint32      txw;
-     Sint32      seekpos;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
      GFCD_EndData(&txw);
      /* 転送が終了しているので,アクセスポインタを進める  */
      if (nsct == GFTR_ALLSCT) {
--- 399,407 ----
  void GFCB_RtnPk(GfsFlow *flow, GfdpHn dpk, Sint32 nsct)
  {
      Sint32      txw;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
+     (void)dts;
      GFCD_EndData(&txw);
      /* 転送が終了しているので,アクセスポインタを進める  */
      if (nsct == GFTR_ALLSCT) {
diff -crBN --binary sbl6/segalib/gfs/gfs_cdc.c sbl6_patch/segalib/gfs/gfs_cdc.c
*** sbl6/segalib/gfs/gfs_cdc.c	1996-02-08 05:23:32.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_cdc.c	2023-01-04 19:05:16.000000000 -0500
***************
*** 1228,1234 ****
  /* タスク状態判定 */
  GFS_LOCAL Bool  gfcd_isIdleTask(Sint32 tsk)
  {
!     Sint32 stat;
  
      switch (tsk) {
      case TSK_ID_SETFLT:
--- 1228,1234 ----
  /* タスク状態判定 */
  GFS_LOCAL Bool  gfcd_isIdleTask(Sint32 tsk)
  {
!     Sint32 stat = 0;
  
      switch (tsk) {
      case TSK_ID_SETFLT:
***************
*** 1263,1268 ****
--- 1263,1269 ----
  /* タスク実行 */
  GFS_LOCAL Sint32        gfcd_doTask(Sint32 tsk, Sint32 *ncmd)
  {
+     Sint32 ret = 0;
      switch (tsk) {
      case TSK_ID_SETFLT:
          return gfcd_doSetFiltTsk(ncmd);
***************
*** 1280,1286 ****
--- 1281,1292 ----
          return gfcd_doSetFiltConTsk(ncmd);
      case TSK_ID_CHGDIR:
          return gfcd_doChgDirTsk(ncmd);
+      default:
+         // Error case, should crash  ?
+         return ret;
+      	
      }
+     return ret;
  }
  
  
***************
*** 1399,1405 ****
  GFS_LOCAL Sint32 gfcd_doGetLenDataTsk(Sint32 *ncmd)
  {
      Sint32      ret;
!     Sint32      actwsiz, nsct, st;
  
      if (TSK_GETLEN_STAT(gfcd_work) == GFCD_TSK_STAT1) {
          ret = CDC_GetSctNum(TSK_GETLEN_BUFNO(gfcd_work), &nsct);
--- 1405,1411 ----
  GFS_LOCAL Sint32 gfcd_doGetLenDataTsk(Sint32 *ncmd)
  {
      Sint32      ret;
!     Sint32      actwsiz, nsct;
  
      if (TSK_GETLEN_STAT(gfcd_work) == GFCD_TSK_STAT1) {
          ret = CDC_GetSctNum(TSK_GETLEN_BUFNO(gfcd_work), &nsct);
diff -crBN --binary sbl6/segalib/gfs/gfs_cdf.c sbl6_patch/segalib/gfs/gfs_cdf.c
*** sbl6/segalib/gfs/gfs_cdf.c	1996-02-08 05:23:32.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_cdf.c	2023-01-04 20:17:58.000000000 -0500
***************
*** 513,519 ****
  GFS_LOCAL Bool gfcf_isCdOk(GfsFlow *flow, Sint32 stat,  Sint32 *err)
  {
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
-     Sint32      fad;
  
      switch (stat) {
      case GFS_STAT_SEEK:
--- 513,518 ----
diff -crBN --binary sbl6/segalib/gfs/gfs_def.h sbl6_patch/segalib/gfs/gfs_def.h
*** sbl6/segalib/gfs/gfs_def.h	1996-02-08 05:23:34.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_def.h	2023-01-04 20:52:10.000000000 -0500
***************
*** 96,105 ****
  #define IS_ENDTBL(atr)  (((atr) & GFS_ATR_END_TBL)? TRUE: FALSE)
  
  /* 警告抑制のため */
! #define XSTRNCPY(s1, s2, n)     strncpy((Sint8 *)s1, (Sint8 *)s2, n)
! #define XSTRCPY(s1, s2)         strcpy((Sint8 *)s1, (Sint8 *)s2)
! #define XSTRNCMP(s1, s2, n)     strncmp((Sint8 *)s1, (Sint8 *)s2, n)
! #define XSTRCMP(s1, s2)         strcmp((Sint8 *)s1, (Sint8 *)s2)
  
  #define GFS_BYTE_SCT(byte, sctsiz)  \
      ((Sint32)(((Uint32)(byte)) + ((Uint32)(sctsiz)) - 1) / ((Uint32)(sctsiz)))
--- 96,105 ----
  #define IS_ENDTBL(atr)  (((atr) & GFS_ATR_END_TBL)? TRUE: FALSE)
  
  /* 警告抑制のため */
! #define XSTRNCPY(s1, s2, n)     strncpy((char *)s1, (const char *)s2, n)
! #define XSTRCPY(s1, s2)         strcpy((char *)s1, (const char *)s2)
! #define XSTRNCMP(s1, s2, n)     strncmp((const char *)s1, (const char *)s2, n)
! #define XSTRCMP(s1, s2)         strcmp(( char *)s1, (const char *)s2)
  
  #define GFS_BYTE_SCT(byte, sctsiz)  \
      ((Sint32)(((Uint32)(byte)) + ((Uint32)(sctsiz)) - 1) / ((Uint32)(sctsiz)))
diff -crBN --binary sbl6/segalib/gfs/gfs_dir.c sbl6_patch/segalib/gfs/gfs_dir.c
*** sbl6/segalib/gfs/gfs_dir.c	1996-02-08 05:23:34.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_dir.c	2023-01-07 14:16:24.000000000 -0500
***************
*** 202,216 ****
   *****************************************************************************/
  Sint32 GFDR_SetupDirTbl(GfsHn gfs, GfsDirTbl *dirtbl, Sint32 nsct)
  {
!     Sint32      ndir, atr, ec;
  
  #if !defined(DEBUG_LIB)
      if (gfs != NULL) {
          GFS_GetFileInfo(gfs, NULL, NULL, NULL, &atr);
          if ((atr & GFS_ATR_DIR) == 0) {
              return GFS_ERR_DIR;
          }
!         ec = GFS_NwCdRead(gfs, nsct);
          if (ec != GFS_ERR_OK) {
              return ec;
          }
--- 202,217 ----
   *****************************************************************************/
  Sint32 GFDR_SetupDirTbl(GfsHn gfs, GfsDirTbl *dirtbl, Sint32 nsct)
  {
!     Sint32      ndir;
  
  #if !defined(DEBUG_LIB)
      if (gfs != NULL) {
+     	Sint32 atr;
          GFS_GetFileInfo(gfs, NULL, NULL, NULL, &atr);
          if ((atr & GFS_ATR_DIR) == 0) {
              return GFS_ERR_DIR;
          }
!         Sint32 ec = GFS_NwCdRead(gfs, nsct);
          if (ec != GFS_ERR_OK) {
              return ec;
          }
***************
*** 678,686 ****
  /* CDからディレクトリエントリの必要な情報を読み込む */
  GFS_LOCAL Sint32 gfdr_readDirEnt(GfdrFile *fp, XaDirEnt *dir)
  {
!     Sint32      ec, i, rdsz, fn_err = FALSE;
      Uint8       fn_len, file_flg;
!     Sint8       ch, *fn_buf, *ext_pos;
  
      if (GFDR_FILE_GFS(fp) == NULL) {
          XA_DIR_RSIZE(dir) = 0;
--- 679,687 ----
  /* CDからディレクトリエントリの必要な情報を読み込む */
  GFS_LOCAL Sint32 gfdr_readDirEnt(GfdrFile *fp, XaDirEnt *dir)
  {
!     Sint32      ec, i, rdsz = FALSE;
      Uint8       fn_len, file_flg;
!     Sint8       ch = 0, *fn_buf, *ext_pos;
  
      if (GFDR_FILE_GFS(fp) == NULL) {
          XA_DIR_RSIZE(dir) = 0;
***************
*** 771,777 ****
                  ext_pos = fn_buf;       /* 拡張子の開始位置保存 */
                  break;
              }
-             fn_err = TRUE;
          }
      }
      while (i < fn_len) {
--- 772,777 ----
***************
*** 791,797 ****
              break;
          }
          if (fn_buf - ext_pos > GFDR_EXT_MAX) {
-             fn_err = TRUE;
              continue;
          }
          if (fn_buf - XA_DIR_FNAME(dir) < GFS_FNAME_LEN) {
--- 791,796 ----
diff -crBN --binary sbl6/segalib/gfs/gfs_mmb.c sbl6_patch/segalib/gfs/gfs_mmb.c
*** sbl6/segalib/gfs/gfs_mmb.c	1996-02-08 05:23:36.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_mmb.c	2023-01-07 14:17:20.000000000 -0500
***************
*** 23,28 ****
--- 23,29 ----
  #include    "gfs_mmc.h"
  #include    "gfs_mmb.h"
  #include    "gfs_trn.h"
+ #include    "gfs_mmf.h"
  
  /*****************************************************************************
   *      定数マクロ
***************
*** 107,113 ****
  {
      Sint32      ap;
      Sint32      nsct;
!     Sint32      lastsize;
      GfsFinfo    *finfo = &GFS_FLW_FINFO(flow);
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
--- 108,114 ----
  {
      Sint32      ap;
      Sint32      nsct;
!     Sint32      lastsize = 0;
      GfsFinfo    *finfo = &GFS_FLW_FINFO(flow);
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
***************
*** 169,174 ****
--- 170,176 ----
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
      GfdpHn      dtk = &gfmb_dtpk;
  
+     (void)dts;
      /* 転送が終了している場合   */
      if (nsct == GFTR_ALLSCT) {
          nsct = GFDP_NSCT(dpk);
diff -crBN --binary sbl6/segalib/gfs/gfs_mmf.c sbl6_patch/segalib/gfs/gfs_mmf.c
*** sbl6/segalib/gfs/gfs_mmf.c	1996-02-08 05:23:38.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_mmf.c	2023-01-04 20:53:32.000000000 -0500
***************
*** 124,129 ****
--- 124,131 ----
      GfsFinfo    *finfo = &GFS_FLW_FINFO(flow);
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
      
+     (void)finfo;
+     
      remain = GFS_FLW_SCT(flow) - GFS_FLW_SCTCNT(flow);
      if (remain <= 0) {
          return GFS_FIN_END;
diff -crBN --binary sbl6/segalib/gfs/gfs_sfb.c sbl6_patch/segalib/gfs/gfs_sfb.c
*** sbl6/segalib/gfs/gfs_sfb.c	1996-02-08 05:23:40.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_sfb.c	2023-01-04 20:54:54.000000000 -0500
***************
*** 154,163 ****
  /* データパック返還 */
  void GFSB_RtnPk(GfsFlow *flow, GfdpHn dtpk, Sint32 nsct)
  {
-     Sint32      seekpos;
      GfdpHn      dpk = &gfsb_dtpk;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
      /* 使用中のデータパックを変換することを確認 */
      if (GFDP_USE(dpk)) {
          /* 転送が終了している場合,アクセスポインタを進める  */
--- 154,163 ----
  /* データパック返還 */
  void GFSB_RtnPk(GfsFlow *flow, GfdpHn dtpk, Sint32 nsct)
  {
      GfdpHn      dpk = &gfsb_dtpk;
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
  
+     (void)dts;
      /* 使用中のデータパックを変換することを確認 */
      if (GFDP_USE(dpk)) {
          /* 転送が終了している場合,アクセスポインタを進める  */
diff -crBN --binary sbl6/segalib/gfs/gfs_sff.c sbl6_patch/segalib/gfs/gfs_sff.c
*** sbl6/segalib/gfs/gfs_sff.c	1996-02-08 05:23:40.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_sff.c	2023-01-04 20:55:18.000000000 -0500
***************
*** 139,144 ****
--- 139,146 ----
      GfsFinfo    *finfo = &GFS_FLW_FINFO(flow);
      GfsDtsrc    *dts = &GFS_FLW_DTSRC(flow);
      
+     (void)finfo;
+     
      remain = GFS_FLW_SCT(flow) - GFS_FLW_SCTCNT(flow);
      if (remain <= 0) {
          return GFS_FIN_END;
diff -crBN --binary sbl6/segalib/gfs/gfs_trn.c sbl6_patch/segalib/gfs/gfs_trn.c
*** sbl6/segalib/gfs/gfs_trn.c	1996-02-08 05:23:40.000000000 -0500
--- sbl6_patch/segalib/gfs/gfs_trn.c	2023-01-07 14:46:50.000000000 -0500
***************
*** 404,410 ****
   *****************************************************************************/
  Sint32 GFTR_Idle(GfsHn gfs)
  {
-     Sint32 tsct, tlen;
      GfsTrans    *trn = &GFS_FILE_TRANS(gfs);
  
      if (GFS_TRN_TSCT(trn) <= 0) {
--- 404,409 ----
***************
*** 450,456 ****
   *****************************************************************************/
  GFS_LOCAL Sint32 GFTR_ExecSvr(GfsHn gfs, Bool *flag)
  {
-     Sint32 tsct, tlen;
      Bool fl = FALSE;
      GfsTrans    *trn = &GFS_FILE_TRANS(gfs);
  
--- 449,454 ----
***************
*** 664,671 ****
          slDMAXCopy(src, dst, nbyte, tmode);
      }
  #else
-     Sint32 i, frac_buf;
-     Uint8 *frac;
      DmaCpuComPrm com_prm;
      DmaCpuPrm prm;
  
--- 662,667 ----
diff -crBN --binary sbl6/segalib/include/per_anlg.h sbl6_patch/segalib/include/per_anlg.h
*** sbl6/segalib/include/per_anlg.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_anlg.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,56 ----
+ /*
+ **■PER_ANLG.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ（アナログデバイス用）
+ **	
+ **	PER_GetAnalogXYZ()
+ **		標準アナログデバイスのＡ／Ｄコンバータの出力値を得る。
+ **	
+ **	SysDevAnalog
+ **		サターン標準アナログデバイス
+ */
+ #if	!defined( __PER_ANLG_H )
+ 	#define	__PER_ANLG_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	/*
+ 	**■SysDevAnalog
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（TYPE_ANALOG）
+ 	**	.size
+ 	**		ペリフェラルデータサイズ
+ 	**	.data[]
+ 	**		トリガ情報
+ 	**	.ax
+ 	**		Ｘ方向のＡ／Ｄコンバータの出力値（左0〜右255）
+ 	**	.ay
+ 	**		Ｙ方向のＡ／Ｄコンバータの出力値（上0〜下255）
+ 	**	.az
+ 	**		Ｚ方向のＡ／Ｄコンバータの出力値（下0〜上255）
+ 	**	.expended[]
+ 	**		拡張データ
+ 	*/
+ 	typedef	struct	SysDevAnalog	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	data[2];
+ 		Uint8	ax;
+ 		Uint8	ay;
+ 		Uint8	az;
+ 		Uint8	expanded[1];
+ 	} SysDevAnalog;
+ 	
+ 	/****************************************
+ 	*			declare functions			*
+ 	****************************************/
+ 	void	PER_GetAnalogXYZ( const SysDevAnalog	*this, int	*x, int	*y, int	*z );
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_dev.h sbl6_patch/segalib/include/per_dev.h
*** sbl6/segalib/include/per_dev.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_dev.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,95 ----
+ /*
+ **■PER_DEV.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ
+ **	
+ **	PER_GetID()
+ **		サターンペリフェラルＩＤを得る。
+ **	PER_GetType()
+ **		ペリフェラルタイプを得る。
+ **	PER_GetSize()
+ **		ペリフェラルデータのサイズを得る。
+ **	
+ **	SysDevice
+ **		サターン標準ペリフェラルの基本型
+ */
+ #if	!defined( __PER_DEV_H )
+ 	#define	__PER_DEV_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	
+ 	/****************************************
+ 	*			define constants			*
+ 	****************************************/
+ 	/*	サターンペリフェラルＩＤ	*/
+ 	#define	ID_UNCONNECTED	0xff
+ 	#define	ID_MD3B			0xe1
+ 	#define	ID_MD6B			0xe2
+ 	#define	ID_MDMOUSE		0xe3
+ 	#define	ID_DIGITAL		0x02
+ 	#define	ID_RACING		0x13
+ 	#define	ID_ANALOG		0x15
+ 	#define	ID_MOUSE		0x23
+ 	#define	ID_KEYBOARD		0x34
+ 	#define	ID_GUN			0xfa
+ 	
+ 	#define	ID_TYPE			0xf0
+ 	#define	ID_SIZE			0x0f
+ 	
+ 	/*	サターンペリフェラルタイプ	*/
+ 	#define	TYPE_DIGITAL	0x00
+ 	#define	TYPE_ANALOG		0x10
+ 	#define	TYPE_POINTER	0x20
+ 	#define	TYPE_KEYBOARD	0x30
+ 	#define	TYPE_MD			0xe0
+ 	#define	TYPE_UNKNOWN	0xf0
+ 	
+ 	/*	バーチャガンのトリガ情報	*/
+ 	#define	GUN_START		0x20
+ 	#define	GUN_TRIGGER		0x10
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	/*
+ 	**■SysDevice
+ 	**	.type
+ 	**		サターンペリフェラルタイプ
+ 	**	.size
+ 	**		ペリフェラルデータサイズ
+ 	**	.data[]
+ 	**		データ
+ 	*/
+ 	typedef	struct	SysDevice	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	data[1];
+ 	} SysDevice;
+ 	
+ 	/****************************************
+ 	*			declare functions			*
+ 	****************************************/
+ 	#if	!defined( __GNUC__ )
+ 		#define	inline
+ 	#endif
+ 	
+ 	static inline int	PER_GetType( const SysDevice	*this ){
+ 		return	( int )this->type;
+ 	}
+ 	static inline int	PER_GetSize( const SysDevice	*this ){
+ 		int		size = 0;
+ 		
+ 		if( PER_GetType( this ) != TYPE_UNKNOWN )
+ 			size = ( int )this->size;
+ 		
+ 		return	size;
+ 	}
+ 	static inline int	PER_GetID( const SysDevice	*this ){
+ 		return	( int )( this->type | this->size );
+ 	}
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_dgt.h sbl6_patch/segalib/include/per_dgt.h
*** sbl6/segalib/include/per_dgt.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_dgt.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,39 ----
+ /*
+ **■PER_DGT.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ（デジタルデバイス用）
+ **	
+ **	SysDevDigital
+ **		サターン標準デジタルデバイス
+ */
+ #if	!defined( __PER_DGT_H )
+ 	#define	__PER_DGT_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	/*
+ 	**■SysDevDigital
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（==TYPE_DIGITAL）
+ 	**	.size
+ 	**		ペリフェラルデータサイズ
+ 	**	.data[]
+ 	**		トリガ情報
+ 	**	.expended[]
+ 	**		拡張データ
+ 	*/
+ 	typedef	struct	SysDevDigital	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	data[2];
+ 		Uint8	expanded[1];
+ 	} SysDevDigital;
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_kbrd.h sbl6_patch/segalib/include/per_kbrd.h
*** sbl6/segalib/include/per_kbrd.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_kbrd.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,73 ----
+ /*
+ **■PER_KBRD.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ（キーボードデバイス用）
+ **	
+ **	PER_GetKeyboardType()
+ **		標準キーボードデバイスのタイプを得る。
+ **	
+ **	SysDevKeyboard
+ **		サターン標準キーボードデバイス
+ */
+ #if	!defined( __PER_KBRD_H )
+ 	#define	__PER_KBRD_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	
+ 	/****************************************
+ 	*			define constants			*
+ 	****************************************/
+ 	/*	キーボードタイプ		*/
+ 	#define	KB_TYPE		0x07
+ 	#define	KB_UNKNOWN	0x07
+ 	
+ 	/*	SysDevKeyboard.shift	*/
+ 	#define	K_CAPS		0x40
+ 	#define	K_NUM		0x20
+ 	#define	K_SCROLL	0x10
+ 	#define	K_MAKE		0x08
+ 	#define	K_BREAK		0x01
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	/*
+ 	**■SysDevKeyboard
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（==TYPE_KEYBOARD）
+ 	**	.size
+ 	**		拡張データ
+ 	**	.data[]
+ 	**		トリガ情報、キーボードタイプ。
+ 	**	.shift
+ 	**		シフトキー情報（K_CAPS,K_NUM,K_SCROLL,K_BREAK,K_MAKE）
+ 	**	.c
+ 	**		文字ナンバー
+ 	**	.expended[]
+ 	**		拡張データ
+ 	*/
+ 	typedef	struct	SysDevKeyboard	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	data[2];
+ 		Uint8	shift;
+ 		Uint8	c;
+ 		Uint8	expanded[1];
+ 	} SysDevKeyboard;
+ 	
+ 	/****************************************
+ 	*			declare functions			*
+ 	****************************************/
+ 	#if	!defined( __GNUC__ )
+ 		#define	inline
+ 	#endif
+ 	
+ 	static inline int	PER_GetKeyboardType( const SysDevKeyboard	*this ){
+ 		return	( int )( this->data[1] & KB_TYPE );
+ 	}
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_md.h sbl6_patch/segalib/include/per_md.h
*** sbl6/segalib/include/per_md.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_md.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,75 ----
+ /*
+ **■PER_MD.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ（メガドライブ用ペリフェラル用）
+ **	
+ **	DevMD3B
+ **		メガドライブ・３ボタンパッド
+ **	DevMD6B
+ **		メガドライブ・６ボタンパッド
+ **	DevMDMouse
+ **		メガドライブ・マウス
+ */
+ #if	!defined( __PER_MD_H )
+ 	#define	__PER_MD_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	/*
+ 	**■DevMD3B
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（==TYPE_MD）
+ 	**	.size
+ 	**		ペリフェラルデータサイズ（==1）
+ 	**	.data[]
+ 	**		トリガ情報
+ 	*/
+ 	struct	DevMD3B	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	data[1];
+ 	};
+ 	
+ 	/*
+ 	**■DevMD6B
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（==TYPE_MD）
+ 	**	.size
+ 	**		ペリフェラルデータサイズ（==2）
+ 	**	.data[]
+ 	**		トリガ情報
+ 	*/
+ 	struct	DevMD6B	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	data[2];
+ 	};
+ 	
+ 	/*
+ 	**■DevMDMouse
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（==TYPE_MD）
+ 	**	.size
+ 	**		ペリフェラルデータサイズ（==3）
+ 	**	.status
+ 	**		トリガ情報、移動量の符号、移動量のオーバーフロー。
+ 	**	.dx
+ 	**	.dy
+ 	**		ＸＹ方向の移動量の絶対値（0〜255）
+ 	*/
+ 	struct	DevMDMouse	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	status;
+ 		Uint8	dx;
+ 		Uint8	dy;
+ 	};
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_poin.h sbl6_patch/segalib/include/per_poin.h
*** sbl6/segalib/include/per_poin.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_poin.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,75 ----
+ /*
+ **■PER_POIN.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ（ポインティングデバイス用）
+ **	
+ **	PER_GetPointerXY()
+ **		標準ポインティングデバイスの移動量を得る。
+ **	
+ **	SysDevPointer
+ **		サターン標準ポインティングデバイス
+ */
+ #if	!defined( __PER_POIN_H )
+ 	#define	__PER_POIN_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	
+ 	/****************************************
+ 	*			define constants			*
+ 	****************************************/
+ 	/*	SysDevPointer.status	*/
+ 	#define	PT_OVER_Y	0x80
+ 	#define	PT_OVER_X	0x40
+ 	#define	PT_SIGN_Y	0x20
+ 	#define	PT_SIGN_X	0x10
+ 	#define	PT_START	0x08
+ 	#define	PT_MIDDLE	0x04
+ 	#define	PT_RIGHT	0x02
+ 	#define	PT_LEFT		0x01
+ 	#define	PT_TRIGGER	0x0f
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	/*
+ 	**■SysDevPointer
+ 	**	.type
+ 	**		サターンペリフェラルタイプ（==TYPE_POINTER）
+ 	**	.size
+ 	**		ペリフェラルデータサイズ
+ 	**	.status
+ 	**		トリガ情報、移動量の符号、移動量のオーバーフロー。
+ 	**	.dx
+ 	**	.dy
+ 	**		ＸＹ方向の移動量の絶対値（0〜255）
+ 	**	.expended[]
+ 	**		拡張データ
+ 	*/
+ 	typedef	struct	SysDevPointer	{
+ 		Uint8	type;
+ 		Uint8	size;
+ 		Uint8	status;
+ 		Uint8	dx;
+ 		Uint8	dy;
+ 		Uint8	expanded[1];
+ 	} SysDevPointer;
+ 	
+ 	/****************************************
+ 	*			declare functions			*
+ 	****************************************/
+ 	#if	!defined( __GNUC__ )
+ 		#define	inline
+ 	#endif
+ 	
+ 	static inline void	PER_GetPointerXY( const SysDevPointer	*this, int	*dx, int	*dy ){
+ 		if( dx != NULL )
+ 			*dx = ( int )( signed char )this->dx;
+ 		if( dy != NULL )
+ 			*dy = -( int )( signed char )this->dy;
+ 	}
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_trg.h sbl6_patch/segalib/include/per_trg.h
*** sbl6/segalib/include/per_trg.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_trg.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,135 ----
+ /*
+ **■PER_TRG.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ（トリガ情報について）
+ **	
+ **	PER_DisguiseTrigger()
+ **		トリガ情報をアサインテーブルにしたがって変換する。
+ **	
+ **	PER_GetTrigger()
+ **		指定されたタイミングでのトリガ情報を得る。
+ **		（アサインテーブルが指定されていれば、それにしたがって変換する）
+ **	PER_GetEdge()
+ **		指定された２つのタイミングの間で変化したトリガ情報を得る。
+ **	PER_GetPressEdge()
+ **		指定された２つのタイミングの間で押されたトリガ情報を得る。
+ **	PER_GetReleaseEdge()
+ **		指定された２つのタイミングの間で放されたトリガ情報を得る。
+ **	
+ **	PER_SetTriggerHandler()
+ **		指定されたＩＤを持つペリフェラル用のトリガハンドラを登録する。
+ **	PER_GetTriggerHandler()
+ **		指定されたＩＤを持つペリフェラル用のトリガハンドラを得る。
+ **	
+ **	assigment_t
+ **		トリガ情報変換テーブル（アサインテーブル）
+ **	trigger_t
+ **		トリガ情報
+ **	trigger_handler_t
+ **		トリガハンドラ（デバイスからトリガ情報を取り出すためのハンドラ）
+ */
+ #if	!defined( __PER_TRG_H )
+ 	#define	__PER_TRG_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	#include	"sega_per.h"
+ 	
+ 	/****************************************
+ 	*			define constants			*
+ 	****************************************/
+ 	/*
+ 	**■trigger_t
+ 	**	TRG_A       Ａボタン
+ 	**	TRG_B       Ｂボタン
+ 	**	TRG_C       Ｃボタン
+ 	**	TRG_X       Ｘボタン
+ 	**	TRG_Y       Ｙボタン
+ 	**	TRG_Z       Ｚボタン
+ 	**	TRG_L       Ｌボタン
+ 	**	TRG_R       Ｒボタン
+ 	**	TRG_UP      ↑
+ 	**	TRG_DOWN    ↓
+ 	**	TRG_LEFT    ←
+ 	**	TRG_RIGHT   →
+ 	**	TRG_START   スタートボタン
+ 	**	
+ 	**	標準ポインティングデバイスの  右  のボタンは TRG_A
+ 	**	標準ポインティングデバイスの真ん中のボタンは TRG_C
+ 	**	標準ポインティングデバイスの  左  のボタンは TRG_B
+ 	**	標準ポインティングデバイスには TRG_START,A,B,C しかない。
+ 	**	メガドライブ６Ｂパッドのモードボタンは TRG_R
+ 	**	メガドライブ６Ｂパッドには TRG_L はない。
+ 	**	メガドライブ３Ｂパッドには TRG_X,Y,Z,L,R はない。
+ 	**	レーシングコントローラーには Y,Z 方向のアナログ出力はない。
+ 	**	レーシングコントローラーには TRG_LEFT,RIGHT,L,R はない。
+ 	**	
+ 	**	TRG_MODE	メガドライブ６ボタンパッドのモードボタン
+ 	**	TRG_RESET	ソフトフェアリセット
+ 	*/
+ 	#define	TRG_B		PER_DGT_B
+ 	#define	TRG_C		PER_DGT_C
+ 	#define	TRG_A		PER_DGT_A
+ 	#define	TRG_START	PER_DGT_S
+ 	#define	TRG_UP		PER_DGT_U
+ 	#define	TRG_DOWN	PER_DGT_D
+ 	#define	TRG_LEFT	PER_DGT_L
+ 	#define	TRG_RIGHT	PER_DGT_R
+ 	#define	TRG_L		PER_DGT_TL
+ 	#define	TRG_Z		PER_DGT_Z
+ 	#define	TRG_Y		PER_DGT_Y
+ 	#define	TRG_X		PER_DGT_X
+ 	#define	TRG_R		PER_DGT_TR
+ 	
+ 	#define	TRG_MODE	TRG_R
+ 	
+ 	#define	TRG_RESET	(TRG_START|TRG_A|TRG_B|TRG_C)
+ 	
+ 	#define	TRIGGER_BIT	16
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	typedef Uint16	trigger_t;
+ 	
+ 	/*
+ 	**■assignment_t
+ 	**	メンバの順番を変更してはいけない。メンバの順番は trigger_t 用の定
+ 	**	数 'TRG_???' のビット並びと対応している。
+ 	*/
+ 	typedef	struct assignment_t	{
+ 		trigger_t	reserved1[3];
+ 		trigger_t	l;
+ 		trigger_t	z;
+ 		trigger_t	y;
+ 		trigger_t	x;
+ 		trigger_t	r;
+ 		trigger_t	b;
+ 		trigger_t	c;
+ 		trigger_t	a;
+ 		trigger_t	start;
+ 		trigger_t	up;
+ 		trigger_t	down;
+ 		trigger_t	left;
+ 		trigger_t	right;
+ 	} assignment_t;
+ 	
+ 	typedef trigger_t	( *trigger_handler_t )( const SysDevice * );
+ 	
+ 	/****************************************
+ 	*			declare functions			*
+ 	****************************************/
+ 	trigger_t	PER_DisguiseTrigger( const assignment_t	*assignment, trigger_t	trigger );
+ 	
+ 	void	PER_SetTriggerHandler( int	id, trigger_handler_t	handler );
+ 	trigger_handler_t	PER_GetTriggerHandler( int	id );
+ 	
+ 	trigger_t	PER_GetTrigger( const SysDevice	*this );
+ 	trigger_t	PER_GetEdge( trigger_t	t1, trigger_t	t2 );
+ 	trigger_t	PER_GetPressEdge( trigger_t	prev, trigger_t	current );
+ 	trigger_t	PER_GetReleaseEdge( trigger_t	prev, trigger_t	current );
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/per_x.h sbl6_patch/segalib/include/per_x.h
*** sbl6/segalib/include/per_x.h	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/include/per_x.h	1996-02-08 05:30:30.000000000 -0500
***************
*** 0 ****
--- 1,94 ----
+ /*
+ **■PER_X.H
+ **	ペリフェラルライブラリの高水準Ｉ／Ｆライブラリ
+ **	
+ **	PER_OpenPort()
+ **		ペリフェラルライブラリを初期化する。
+ **	PER_GetPort()
+ **		ペリフェラルデータを収集する。
+ **		（ V-BLANK-OUT 割り込みハンドラの中でコールすること。）
+ **	PER_GetDeviceA()
+ **		収集したペリフェラルデータからデバイス情報を得る。（絶対位置指定）
+ **	PER_GetDeviceR()
+ **		収集したペリフェラルデータからデバイス情報を得る。（相対位置指定）
+ **	
+ **	SysPort
+ **		ペリフェラル情報
+ **	
+ **	
+ **	下記の３つの定数の値を適宜変更し、再コンパイルして使用してください。
+ **	_MAX_PORT
+ **		ＳＡＴＵＲＮ本体についている端子の数
+ **		（通常は、2 に設定しておく）
+ **	_MAX_PERIPHERAL
+ **		１つの端子に接続可能なペリフェラルの数
+ **		（通常は、マルチターミナルに対応するために 6 以上に設定しておく）
+ **	SZ_PERIPHERAL
+ **		１つのペリフェラルのデータサイズの最大
+ **	
+ **	SZ_BUFFER
+ **		ペリフェラルライブラリが使用するワークエリアのサイズです。
+ */
+ #if	!defined( __PER_X_H )
+ 	#define	__PER_X_H
+ 	
+ 	/****************************************
+ 	*			include files				*
+ 	****************************************/
+ 	#include	"sega_xpt.h"
+ 	#include	"sega_per.h"
+ 	
+ 	#include	"per_dev.h"
+ 	#include	"per_dgt.h"
+ 	#include	"per_anlg.h"
+ 	#include	"per_poin.h"
+ 	#include	"per_kbrd.h"
+ 	#include	"per_md.h"
+ 	#include	"per_trg.h"
+ 	
+ 	/****************************************
+ 	*			define constants			*
+ 	****************************************/
+ 	#define	EXIT_SUCCESS	0
+ 	
+ 	#define	_MAX_PORT		2
+ 	#define	_MAX_PERIPHERAL	6
+ 	#define	SZ_PERIPHERAL	5
+ 	#define	SZ_BUFFER		((_MAX_PORT*_MAX_PERIPHERAL*(SZ_PERIPHERAL+2)*2)+SZ_PERIPHERAL)
+ 	
+ 	#define	PID_GUN		0x0a
+ 	
+ 	#define	MID_GUN		0xa0
+ 	
+ 	#define	PER_LOCK	0x00000001
+ 	
+ 	/****************************************
+ 	*		declare object types			*
+ 	****************************************/
+ 	typedef	Uint8	SysPeripheral[SZ_PERIPHERAL+2];
+ 	
+ 	typedef	struct	SysPort	{
+ 		Uint8			id;
+ 		Uint8			connectable;
+ 		SysPeripheral	*peripheral;
+ 	} SysPort;
+ 	
+ 	/****************************************
+ 	*			declare functions			*
+ 	****************************************/
+ 	#if	!defined( __GNUC__ )
+ 		#define	inline
+ 	#endif
+ 	
+ 	static inline int	PER_GetPortID( SysPort	*port ){
+ 		return	( int )( port->id >> 4 );
+ 	}
+ 	
+ 	SysPort		*PER_OpenPort( void );
+ 	void		PER_GetPort( SysPort	*port );
+ 	const SysDevice	*PER_GetDeviceA( const SysPort	*port, Uint32	n );
+ 	const SysDevice	*PER_GetDeviceR( const SysPort	*port, Uint32	n );
+ 	
+ #endif
+ 
+ 
\ No newline at end of file
diff -crBN --binary sbl6/segalib/include/sega_int.h sbl6_patch/segalib/include/sega_int.h
*** sbl6/segalib/include/sega_int.h	1996-02-08 05:23:46.000000000 -0500
--- sbl6_patch/segalib/include/sega_int.h	2021-12-26 18:28:36.000000000 -0500
***************
*** 499,502 ****
  #endif
  
  #endif  /* ifndef SEGA_INT_H */
! 
\ No newline at end of file
--- 499,502 ----
  #endif
  
  #endif  /* ifndef SEGA_INT_H */
! 
diff -crBN --binary sbl6/segalib/include/sega_per.h sbl6_patch/segalib/include/sega_per.h
*** sbl6/segalib/include/sega_per.h	1996-02-08 05:23:48.000000000 -0500
--- sbl6_patch/segalib/include/sega_per.h	2022-09-24 08:41:04.000000000 -0400
***************
*** 233,239 ****
      PerMulCon   con;
  }PerMulInfo;                                    /* マルチタップ情報          */
  
! typedef struct  {                               /* システム出力              */
      Uint8   cc;                                 /* カートリッジコード        */
      Uint8   ac;                                 /* エリアコード              */
      Uint16  ss;                                 /* システムステータス        */
--- 233,239 ----
      PerMulCon   con;
  }PerMulInfo;                                    /* マルチタップ情報          */
  
! typedef struct __attribute__ ((aligned (16))) { /* システム出力              */
      Uint8   cc;                                 /* カートリッジコード        */
      Uint8   ac;                                 /* エリアコード              */
      Uint16  ss;                                 /* システムステータス        */
***************
*** 612,627 ****
   */
  
  /********************************* persprt.h *********************************/
! #if 0
!     以下 DISK Version 1994-11-11の追加分
!     
!     ◆システム／ペリフェラルライブラリ使用サンプルプログラムへの対処
!         システム／ペリフェラルライブラリを使用している各ライブラリの
!         サンプルプログラムのために今回のシステム／ペリフェラルライブラリには、
!         以前のバージョンの関数、定数等を含めています。但し、この関数、定数等は
!         、4thSTEPでは削除します。
!         以前のバージョンの関数、定数等は使用しないでください。
! #endif
  /*
   * GLOBAL DEFINES/MACROS DEFINES
   */
--- 612,618 ----
   */
  
  /********************************* persprt.h *********************************/
! 
  /*
   * GLOBAL DEFINES/MACROS DEFINES
   */
***************
*** 783,786 ****
  
  #endif  /* ifndef SEGA_PER_H */
  /******************************* end of file *********************************/
! 
\ No newline at end of file
--- 774,777 ----
  
  #endif  /* ifndef SEGA_PER_H */
  /******************************* end of file *********************************/
! 
diff -crBN --binary sbl6/segalib/include/sega_scl.h sbl6_patch/segalib/include/sega_scl.h
*** sbl6/segalib/include/sega_scl.h	1995-09-29 10:30:48.000000000 -0400
--- sbl6_patch/segalib/include/sega_scl.h	2024-08-19 13:24:44.000000000 -0400
***************
*** 1,1440 ****
! /*------------------------------------------------------------------------
!  *  FILE:	SEGA_SCL.H
!  *
!  *	Copyright(c) 1994 SEGA
!  *
!  *  PURPOSE:
!  *	Scroll Simulation program header file
!  *	Scroll Register Data Structure Definition File
!  *
!  *  AUTHOR(S):
!  *	K.M
!  *		
!  *  MOD HISTORY:
!  *	Written by K.M on 1994-05-20 Ver.1.00
!  *	Updated by K.M on 1994-07-01 Ver.1.00
!  * 
!  *------------------------------------------------------------------------
!  */
! 
! #ifndef	SEGA_SCR_H
! #define SEGA_SCR_H
! 
! #include <sega_xpt.h>
! #include <sega_def.h>
! #include <sega_mth.h> 
! 
! #define VBR              0x06000000
! #define SCU_BASE         0x25FE0000
! #define SCU_INTR_MASK    0x000000a0
! #define SCU_INTR_STATUS  0x000000a4
! #define SETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x300)))
! #define GETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x304)))
! #define SETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x310)))
! #define GETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x314)))
! #define VBIVN	0x40
! #define VBOVN	0x41
! #define HBIVN	0x42
! 
! /*********************************************
!  *      System Register Cluster	             *
!  *      Address ranger 180000H - 180027H     *
!  *********************************************/
!  typedef struct	SclSysreg{
! 	Uint16	tvmode;			/* TV Mode */
! 	Uint16	extenbl;		/* External Input Enable */
! 	Uint16	tvstatus;		/* TV Status Read Only */
! 	Uint16	vramsize;		/* VRAM Size */
! 	Uint16	H_val;			/* H Counter Read Only */
! 	Uint16	V_val;			/* V Counter Read Only */
! 	Uint16	vramchg;		/* VRAM Change */
! 	Uint16	ramcontrl;		/* RAM Control */
! 	Uint16	vramcyc[8];		/* VRAM Cycle Table x8 */
! 	Uint16	dispenbl;		/* Display Enable */
! 	Uint16	mosaic;			/* Mosaic Control */
! 	Uint16	specialcode_sel;	/* Special Code Selector */
! 	Uint16	specialcode;		/* Special Code */
!  } SclSysreg;
! 
! /**********************************************
!  *      Scroll Data Set Register Cluster      *
!  *      Address ranger 180028H - 18006FH      *
!  **********************************************/
! typedef struct SclDataset{
! 	Uint16	charcontrl0;		/* Character Control */
! 	Uint16	charcontrl1;		/* Character Control */
! 	Uint16	bmpalnum0;		/* Bitmap Palette Number */
! 	Uint16	bmpalnum1;		/* Bitmap Palette Number */
! 	Uint16	patnamecontrl[5];	/* Pattern Name Controlx5 */
! 	Uint16	platesize;		/* Plate Size */	
! 	Uint16	mapoffset0;		/* Map Offset */
! 	Uint16	mapoffset1;		/* Map Offset */
! 	Uint16	normap[8];		/* Normal Scroll Map x8*/
! 	Uint16	rotmap[16];		/* Rotate Scroll Map x16*/
! } SclDataset;
! 
! /***************************************************
!  *      Normal Scroll Function Register Cluster    *
!  *      Address ranger 180070H - 1800AFH           *
!  ***************************************************/
! typedef struct SclNorscl{
! 	Fixed32	n0_move_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_move_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n0_delta_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_delta_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n1_move_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_move_y;		/* NBG1 Scroll Movement Y */
! 	Fixed32	n1_delta_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_delta_y;		/* NBG1 Scroll Movement Y */
! 	Uint16	n2_move_x;		/* NBG2 Scroll Movement X */
! 	Uint16	n2_move_y;		/* NBG2 Scroll Movement Y */
! 	Uint16	n3_move_x;		/* NBG3 Scroll Movement X */
! 	Uint16	n3_move_y;		/* NBG3 Scroll Movement Y */
! 	Uint16	zoomenbl;		/* Zoom Enable */
! 	Uint16	linecontrl;		/* Normal Extension Control */
! 	Uint32	celladdr;		/* Cell Scroll Table Address */
! 	Uint32	lineaddr[2];		/* Line Scroll Table Address x2 */
! 	Uint32	linecolmode;		/* Line BG Color Mode Address */
! 	Uint32	backcolmode;		/* Back BG Color Mode Address */
! } SclNorscl;
! 
! /****************************************************
!  *      Rotate Scroll Function Register Cluster     *
!  *      Address ranger 1800B0H - 1800BFH            *
!  ****************************************************/
! typedef struct SclRotscl{
! 	Uint16	paramode;		/* Rotate Parameter Mode */
! 	Uint16	paramcontrl;		/* Rotate Parameter Read Control */
! 	Uint16	k_contrl;		/* Keisu Table Control */
! 	Uint16	k_offset;		/* Keisu Addres Offset */
! 	Uint16	mapover[2];		/* Rotate Scroll Map Over */
! 	Uint32	paramaddr;		/* Rotate Parameter Tabel Address */
! } SclRotscl;
! 
! /***************************************************
!  *      Window Scroll Setting Register Cluster     *
!  *      Address ranger 1800C0H - 1800DFH           *
!  ***************************************************/
! typedef struct SclWinscl{
! 					/* 1800C0 */
! 	Uint16	win0_start[2];		/* Window #0 Start X & Y */
! 					/* 1800C4 */
! 	Uint16	win0_end[2];		/* Window #0 End X & Y */
! 					/* 1800C8 */
! 	Uint16	win1_start[2];		/* Window #1 Start X & Y */
! 					/* 1800CC */
! 	Uint16	win1_end[2];		/* Window #1 End X & Y */
! 					/* 1800D0 */
! 	Uint16	wincontrl[4];		/* Window Control */
! 					/* 1800D8 */
! 	Uint32 	linewin0_addr;		/* Line Window #0 Table Address */ 
! 					/* 1800DC */
! 	Uint32 	linewin1_addr;		/* Line Window #1 Table Address */ 
! } SclWinscl;
! 
! /***********************************************
!  *      Priority Related Register Cluster      *
!  ***********************************************/
! typedef struct SclPrior{
! 	Uint16	prnum;
! } SclPrior;
! 
! 
! /**************************************************
!  *      Scroll Parameters Definition              *
!  **************************************************/
! typedef struct  SclXy {
! 	 Fixed32         x;
! 	 Fixed32         y;
! } SclXy;
! 
! typedef struct  SclXyz {
! 	 Fixed32         x;
! 	 Fixed32         y;
! 	 Fixed32         z;
! } SclXyz;
! 
! typedef struct  SclXy16 {
!         Uint16         x;
!         Uint16         y;
! } SclXy16;
! 
! typedef struct  SclXyz16 {
!         Sint16         x;
!         Sint16         y;
!         Sint16         z;
! } SclXyz16;
! 
! typedef struct  SclRgb {
! 	 Sint16		red;
! 	 Sint16		green;
! 	 Sint16		blue;
! } SclRgb;
! 
! typedef struct  SclLineTb {
! 	 Fixed32	h;
! 	 Fixed32	v;
! 	 Fixed32	dh;
! } SclLineTb;
! 
! typedef struct  SclLineWindowTb {
! 	 Uint16		start;
! 	 Uint16		end;
! } SclLineWindowTb;
! 
! typedef struct SclVramConfig{
! 	Uint32	ktboffsetA;/* 回転ﾊﾟﾗﾒｰﾀA用係数ﾃｰﾌﾞﾙをﾊﾞﾝｸ中のどこに配置するか */
! 	Uint32	ktboffsetB;/* 回転ﾊﾟﾗﾒｰﾀB用係数ﾃｰﾌﾞﾙをﾊﾞﾝｸ中のどこに配置するか */
! 	Uint8	vramModeA; /* VRAM A を２つのバンクに区切るか指定(0/1)  */
! 	Uint8	vramModeB; /* VRAM B を２つのバンクに区切るか指定(0/1)  */
! 	Uint8	vramA0;    /* VRAM A or A0 を回転面の何で使用するか指定 */
! 	Uint8	vramA1;    /* VRAM A1 を回転面の何で使用するか指定      */
! 	Uint8	vramB0;    /* VRAM B or B0 を回転面の何で使用するか指定 */
! 	Uint8	vramB1;    /* VRAM B1 を回転面の何で使用するか指定      */
! 	Uint8	colram;    /* カラーＲＡＭに係数データを置くか？        */
! } SclVramConfig;
! 
! typedef struct SclRotreg{
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	SclXyz16	viewp;
! 	Uint16		dummy1;
! 	SclXyz16	rotatecenter;
! 	Uint16		dummy2;
! 	SclXy		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! /*	Fixed32		dummy3[8];	*/
! 	Fixed32		dummy3[2];
! } SclRotreg;
! 
! typedef struct SclRotparam{
! 	Uint32		addr;
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	Fixed32		matrix_g;
! 	Fixed32		matrix_h;
! 	Fixed32		matrix_i;
! 	Fixed32		drotangle;
! 	SclXyz		viewp;
! 	SclXyz		rotatecenter;
! 	SclXyz		disprotcenter;
! 	SclXyz		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! 	Uint16		k_size;
! } SclRotparam;
! 
! /*******************************************
!  *      Scroll Configure Data Structure    *
!  *******************************************/
! typedef	struct	SclConfig {
! 	Uint8		dispenbl;
! 	Uint8		charsize;
! 	Uint8		pnamesize;
! 	Uint8		platesize;
! 	Uint8		bmpsize;
! 	Uint8		coltype;
! 	Uint8		datatype;
! 	Uint8		mapover;
! 	Uint8		flip;
! 	Uint16		patnamecontrl;
! /*	Uint32		plate_addr[16];		1995.9.29 cyoshida */
! 	Uint32		plate_addr[32];
! } SclConfig;
! 
! /******************************************************
!  *      Line & Cell Scroll Parameter Data Structure   *
!  ******************************************************/
! #define	SCL_MAXLINE	512
! #define	SCL_MAXCELL	64
! 
! typedef	struct	SclLineparam{
! 	Uint8		delta_enbl;
! 	Uint8		v_enbl;
! 	Uint8		h_enbl;
! 	Uint8		cell_enbl;
! 	Uint8		interval;
! 	Uint32		line_addr;
! 	Uint32		cell_addr;
! 	SclLineTb	line_tbl[SCL_MAXLINE];
! 	Fixed32		cell_tbl[SCL_MAXCELL];
! }	SclLineparam;
! 
! typedef	struct	SclLineWin{
! 	Uint16		winum;
! 	Uint16		y[2];
! 	Uint32		addr;
! 	SclXy16		tbl[SCL_MAXLINE];
! }	SclLineWin;
! 
! /***tuika c.yoshida******/
! 
! typedef	struct	SclSblSgl{
! 	Uint16		sgl_flag;
! }SclSblSgl;
! 
! /************************/
! 
! #define SCL_VDP2_VRAM		0x25e00000
! #define SCL_VDP2_VRAM_A		0x25e00000
! #define SCL_VDP2_VRAM_A0	0x25e00000
! #define SCL_VDP2_VRAM_A1	0x25e20000
! #define SCL_VDP2_VRAM_B		0x25e40000
! #define SCL_VDP2_VRAM_B0	0x25e40000
! #define SCL_VDP2_VRAM_B1	0x25e60000
! #define	SCL_COLRAM_ADDR		0x25F00000	/* Color RAM */
! 
! #define SCL_NON			0   /* RBG0では使用しない        */
! #define SCL_RBG0_K 		1   /* RBG0の係数ﾃｰﾌﾞﾙを置く     */
! #define SCL_RBG0_PN 		2   /* RBG0のﾊﾟﾀｰﾝﾈｰﾑﾃｰﾌﾞﾙを置く */
! #define SCL_RBG0_CHAR 		3   /* RBG0のｷｬﾗｸﾀを置く         */
! #define SCL_RBG1_K 		4   /* RBG1の係数ﾃｰﾌﾞﾙを置く     */
! 
! #define	SCL_CHAR_SIZE_1X1	0
! #define	SCL_CHAR_SIZE_2X2	1
! 
! #define	SCL_PN2WORD		0
! #define	SCL_PN1WORD		1
! 
! #define	SCL_PL_SIZE_1X1		0
! #define	SCL_PL_SIZE_2X1		1
! #define	SCL_PL_SIZE_2X2		3
! 
! #define	SCL_BMP_SIZE_512X256	0
! #define	SCL_BMP_SIZE_512X512	1
! #define	SCL_BMP_SIZE_1024X256	2
! #define	SCL_BMP_SIZE_1024X512	3
! 
! #define	SCL_COL_TYPE_16		0
! #define	SCL_COL_TYPE_256	1
! #define	SCL_COL_TYPE_2048	2
! #define	SCL_COL_TYPE_32K	3
! #define	SCL_COL_TYPE_1M		4
! 
! #define	SCL_CELL		0
! #define	SCL_BITMAP		1
! 
! #define	SCL_OVER_0		0
! #define	SCL_OVER_1		1
! #define	SCL_OVER_2		2
! #define	SCL_OVER_3		3
! 
! #define	SCL_PN_10BIT		0
! #define	SCL_PN_12BIT		1
! 
! #define	SCL_1_LINE		0
! #define	SCL_2_LINE		1
! #define	SCL_4_LINE		2
! 
! #define	SCL_NON_INTER		0
! #define	SCL_SINGLE_INTER	2
! #define	SCL_DOUBLE_INTER	3
! 
! #define	SCL_224LINE		0
! #define	SCL_240LINE		1
! #define	SCL_256LINE		2
! 
! #define	SCL_NORMAL_A		0
! #define	SCL_NORMAL_B		1
! #define	SCL_HIRESO_A		2
! #define	SCL_HIRESO_B		3
! #define	SCL_NORMAL_AE		4
! #define	SCL_NORMAL_BE		5
! #define	SCL_HIRESO_AE		6
! #define	SCL_HIRESO_BE		7
! 
! #define	SCL_X_AXIS		1
! #define	SCL_Y_AXIS		2
! 
! #define	SCL_W0			0
! #define	SCL_W1			1
! 
! #define FIXED(x)	      ((Fixed32)((x) * 65536.0))
! #define MUL_FIXED(a, b)       MTH_Mul(a, b)
! #define DIV_FIXED(a, b)       MTH_Div(a, b)
! 
! #endif	/* ifndef SEGA_SCR_H */
! 
! 
! /*------------------------------------------------------------------------
!  *  
!  *
!  *  DESCRIPTION:
!  *
!  *          Header file for Priority library internal use.
!  *          Each Macro Set a parameter on Register buffer.
!  *          the buffer will copy to REAL regster while V-interval.
!  *          ここにあるマクロは、レジスタバッファに各コントロール値を
!  *          書き込み、書き込んだレジスタバッファのダーティーフラグを
!  *          1 にする。
! -------------------------------------------------------------------------*/
! 
! #ifndef __PRI_GLVAR
! #define __PRI_GLVAR
! 
! #ifndef __PRI_MACRO
! #define __PRI_MACRO
! 
! #ifndef __PRI_REG
! #define __PRI_REG
! 
! /*-----< other group regs >----*/
! typedef struct {
!     Uint16 SpriteControl;		/* 1800E0 */
!     Uint16 ShadowControl;		/* 1800E2 */
!     Uint16 ColorRamOffset0;		/* 1800E4 */
!     Uint16 ColorRamOffset1;		/* 1800E6 */
!     Uint16 LineColorEnable;		/* 1800E8 */
!     Uint16 SpecialPriorityMode;		/* 1800EA */
!     Uint16 ColorMixControl;		/* 1800EC */
!     Uint16 SpecialColorMixMode;		/* 1800EE */
! } SclOtherPriRegister;
! 
! /*----< sprite priority >----*/
! typedef struct {
!     Uint16 PriorityNumberSP01;		/* 1800F0 */
!     Uint16 PriorityNumberSP23;		/* 1800F2 */
!     Uint16 PriorityNumberSP45;		/* 1800F4 */
!     Uint16 PriorityNumberSP67;		/* 1800F6 */
! } SclSpPriNumRegister;
! 
! /*----< scroll priority >----*/
! typedef struct {
!     Uint16 PriorityNumberNBG01;		/* 1800F8 */
!     Uint16 PriorityNumberNBG23;		/* 1800FA */
!     Uint16 PriorityNumberRBG0;		/* 1800FC */
! } SclBgPriNumRegister;
! 
! /*----< sprite color Mix >----*/
! typedef struct {
!     Uint16 ColMixRateSP01;		/* 180100 */
!     Uint16 ColMixRateSP23;		/* 180102 */
!     Uint16 ColMixRateSP45;		/* 180104 */
!     Uint16 ColMixRateSP67;		/* 180106 */
! } SclSpColMixRegister;
! 
! /*----< scroll color Mix >----*/
! typedef struct {
!     Uint16 ColMixRateNBG01;		/* 180108 */
!     Uint16 ColMixRateNBG23;		/* 18010A */
!     Uint16 ColMixRateRBG0;		/* 18010C */
!     Uint16 ColMixRateLCBAK;		/* 18010E */
! } SclBgColMixRegister;
! 
! /*----< color offset >----*/
! typedef struct {
!     Uint16 ColorOffsetEnable;		/* 180110 */
!     Uint16 ColorOffsetSelect;		/* 180112 */
!     Uint16 ColorOffsetA_RED;		/* 180114 */
!     Uint16 ColorOffsetA_GREEN;		/* 180116 */
!     Uint16 ColorOffsetA_BLUE;		/* 180118 */
!     Uint16 ColorOffsetB_RED;		/* 18011A */
!     Uint16 ColorOffsetB_GREEN;		/* 18011E */
!     Uint16 ColorOffsetB_BLUE;		/* 180120 */
! } SclColOffsetRegister;
! 
! /*---- レジスタバッファのダーティー・フラグ */
! typedef struct
! {
!     Uint32 SclOtherPri:1;
!     Uint32 SclSpPriNum:1;
!     Uint32 SclBgPriNum:1;
!     Uint32 SclSpColMix:1;
!     Uint32 SclBgColMix:1;
!     Uint32 SclColOffset:1;
! } SclPriBuffDirtyFlags;
! 
! #endif /* __PRI_REG */
! 
! 
! extern SclOtherPriRegister	SclOtherPri;
! extern SclSpPriNumRegister	SclSpPriNum;
! extern SclBgPriNumRegister	SclBgPriNum;
! extern SclSpColMixRegister	SclSpColMix;
! extern SclBgColMixRegister	SclBgColMix;
! extern SclColOffsetRegister	SclColOffset;
! extern SclPriBuffDirtyFlags	SclPriBuffDirty;
! 
! /* Following macros never check argument value range.*/
! 
! /* VDP-II manual p.129 */
! #define SCL_SET_SPCCCS(/* 2 bits */ spcccs) /* スプライト色演算条件 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0x0FFF) | ((spcccs) << 12))
! 
! #define SCL_GET_SPCCCS() \
!   ((SclOtherPri.SpriteControl & 0x3000) >> 12)
! 
! #define SCL_SET_SPCCN(/* 3 bits */ spccn) /* スプライト色演算条件ナンバ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xF0FF) | ((spccn) << 8))
! 
! #define SCL_GET_SPCCN() \
!   ((SclOtherPri.SpriteControl & 0x0700) >> 8)
! 
! #define SCL_SET_SPCLMD(/* 1 bit */ spclmd) /* スプライトの色形式 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFDF) | ((spclmd) << 5))
! 
! #define SCL_GET_SPCLMD() \
!   ((SclOtherPri.SpriteControl & 0x0020) >> 5)
! 
! #define SCL_SET_SPWINEN(/* 1 bit */ spwinen) /* スプライトウィンドウイネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFEF) | ((spwinen) << 4))    /* -> p.121 */
! 
! #define SCL_GET_SPWINEN() \
!   ((SclOtherPri.SpriteControl & 0x0010) >> 4)
! 
! #define SCL_SET_SPTYPE(/* 4bits */ sptype) /* スプライトのタイプ指定 */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFF0) | (sptype))
! 
! #define SCL_GET_SPTYPE() \
!   (SclOtherPri.SpriteControl & 0x000F)
! 
! /* VDP-II manual p.131 */
! /*-------------------- スプライト用プライオリティレジスタ No.0-7 */
! 
! #define SCL_SET_S0PRIN(/* 3 bits */ s0prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1,\
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xFFF0) | (s0prin))
! 
! #define SCL_GET_S0PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0007))
! 
! #define SCL_SET_S1PRIN(/* 3 bits */ s1prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xF0FF) | ((s1prin) << 8))
! 
! #define SCL_GET_S1PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0700) >> 8)
! 
! #define SCL_SET_S2PRIN(/* 3 bits */ s2prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xFFF0) | ((s2prin)))
! 
! #define SCL_GET_S2PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0007))
! 
! #define SCL_SET_S3PRIN(/* 3 bits */ s3prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xF0FF) | ((s3prin) << 8))
! 
! #define SCL_GET_S3PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0700) >> 8)
! 
! #define SCL_SET_S4PRIN(/* 3 bits */ s4prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xFFF0) | ((s4prin)))
! 
! #define SCL_GET_S4PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0007))
! 
! #define SCL_SET_S5PRIN(/* 3 bits */ s5prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xF0FF) | ((s5prin) << 8))
! 
! #define SCL_GET_S5PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0700) >> 8)
! 
! #define SCL_SET_S6PRIN(/* 3 bits */ s6prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xFFF0) | ((s6prin)))
! 
! #define SCL_GET_S6PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0007))
! 
! #define SCL_SET_S7PRIN(/* 3 bits */ s7prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xF0FF) | ((s7prin) << 8))
! 
! #define SCL_GET_S7PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0700) >> 8)
! 
! /* VDP-II manual p.132 */
! /*------------------- スプライト用カラー演算割合レジスタ No.0-7 */
! 
! #define SCL_SET_S0CCRT(/* 5bits */ s0ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0xFF00) | ((s0ccrt)))
! 
! #define SCL_GET_S0CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x001F) >> 0)
! 
! #define SCL_SET_S1CCRT(/* 5bits */ s1ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0x00FF) | ((s1ccrt) << 8))
! 
! #define SCL_GET_S1CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x1F00) >> 8)
! 
! #define SCL_SET_S2CCRT(/* 5bits */ s2ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0xFF00) | ((s2ccrt)))
! 
! #define SCL_GET_S2CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x001F))
! 
! #define SCL_SET_S3CCRT(/* 5bits */ s3ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0x00FF) | ((s3ccrt) << 8))
! 
! #define SCL_GET_S3CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x1F00) >> 8)
! 
! #define SCL_SET_S4CCRT(/* 5bits */ s4ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0xFF00) | ((s4ccrt)))
! 
! #define SCL_GET_S4CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x001F))
! 
! #define SCL_SET_S5CCRT(/* 5bits */ s5ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0x00FF) | ((s5ccrt) << 8))
! 
! #define SCL_GET_S5CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x1F00) >> 8)
! 
! #define SCL_SET_S6CCRT(/* 5bits */ s6ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0xFF00) | ((s6ccrt)))
! 
! #define SCL_GET_S6CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x001F))
! 
! #define SCL_SET_S7CCRT(/* 5bits */ s7ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0x00FF) | ((s7ccrt) << 8))
! 
! #define SCL_GET_S7CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x1F00) >> 8)
! 
! /* VDP-II manual p.138 */
! /*-- カラー RAM アドレスオフセット N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0CAOS(/* 3bits */ n0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFFF0) | ((n0caos)))
! 
! #define SCL_GET_N0CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0007))
! 
! #define SCL_SET_N1CAOS(/* 3bits */ n1caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFF0F) | ((n1caos) << 4))
! 
! #define SCL_GET_N1CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0070) >> 4)
! 
! #define SCL_SET_N2CAOS(/* 3bits */ n2caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xF0FF) | ((n2caos) << 8))
! 
! #define SCL_GET_N2CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0700) >> 8)
! 
! #define SCL_SET_N3CAOS(/* 3bits */ n3caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0x0FFF) | ((n3caos) << 12))
! 
! #define SCL_GET_N3CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x7000) >> 12)
! 
! #define SCL_SET_R0CAOS(/* 3bits */ r0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFFF0) | ((r0caos) << 0))
! 
! #define SCL_GET_R0CAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0007) >> 0)
! 
! #define SCL_SET_SPCAOS(/* 3bits */ spcaos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFF0F) | ((spcaos) << 4))
! 
! #define SCL_GET_SPCAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0070) >> 4)
! 
! 
! /*----- ラインカラー画面イネーブル N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0LCEN(/* 1bit */ n0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFE) | ((n0lcen)))
! 
! #define SCL_GET_N0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0001))
! 
! #define SCL_SET_N1LCEN(/* 1bit */ n1lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFD) | ((n1lcen) << 1))
! 
! #define SCL_GET_N1LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2LCEN(/* 1bit */ n2lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFB) | ((n2lcen) << 2))
! 
! #define SCL_GET_N2LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3LCEN(/* 1bit */ n3lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFF7) | ((n3lcen) << 3))
! 
! #define SCL_GET_N3LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0LCEN(/* 1bit */ r0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFEF) | ((r0lcen) << 4))
! 
! #define SCL_GET_R0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0010) >> 4)
! 
! #define SCL_SET_SPLCEN(/* 1bit */ splcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFDF) | ((splcen) << 5))
! 
! #define SCL_GET_SPLCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0020) >> 5)
! 
! /*-------- 特殊プライオリティモード N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0SPRM(/* 2bits */ n0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFFC) | ((n0sprm)))
! 
! #define SCL_GET_N0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0003))
! 
! #define SCL_SET_N1SPRM(/* 2bits */ n1sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFF3) | ((n1sprm) << 2))
! 
! #define SCL_GET_N1SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SPRM(/* 2bits */ n2sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFCF) | ((n2sprm) << 4))
! 
! #define SCL_GET_N2SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SPRM(/* 2bits */ n3sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFF3F) | ((n3sprm) << 6))
! 
! #define SCL_GET_N3SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SPRM(/* 2bits */ r0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFCFF) | ((r0sprm) << 8))
! 
! #define SCL_GET_R0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0300) >> 8)
! 
! /*---------プライオリティー番号 N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0PRIN(/* 3 bits */ n0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0xFF00) | ((n0prin)))
! 
! #define SCL_GET_N0PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0007))
! 
! #define SCL_SET_N1PRIN(/* 3 bits */ n1prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0x00FF) | ((n1prin) << 8))
! 
! #define SCL_GET_N1PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0700) >> 8)
! 
! #define SCL_SET_N2PRIN(/* 3 bits */ n2prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0xFF00) | ((n2prin)))
! 
! #define SCL_GET_N2PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0007))
! 
! #define SCL_SET_N3PRIN(/* 3 bits */ n3prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0x00FF) | ((n3prin) << 8))
! 
! #define SCL_GET_N3PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0700) >> 8)
! 
! #define SCL_SET_R0PRIN(/* 3 bits */ r0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberRBG0 \
!    = ((r0prin)))
! 
! #define SCL_GET_R0PRIN() \
!    ((SclBgPriNum.PriorityNumberRBG0 & 0x0007))
! 
! #define SCL_SET_BOKEN(/* 1 bits */ boken) /* ボカシ演算イネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x7FFF) | ((boken) << 15))
! 
! #define SCL_GET_B0KEN() \
!   ((SclOtherPri.ColorMixControl & 0x8000) >> 15)
! 
! #define SCL_SET_BOKN(/* 3 bits */ bokn) /* ボカシ画面番号 */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x8FFF) | ((bokn) << 12))
! 
! #define SCL_GET_BOKN() \
!   ((SclOtherPri.ColorMixControl & 0x7000) >> 12)
! 
! #define SCL_SET_EXCCEN(/* 1 bit */ exccn) /* 拡張カラー演算イネーブル */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFBFF) | ((exccn) << 10))
! 
! #define SCL_GET_EXCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0400) >> 10)
! 
! #define SCL_SET_CCRTMD(/* 1 bit */ ccrtmd) /* カラー演算割合モード */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFDFF) | ((Uint32)(ccrtmd) << 9))
! 
! #define SCL_GET_CCRTMD() \
!   ((SclOtherPri.ColorMixControl & 0x0200) >> 9)
! 
! #define SCL_SET_CCMD(/* 1 bit */ ccmd) /* カラー演算モード */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFEFF) | ((Uint32)(ccmd) << 8))
! 
! #define SCL_GET_CCMD() \
!   ((SclOtherPri.ColorMixControl & 0x0100) >> 8)
! 
! /*------ カラー演算イネーブル N0|R1, N1|EXBG, N2, N3, R0, LC, SPRITE */ 
! #define SCL_SET_SPCCEN(/* 1 bit */ spccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFBF) | ((spccen) << 6))
! 
! #define SCL_GET_SPCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0040) >> 6)
! 
! #define SCL_SET_LCCCEN(/* 1 bit */ lcccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFDF) | ((lcccen) << 5))
! 
! #define SCL_GET_LCCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0020) >> 5)
! 
! #define SCL_SET_R0CCEN(/* 1 bit */ r0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFEF) | ((r0ccen) << 4))
! 
! #define SCL_GET_R0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0010) >> 4)
! 
! #define SCL_SET_N3CCEN(/* 1 bit */ n3ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFF7) | ((n3ccen) << 3))
! 
! #define SCL_GET_N3CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0008) >> 3)
! 
! #define SCL_SET_N2CCEN(/* 1 bit */ n2ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFB) | ((n2ccen) << 2))
! 
! #define SCL_GET_N2CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0004) >> 2)
! 
! #define SCL_SET_N1CCEN(/* 1 bit */ n1ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFD) | ((n1ccen) << 1))
!   
! #define SCL_GET_N1CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0002) >> 1)
! 
! #define SCL_SET_N0CCEN(/* 1 bit */ n0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFE) | ((n0ccen)))
! 
! #define SCL_GET_N0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0001))
! 
! 
! /*-------------- 特殊カラー演算モード N0|R1, N1|EXBG, N2, N3, R0 */
! #define SCL_SET_N0SCCM(/* 2 bits */ n0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFFC) | ((n0sccm)))
! 
! #define SCL_GET_N0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0003))
! 
! #define SCL_SET_N1SCCM(/* 2 bits */ n1sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFF3) | ((n1sccm) << 2))
! 
! #define SCL_GET_N1SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SCCM(/* 2 bits */ n2sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFCF) | ((n2sccm) << 4))
! 
! #define SCL_GET_N2SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SCCM(/* 2 bits */ n3sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFF3F) | ((n3sccm) << 6))
! 
! #define SCL_GET_N3SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SCCM(/* 2 bits */ r0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!   = (SclOtherPri.SpecialColorMixMode & 0xFCFF) | ((r0sccm) << 8))
! 
! #define SCL_GET_R0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0300) >> 8)
! 
! /*------ スクロール面用カラー演算割合 N0|R1, N1|EXBG, N2, N3, R0, LC, BACK */
! #define SCL_SET_N0CCRT(/* 5 bits */ n0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0xFF00) | ((n0ccrt)))
! 
! #define SCL_GET_N0CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x001F))
! 
! #define SCL_SET_N1CCRT(/* 5 bits */ n1ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0x00FF) | ((n1ccrt) << 8))
! 
! #define SCL_GET_N1CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x1F00) >> 8)
! 
! #define SCL_SET_N2CCRT(/* 5 bits */ n2ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0xFF00) | ((n2ccrt)))
! 
! #define SCL_GET_N2CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x001F))
! 
! #define SCL_SET_N3CCRT(/* 5 bits */ n3ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0x00FF) | ((n3ccrt) << 8))
! 
! #define SCL_GET_N3CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x1F00) >> 8)
! 
! #define SCL_SET_R0CCRT(/* 5 bits */ r0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateRBG0 \
!    = ((r0ccrt)))
! 
! #define SCL_GET_R0CCRT() \
!   ((SclBgColMix.ColMixRateRBG0 & 0x001F))
! 
! #define SCL_SET_LCCCRT(/* 5 bits */ lcccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0xFF00) | ((lcccrt)))
! 
! #define SCL_GET_LCCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x001F))
! 
! #define SCL_SET_BKCCRT(/* 5 bits */ bkccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0x00FF) | ((bkccrt) << 8))
! 
! #define SCL_GET_BKCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x1F00) >> 8)
! 
! /*-- カラーオフセットイネーブル N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COEN(/* 1 bit */ n0coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFE) | ((n0coen)))
! 
! #define SCL_GET_N0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0001))
! 
! #define SCL_SET_N1COEN(/* 1 bit */ n1coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFD) | ((n1coen) << 1))
! 
! #define SCL_GET_N1COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2COEN(/* 1 bit */ n2coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFB) | ((n2coen) << 2))
! 
! #define SCL_GET_N2COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3COEN(/* 1 bit */ n3coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFF7) | ((n3coen) << 3))
! 
! #define SCL_GET_N3COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0COEN(/* 1 bit */ r0coen) \
!    (SclPriBuffDirty.SclColOffset = 1, \
!     SclColOffset.ColorOffsetEnable \
!     = (SclColOffset.ColorOffsetEnable & 0xFFEF) | ((r0coen) << 4))
! 
! #define SCL_GET_R0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOEN(/* 1 bit */ bkcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFDF) | ((bkcoen) << 5))
! 
! #define SCL_GET_BKCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOEN(/* 1 bit */ spcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFBF) | ((spcoen) << 6))
! 
! #define SCL_GET_SPCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0040) >> 6)
! 
! /*--- カラーオフセットレジスタ選択 N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COSL(/* 1 bit */ n0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFE) | (n0cosl))
! 
! #define SCL_GET_N0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0001))
! 
! #define SCL_SET_N1COSL(/* 1 bit */ n1cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFD) | ((n1cosl) << 1))
! 
! #define SCL_GET_N1COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0002) >> 1)
! 
! #define SCL_SET_N2COSL(/* 1 bit */ n2cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFB) | ((n2cosl) << 2))
! 
! #define SCL_GET_N2COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0004) >> 2)
! 
! #define SCL_SET_N3COSL(/* 1 bit */ n3cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFF7) | ((n3cosl) << 3))
! 
! #define SCL_GET_N3COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0008) >> 3)
! 
! #define SCL_SET_R0COSL(/* 1 bit */ r0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFEF) | ((r0cosl) << 4))
! 
! #define SCL_GET_R0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOSL(/* 1 bit */ bkcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFDF) | ((bkcosl) << 5))
! 
! #define SCL_GET_BKCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOSL(/* 1 bit */ spcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFBF) | ((spcosl) << 6))
! 
! #define SCL_GET_SPCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0040) >> 6)
! 
! /* カラーオフセットレジスタ A */
! #define SCL_SET_COARD(/* 9 bit */ coard) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_RED \
!    = (coard))
! 
! #define SCL_GET_COARD() \
!   (SclColOffset.ColorOffsetA_RED & 0x01FF)
! 
! #define SCL_SET_COAGR(/* 9 bit */ coagr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_GREEN \
!    = (coagr))
! 
! #define SCL_GET_COAGR() \
!   (SclColOffset.ColorOffsetA_GREEN & 0x01FF)
! 
! #define SCL_SET_COABL(/* 9 bit */ coabl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_BLUE \
!    = (coabl))
! 
! #define SCL_GET_COABL() \
!   (SclColOffset.ColorOffsetA_BLUE & 0x01FF)
! 
! /* カラーオフセットレジスタ B*/
! #define SCL_SET_COBRD(/* 9 bit */ cobrd) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_RED \
!    = (cobrd))
! 
! #define SCL_GET_COBRD() \
!    (SclColOffset.ColorOffsetB_RED & 0x01FF)
! 
! #define SCL_SET_COBGR(/* 9 bit */ cobgr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_GREEN \
!    = (cobgr))
! 
! #define SCL_GET_COBGR() \
!   (SclColOffset.ColorOffsetB_GREEN & 0x01FF)
! 
! #define SCL_SET_COBBL(/* 9 bit */ cobbl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_BLUE \
!    = (cobbl))
! 
! #define SCL_GET_COBBL() \
!   (SclColOffset.ColorOffsetB_BLUE & 0x01FF)
! 
! /*----------- シャドウコントロール N0|R1, N1|EXBG, N2, N3, R0, BACK */
! 
! #define SCL_SET_N0SDEN(/* 1 bit */ n0sden) \
!    (SclPriBuffDirty.SclOtherPri = 1, \
!     SclOtherPri.ShadowControl \
!     = (SclOtherPri.ShadowControl & 0xFFFE) | ((n0sden)))
! 
! #define SCL_GET_N0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0001))
! 
! #define SCL_SET_N1SDEN(/* 1 bit */ n1sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFD) | ((n1sden) << 1))
! 
! #define SCL_GET_N1SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0002) >> 1)
! 
! #define SCL_SET_N2SDEN(/* 1 bit */ n2sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFB) | ((n2sden) << 2))
! 
! #define SCL_GET_N2SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0004) >> 2)
! 
! #define SCL_SET_N3SDEN(/* 1 bit */ n3sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFF7) | ((n3sden) << 3))
! 
! #define SCL_GET_N3SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0008) >> 3)
! 
! #define SCL_SET_R0SDEN(/* 1 bit */ r0sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFEF) | ((r0sden) << 4))
! 
! #define SCL_GET_R0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0010) >> 4)
! 
! #define SCL_SET_BKSDEN(/* 1 bit */ bksden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFDF) | ((bksden) << 5))
! 
! #define SCL_GET_BKSDEN() \
!   ((SclOtherPri.ShadowControl & 0x0020) >> 5)
! 
! /*--------------------------------------- 透明シャドウセレクト */
! #define SCL_SET_TPSDSL(/* 1 bit */ tpsden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFEFF) | ((tpsden) << 8))
! 
! #define SCL_GET_TPSDSL() \
!   ((SclOtherPri.ShadowControl & 0x0100) >> 8)
! 
! /*---------------------------カラー RAM モード */
! /* 0x1800E 番地にあるので スクロールライブラリで設定する */
! 
! /* 値の定義 */
! 
! #define SCL_RBG0	0x00000001
! #define SCL_RBG1	0x00000002
! #define SCL_NBG0	0x00000004
! #define SCL_NBG1	0x00000008
! #define SCL_NBG2	0x00000010
! #define SCL_NBG3	0x00000020
! 
! #define SCL_EXBG	0x00000080
! #define SCL_SPR 	0x00000100
! #define SCL_SP0 	0x00000100
! #define SCL_SP1 	0x00000200
! #define SCL_SP2 	0x00000400
! #define SCL_SP3 	0x00000800
! #define SCL_SP4 	0x00001000
! #define SCL_SP5 	0x00002000
! #define SCL_SP6 	0x00004000
! #define SCL_SP7 	0x00008000
! #define SCL_RP  	0x00010000
! #define SCL_RP_R	0xfffeffff
! #define SCL_CC  	0x00020000
! #define SCL_LNCL	0x00040000
! #define SCL_BACK	0x00080000
! 
! #define SCL_RBG_TB_A	SCL_RBG0
! #define SCL_RBG_TB_B	SCL_RBG1
! 
! #define SCL_CRM15_1024 0
! #define SCL_CRM15_2048 1
! #define SCL_CRM24_1024 2
! 
! /* スプライトのタイプ指定 */
! #define SCL_TYPE0	0
! #define SCL_TYPE1	1
! #define SCL_TYPE2	2
! #define SCL_TYPE3	3
! #define SCL_TYPE4	4
! #define SCL_TYPE5	5
! #define SCL_TYPE6	6
! #define SCL_TYPE7	7
! #define SCL_TYPE8	8
! #define SCL_TYPE9	9
! #define SCL_TYPEA	10
! #define SCL_TYPEB	11
! #define SCL_TYPEC	12
! #define SCL_TYPED	13
! #define SCL_TYPEE	14
! #define SCL_TYPEF	15
! 
! #define SCL_PALETTE	0
! #define SCL_MIX 	1
! 
! #define SCL_MSB_SHADOW	0
! #define SCL_SP_WINDOW	1
! 
! #define SCL_IF_BEHIND	0
! #define SCL_IF_EQUAL	1
! #define SCL_IF_FRONT	2
! #define SCL_MSB_ON	3
! 
! #define SCL_OFFSET_A	0
! #define SCL_OFFSET_B	1
! 
! #endif /* __PRI_MACRO */
! 
! extern SclOtherPriRegister  SclOtherPri;  /* いろいろ */
! 
! extern SclSpPriNumRegister  SclSpPriNum;  /* スプライトのプライオリティ番号 */
! 
! extern SclBgPriNumRegister  SclBgPriNum;  /* スクロールのプライオリティ番号 */
! 
! extern SclSpColMixRegister  SclSpColMix;  /* スプライトの色演算 */
! 
! extern SclBgColMixRegister  SclBgColMix;  /* スクロールの色演算 */
! 
! extern SclColOffsetRegister SclColOffset; /* カラーオフセット */
! 
! extern SclPriBuffDirtyFlags SclPriBuffDirty; /* レジスタバッファのダーティー・フラグ */
! 
! /*--- REAL Priority Registers (Pointer) ---*/
! 
! extern SclOtherPriRegister  *SclRealOtherPri;
! 
! extern SclSpPriNumRegister  *SclRealSpPriNum;
! 
! extern SclBgPriNumRegister  *SclRealBgPriNum;
! 
! extern SclSpColMixRegister  *SclRealSpColMix;
! 
! extern SclBgColMixRegister  *SclRealBgColMix;
! 
! extern SclColOffsetRegister *SclRealColOffset;
! 
! #endif /* __PRI_GLVAR */
! 
! /* ＶＤＰ２ライブラリのプロトタイプ宣言 */
! #ifndef	SEGA_SCL_PROTO
! #define SEGA_SCL_PROTO
! 
! extern	void	SCL_Vdp2Init(void);
! extern	void	SCL_Vdp2_SGLInit(Uint16 tvmod);
! extern	void	SCL_SetDisplayMode(Uint8 interlace,Uint8 vertical,Uint8 horizontal);
! extern	void	SCL_InitVramConfigTb(SclVramConfig *tp);
! extern	void	SCL_InitConfigTb(SclConfig *scfg);
! extern	void	SCL_InitLineParamTb(SclLineparam *lp);
! extern	void	SCL_SetVramConfig(SclVramConfig *tp);
! extern	void	SCL_SetConfig(Uint16 sclnum, SclConfig *scfg);
! extern	void	SCL_SetCycleTable(Uint16 *tp);
! extern	void	SCL_Open(Uint32 sclnum);
! extern	void	SCL_Close(void);
! extern	void	SCL_SetLineParam(SclLineparam *lp);
! extern	void	SCL_MoveTo(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Move(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Scale(Fixed32 Sx, Fixed32 Sy);
! extern	void	SCL_SetColRamMode(Uint32 ComRamMode);
! extern	Uint32	SCL_InitRotateTable(Uint32 Address,Uint16 Mode,Uint32 rA,Uint32 rB);
! extern	void	SCL_RotateTo(Fixed32 xy,Fixed32 z,Fixed32 disp,Uint16 mode);
! extern	void	SCL_Rotate(Fixed32 xy,Fixed32 z,Fixed32 disp);
! extern	void	SCL_SetRotateViewPoint(Uint16 x,Uint16 y,Uint16 z);
! extern	void    SCL_SetRotateZoom(Fixed32 x,Fixed32 y);
! extern	void	SCL_SetRotateCenter(Uint16 x,Uint16 y,Uint16 z);
! extern	void	SCL_SetRotateCenterDisp(Uint16 x,Uint16 y);
! extern	void	SCL_SetCoefficientData(Uint32 sclnum,Uint16 *data,Uint16 x,Uint16 y);
! extern	void	SCL_SetLncl(Uint32 addr,Uint16 tbnum,Uint16 *palNumTb);
! extern	void	SCL_SetBack(Uint32 addr,Uint16 dataSize,Uint16 *dataTb);
! extern	void	SCL_SetMosaic(Uint32 surface,Uint8 x,Uint8 y);
! extern	void	SCL_SetSpriteMode(Uint8 Type, Uint8 ColMode, Uint8 WinMode);
! extern	Uint32	SCL_GetColRamMode(void);
! extern	void	SCL_SetColRam(Uint32 Object, Uint32 Index,Uint32 num,void *Color);
! extern	Uint32	SCL_AllocColRam(Uint32 Surface, Uint32 NumOfColors, Uint8 transparent);
! extern	void	SCL_FreeColRam(Uint32 Surface);
! extern	void	SCL_SetAutoColChg(Uint32 Surface,Uint32 Interval,Uint32 Index,
! 			Uint32 NumOfCol,Uint32 NumOfTbl,Uint32 *ChangeTbl);
! extern	Uint32	SCL_GetColRamOffset(Uint32 Object);
! extern	void	SCL_SetPriority(Uint32 Object, Uint8 Priority);
! extern	Uint8	SCL_GetPriority(Uint32 Object);
! extern	void	SCL_SetColMixMode(Uint32 ColMixPriority, Uint8 Mode);
! extern	void	SCL_SetColMixRate(Uint32 Surfaces, Uint8 Rate);
! extern	void	SCL_SetAutoColMix(Uint32 Surfaces,Uint32 Interval,Uint32 Time,
! 			Uint8 StartRate,Uint8 EndRate);
! extern	void	SCL_SetColOffset(Uint32 OffsetReg, Uint32 Surfaces,
! 			Sint16 red, Sint16 green, Sint16 blue);
! extern	void	SCL_IncColOffset(Uint32 OffsetReg,Sint16 red,Sint16 green,Sint16 blue);
! extern	void	SCL_SetAutoColOffset(Uint32 OffsetReg,Uint32 Interval,Uint32 Time,
! 				SclRgb *start,SclRgb *end);
! extern	void	SCL_EnableBlur(Uint32 Surface);
! extern	void	SCL_DisableBlur(void);
! extern	void	SCL_EnableLineCol(Uint32 Surface);
! extern	void	SCL_DisableLineCol(Uint32 Surface);
! extern	void	SCL_SetWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint16 sx,Uint16 sy,Uint16 ex,Uint16 ey);
! extern	void	SCL_SetLineWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint32 addr,Uint32 sy,Uint32 tbSize,SclLineWindowTb *tp);
! extern	void	SCL_SetSpriteWindow(Uint32 logic,Uint32 enable,Uint32 area);
! extern	void	SCL_SetFrameInterval(Uint16 count);
! extern	void	SCL_DisplayFrame(void);
! extern	void	SCL_VblankStart(void);
! extern	void	SCL_VblankEnd(void);
! extern	void	SCL_AbortAutoVe(void);
! 
! extern	void	SCL_SglOn(void);		/* tuika c.yoshida */
! extern	void	SCL_SglOff(void);		/* tuika c.yoshida */
! 
! /* 画面サイズデフォルト */
! extern	Uint16	SclDisplayX;
! extern	Uint16	SclDisplayY;
! 
! /* レジスタバッファ */
! extern	SclSysreg	Scl_s_reg;
! extern	SclDataset	Scl_d_reg;
! extern	SclNorscl	Scl_n_reg;
! extern	SclRotscl	Scl_r_reg;
! extern	SclWinscl	Scl_w_reg;
! extern	Uint16		SclProcess;
! extern	SclSblSgl	Scl_flag;
! 
! #endif /* SEGA_SCL_PROTO */
! 
\ No newline at end of file
--- 1,1428 ----
! /*------------------------------------------------------------------------
!  *  FILE:	SEGA_SCL.H
!  *
!  *	Copyright(c) 1994 SEGA
!  *
!  *  PURPOSE:
!  *	Scroll Simulation program header file
!  *	Scroll Register Data Structure Definition File
!  *
!  *  AUTHOR(S):
!  *	K.M
!  *
!  *  MOD HISTORY:
!  *	Written by K.M on 1994-05-20 Ver.1.00
!  *	Updated by K.M on 1994-07-01 Ver.1.00
!  *
!  *------------------------------------------------------------------------
!  */
! 
! #ifndef	SEGA_SCR_H
! #define SEGA_SCR_H
! 
! #include <sega_xpt.h>
! #include <sega_def.h>
! #include <sega_mth.h>
! 
! #define VBR              0x06000000
! #define SCU_BASE         0x25FE0000
! #define SCU_INTR_MASK    0x000000a0
! #define SCU_INTR_STATUS  0x000000a4
! #define SETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x300)))
! #define GETUINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x304)))
! #define SETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x310)))
! #define GETSINT   ((Sint32 (*)()) *((Uint32*)(VBR+0x314)))
! #define VBIVN	0x40
! #define VBOVN	0x41
! #define HBIVN	0x42
! 
! /*********************************************
!  *      System Register Cluster	             *
!  *      Address ranger 180000H - 180027H     *
!  *********************************************/
!  typedef struct	SclSysreg{
! 	Uint16	tvmode;			/* TV Mode */
! 	Uint16	extenbl;		/* External Input Enable */
! 	Uint16	tvstatus;		/* TV Status Read Only */
! 	Uint16	vramsize;		/* VRAM Size */
! 	Uint16	H_val;			/* H Counter Read Only */
! 	Uint16	V_val;			/* V Counter Read Only */
! 	Uint16	vramchg;		/* VRAM Change */
! 	Uint16	ramcontrl;		/* RAM Control */
! 	Uint16	vramcyc[8];		/* VRAM Cycle Table x8 */
! 	Uint16	dispenbl;		/* Display Enable */
! 	Uint16	mosaic;			/* Mosaic Control */
! 	Uint16	specialcode_sel;	/* Special Code Selector */
! 	Uint16	specialcode;		/* Special Code */
!  } SclSysreg;
! 
! /**********************************************
!  *      Scroll Data Set Register Cluster      *
!  *      Address ranger 180028H - 18006FH      *
!  **********************************************/
! typedef struct SclDataset{
! 	Uint16	charcontrl0;		/* Character Control */
! 	Uint16	charcontrl1;		/* Character Control */
! 	Uint16	bmpalnum0;		/* Bitmap Palette Number */
! 	Uint16	bmpalnum1;		/* Bitmap Palette Number */
! 	Uint16	patnamecontrl[5];	/* Pattern Name Controlx5 */
! 	Uint16	platesize;		/* Plate Size */
! 	Uint16	mapoffset0;		/* Map Offset */
! 	Uint16	mapoffset1;		/* Map Offset */
! 	Uint16	normap[8];		/* Normal Scroll Map x8*/
! 	Uint16	rotmap[16];		/* Rotate Scroll Map x16*/
! } SclDataset;
! 
! /***************************************************
!  *      Normal Scroll Function Register Cluster    *
!  *      Address ranger 180070H - 1800AFH           *
!  ***************************************************/
! typedef struct SclNorscl{
! 	Fixed32	n0_move_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_move_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n0_delta_x;		/* NBG0 Scroll Movement X */
! 	Fixed32	n0_delta_y;		/* NBG0 Scroll Movement Y */
! 	Fixed32	n1_move_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_move_y;		/* NBG1 Scroll Movement Y */
! 	Fixed32	n1_delta_x;		/* NBG1 Scroll Movement X */
! 	Fixed32	n1_delta_y;		/* NBG1 Scroll Movement Y */
! 	Uint16	n2_move_x;		/* NBG2 Scroll Movement X */
! 	Uint16	n2_move_y;		/* NBG2 Scroll Movement Y */
! 	Uint16	n3_move_x;		/* NBG3 Scroll Movement X */
! 	Uint16	n3_move_y;		/* NBG3 Scroll Movement Y */
! 	Uint16	zoomenbl;		/* Zoom Enable */
! 	Uint16	linecontrl;		/* Normal Extension Control */
! 	Uint32	celladdr;		/* Cell Scroll Table Address */
! 	Uint32	lineaddr[2];		/* Line Scroll Table Address x2 */
! 	Uint32	linecolmode;		/* Line BG Color Mode Address */
! 	Uint32	backcolmode;		/* Back BG Color Mode Address */
! } SclNorscl;
! 
! /****************************************************
!  *      Rotate Scroll Function Register Cluster     *
!  *      Address ranger 1800B0H - 1800BFH            *
!  ****************************************************/
! typedef struct SclRotscl{
! 	Uint16	paramode;		/* Rotate Parameter Mode */
! 	Uint16	paramcontrl;		/* Rotate Parameter Read Control */
! 	Uint16	k_contrl;		/* Keisu Table Control */
! 	Uint16	k_offset;		/* Keisu Addres Offset */
! 	Uint16	mapover[2];		/* Rotate Scroll Map Over */
! 	Uint32	paramaddr;		/* Rotate Parameter Tabel Address */
! } SclRotscl;
! 
! /***************************************************
!  *      Window Scroll Setting Register Cluster     *
!  *      Address ranger 1800C0H - 1800DFH           *
!  ***************************************************/
! typedef struct SclWinscl{
! 					/* 1800C0 */
! 	Uint16	win0_start[2];		/* Window #0 Start X & Y */
! 					/* 1800C4 */
! 	Uint16	win0_end[2];		/* Window #0 End X & Y */
! 					/* 1800C8 */
! 	Uint16	win1_start[2];		/* Window #1 Start X & Y */
! 					/* 1800CC */
! 	Uint16	win1_end[2];		/* Window #1 End X & Y */
! 					/* 1800D0 */
! 	Uint16	wincontrl[4];		/* Window Control */
! 					/* 1800D8 */
! 	Uint32 	linewin0_addr;		/* Line Window #0 Table Address */
! 					/* 1800DC */
! 	Uint32 	linewin1_addr;		/* Line Window #1 Table Address */
! } SclWinscl;
! 
! /***********************************************
!  *      Priority Related Register Cluster      *
!  ***********************************************/
! typedef struct SclPrior{
! 	Uint16	prnum;
! } SclPrior;
! 
! 
! /**************************************************
!  *      Scroll Parameters Definition              *
!  **************************************************/
! typedef struct  SclXy {
! 	 Fixed32         x;
! 	 Fixed32         y;
! } SclXy;
! 
! typedef struct  SclXyz {
! 	 Fixed32         x;
! 	 Fixed32         y;
! 	 Fixed32         z;
! } SclXyz;
! 
! typedef struct  SclXy16 {
!         Uint16         x;
!         Uint16         y;
! } SclXy16;
! 
! typedef struct  SclXyz16 {
!         Sint16         x;
!         Sint16         y;
!         Sint16         z;
! } SclXyz16;
! 
! typedef struct  SclRgb {
! 	 Sint16		red;
! 	 Sint16		green;
! 	 Sint16		blue;
! } SclRgb;
! 
! typedef struct  SclLineTb {
! 	 Fixed32	h;
! 	 Fixed32	v;
! 	 Fixed32	dh;
! } SclLineTb;
! 
! typedef struct  SclLineWindowTb {
! 	 Uint16		start;
! 	 Uint16		end;
! } SclLineWindowTb;
! 
! typedef struct SclVramConfig{
! 	Uint32	ktboffsetA;/* ｿｽｿｽｿｽ]ｿｽｿｽｿｽﾒｰｿｽAｿｽpｿｽWｿｽｿｽﾃｰｿｽｿｽﾙゑｿｽｿｽｿｽﾝｸｿｽｿｽｿｽﾌどゑｿｽｿｽﾉ配ｿｽuｿｽｿｽｿｽ驍ｩ */
! 	Uint32	ktboffsetB;/* ｿｽｿｽｿｽ]ｿｽｿｽｿｽﾒｰｿｽBｿｽpｿｽWｿｽｿｽﾃｰｿｽｿｽﾙゑｿｽｿｽｿｽﾝｸｿｽｿｽｿｽﾌどゑｿｽｿｽﾉ配ｿｽuｿｽｿｽｿｽ驍ｩ */
! 	Uint8	vramModeA; /* VRAM A ｿｽｿｽｿｽQｿｽﾂのバｿｽｿｽｿｽNｿｽﾉ具ｿｽｿｽﾘるかｿｽwｿｽｿｽ(0/1)  */
! 	Uint8	vramModeB; /* VRAM B ｿｽｿｽｿｽQｿｽﾂのバｿｽｿｽｿｽNｿｽﾉ具ｿｽｿｽﾘるかｿｽwｿｽｿｽ(0/1)  */
! 	Uint8	vramA0;    /* VRAM A or A0 ｿｽｿｽｿｽｿｽｿｽ]ｿｽﾊの会ｿｽｿｽﾅ使ｿｽpｿｽｿｽｿｽ驍ｩｿｽwｿｽｿｽ */
! 	Uint8	vramA1;    /* VRAM A1 ｿｽｿｽｿｽｿｽｿｽ]ｿｽﾊの会ｿｽｿｽﾅ使ｿｽpｿｽｿｽｿｽ驍ｩｿｽwｿｽｿｽ      */
! 	Uint8	vramB0;    /* VRAM B or B0 ｿｽｿｽｿｽｿｽｿｽ]ｿｽﾊの会ｿｽｿｽﾅ使ｿｽpｿｽｿｽｿｽ驍ｩｿｽwｿｽｿｽ */
! 	Uint8	vramB1;    /* VRAM B1 ｿｽｿｽｿｽｿｽｿｽ]ｿｽﾊの会ｿｽｿｽﾅ使ｿｽpｿｽｿｽｿｽ驍ｩｿｽwｿｽｿｽ      */
! 	Uint8	colram;    /* ｿｽJｿｽｿｽｿｽ[ｿｽqｿｽ`ｿｽlｿｽﾉ係ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽuｿｽｿｽｿｽｿｽｿｽH        */
! } SclVramConfig;
! 
! typedef struct SclRotreg{
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	SclXyz16	viewp;
! 	Uint16		dummy1;
! 	SclXyz16	rotatecenter;
! 	Uint16		dummy2;
! 	SclXy		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! 	Fixed32		dummy3[8];
! } SclRotreg;
! 
! typedef struct SclRotparam{
! 	Uint32		addr;
! 	SclXyz		screenst;
! 	SclXy		screendlt;
! 	SclXy		delta;
! 	Fixed32		matrix_a;
! 	Fixed32		matrix_b;
! 	Fixed32		matrix_c;
! 	Fixed32		matrix_d;
! 	Fixed32		matrix_e;
! 	Fixed32		matrix_f;
! 	Fixed32		matrix_g;
! 	Fixed32		matrix_h;
! 	Fixed32		matrix_i;
! 	Fixed32		drotangle;
! 	SclXyz		viewp;
! 	SclXyz		rotatecenter;
! 	SclXyz		disprotcenter;
! 	SclXyz		move;
! 	SclXy		zoom;
! 	Fixed32		k_tab;
! 	SclXy		k_delta;
! 	Uint16		k_size;
! } SclRotparam;
! 
! /*******************************************
!  *      Scroll Configure Data Structure    *
!  *******************************************/
! typedef	struct	SclConfig {
! 	Uint8		dispenbl;
! 	Uint8		charsize;
! 	Uint8		pnamesize;
! 	Uint8		platesize;
! 	Uint8		bmpsize;
! 	Uint8		coltype;
! 	Uint8		datatype;
! 	Uint8		mapover;
! 	Uint8		flip;
! 	Uint16		patnamecontrl;
! 	Uint32		plate_addr[16];
! } SclConfig;
! 
! /******************************************************
!  *      Line & Cell Scroll Parameter Data Structure   *
!  ******************************************************/
! #define	SCL_MAXLINE	512
! #define	SCL_MAXCELL	64
! 
! typedef	struct	SclLineparam{
! 	Uint8		delta_enbl;
! 	Uint8		v_enbl;
! 	Uint8		h_enbl;
! 	Uint8		cell_enbl;
! 	Uint8		interval;
! 	Uint32		line_addr;
! 	Uint32		cell_addr;
! 	SclLineTb	line_tbl[SCL_MAXLINE];
! 	Fixed32		cell_tbl[SCL_MAXCELL];
! }	SclLineparam;
! 
! typedef	struct	SclLineWin{
! 	Uint16		winum;
! 	Uint16		y[2];
! 	Uint32		addr;
! 	SclXy16		tbl[SCL_MAXLINE];
! }	SclLineWin;
! 
! 
! #define SCL_VDP2_VRAM		0x25e00000
! #define SCL_VDP2_VRAM_A		0x25e00000
! #define SCL_VDP2_VRAM_A0	0x25e00000
! #define SCL_VDP2_VRAM_A1	0x25e20000
! #define SCL_VDP2_VRAM_B		0x25e40000
! #define SCL_VDP2_VRAM_B0	0x25e40000
! #define SCL_VDP2_VRAM_B1	0x25e60000
! #define	SCL_COLRAM_ADDR		0x25F00000	/* Color RAM */
! 
! #define SCL_NON			0   /* RBG0ｿｽﾅは使ｿｽpｿｽｿｽｿｽﾈゑｿｽ        */
! #define SCL_RBG0_K 		1   /* RBG0ｿｽﾌ係ｿｽｿｽﾃｰｿｽｿｽﾙゑｿｽｿｽuｿｽｿｽ     */
! #define SCL_RBG0_PN 		2   /* RBG0ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈｰｿｽﾃｰｿｽｿｽﾙゑｿｽｿｽuｿｽｿｽ */
! #define SCL_RBG0_CHAR 		3   /* RBG0ｿｽﾌｷｿｽﾗｸｿｽｿｽｿｽｿｽuｿｽｿｽ         */
! #define SCL_RBG1_K 		4   /* RBG1ｿｽﾌ係ｿｽｿｽﾃｰｿｽｿｽﾙゑｿｽｿｽuｿｽｿｽ     */
! 
! #define	SCL_CHAR_SIZE_1X1	0
! #define	SCL_CHAR_SIZE_2X2	1
! 
! #define	SCL_PN2WORD		0
! #define	SCL_PN1WORD		1
! 
! #define	SCL_PL_SIZE_1X1		0
! #define	SCL_PL_SIZE_2X1		1
! #define	SCL_PL_SIZE_2X2		3
! 
! #define	SCL_BMP_SIZE_512X256	0
! #define	SCL_BMP_SIZE_512X512	1
! #define	SCL_BMP_SIZE_1024X256	2
! #define	SCL_BMP_SIZE_1024X512	3
! 
! #define	SCL_COL_TYPE_16		0
! #define	SCL_COL_TYPE_256	1
! #define	SCL_COL_TYPE_2048	2
! #define	SCL_COL_TYPE_32K	3
! #define	SCL_COL_TYPE_1M		4
! 
! #define	SCL_CELL		0
! #define	SCL_BITMAP		1
! 
! #define	SCL_OVER_0		0
! #define	SCL_OVER_1		1
! #define	SCL_OVER_2		2
! #define	SCL_OVER_3		3
! 
! #define	SCL_PN_10BIT		0
! #define	SCL_PN_12BIT		1
! 
! #define	SCL_1_LINE		0
! #define	SCL_2_LINE		1
! #define	SCL_4_LINE		2
! 
! #define	SCL_NON_INTER		0
! #define	SCL_SINGLE_INTER	2
! #define	SCL_DOUBLE_INTER	3
! 
! #define	SCL_224LINE		0
! #define	SCL_240LINE		1
! #define	SCL_256LINE		2
! 
! #define	SCL_NORMAL_A		0
! #define	SCL_NORMAL_B		1
! #define	SCL_HIRESO_A		2
! #define	SCL_HIRESO_B		3
! #define	SCL_NORMAL_AE		4
! #define	SCL_NORMAL_BE		5
! #define	SCL_HIRESO_AE		6
! #define	SCL_HIRESO_BE		7
! 
! #define	SCL_X_AXIS		1
! #define	SCL_Y_AXIS		2
! 
! #define	SCL_W0			0
! #define	SCL_W1			1
! 
! #define FIXED(x)	      ((Fixed32)((x) * 65536.0))
! #define MUL_FIXED(a, b)       MTH_Mul(a, b)
! #define DIV_FIXED(a, b)       MTH_Div(a, b)
! 
! #endif	/* ifndef SEGA_SCR_H */
! 
! 
! /*------------------------------------------------------------------------
!  *
!  *
!  *  DESCRIPTION:
!  *
!  *          Header file for Priority library internal use.
!  *          Each Macro Set a parameter on Register buffer.
!  *          the buffer will copy to REAL regster while V-interval.
!  *          ｿｽｿｽｿｽｿｽｿｽﾉゑｿｽｿｽｿｽｿｽ}ｿｽNｿｽｿｽｿｽﾍ、ｿｽｿｽｿｽWｿｽXｿｽ^ｿｽoｿｽbｿｽtｿｽ@ｿｽﾉ各ｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽlｿｽｿｽ
!  *          ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾝ、ｿｽｿｽｿｽｿｽｿｽｿｽｿｽだｿｽｿｽWｿｽXｿｽ^ｿｽoｿｽbｿｽtｿｽ@ｿｽﾌダｿｽ[ｿｽeｿｽBｿｽ[ｿｽtｿｽｿｽｿｽOｿｽｿｽ
!  *          1 ｿｽﾉゑｿｽｿｽｿｽｿｽB
! -------------------------------------------------------------------------*/
! 
! #ifndef __PRI_GLVAR
! #define __PRI_GLVAR
! 
! #ifndef __PRI_MACRO
! #define __PRI_MACRO
! 
! #ifndef __PRI_REG
! #define __PRI_REG
! 
! /*-----< other group regs >----*/
! typedef struct {
!     volatile Uint16 SpriteControl;		/* 1800E0 */
!     volatile Uint16 ShadowControl;		/* 1800E2 */
!     volatile Uint16 ColorRamOffset0;		/* 1800E4 */
!     volatile Uint16 ColorRamOffset1;		/* 1800E6 */
!     volatile Uint16 LineColorEnable;		/* 1800E8 */
!     volatile Uint16 SpecialPriorityMode;		/* 1800EA */
!     volatile Uint16 ColorMixControl;		/* 1800EC */
!     volatile Uint16 SpecialColorMixMode;		/* 1800EE */
! } SclOtherPriRegister;
! 
! /*----< sprite priority >----*/
! typedef struct {
!     volatile Uint16 PriorityNumberSP01;		/* 1800F0 */
!     volatile Uint16 PriorityNumberSP23;		/* 1800F2 */
!     volatile Uint16 PriorityNumberSP45;		/* 1800F4 */
!     volatile Uint16 PriorityNumberSP67;		/* 1800F6 */
! } SclSpPriNumRegister;
! 
! /*----< scroll priority >----*/
! typedef struct {
!     volatile Uint16 PriorityNumberNBG01;		/* 1800F8 */
!     volatile Uint16 PriorityNumberNBG23;		/* 1800FA */
!     volatile Uint16 PriorityNumberRBG0;		/* 1800FC */
! } SclBgPriNumRegister;
! 
! /*----< sprite color Mix >----*/
! typedef struct {
!     volatile Uint16 ColMixRateSP01;		/* 180100 */
!     volatile Uint16 ColMixRateSP23;		/* 180102 */
!     volatile Uint16 ColMixRateSP45;		/* 180104 */
!     volatile Uint16 ColMixRateSP67;		/* 180106 */
! } SclSpColMixRegister;
! 
! /*----< scroll color Mix >----*/
! typedef struct {
!     volatile Uint16 ColMixRateNBG01;		/* 180108 */
!     volatile Uint16 ColMixRateNBG23;		/* 18010A */
!     volatile Uint16 ColMixRateRBG0;		/* 18010C */
!     volatile Uint16 ColMixRateLCBAK;		/* 18010E */
! } SclBgColMixRegister;
! 
! /*----< color offset >----*/
! typedef struct {
!     volatile Uint16 ColorOffsetEnable;		/* 180110 */
!     volatile Uint16 ColorOffsetSelect;		/* 180112 */
!     volatile Uint16 ColorOffsetA_RED;		/* 180114 */
!     volatile Uint16 ColorOffsetA_GREEN;		/* 180116 */
!     volatile Uint16 ColorOffsetA_BLUE;		/* 180118 */
!     volatile Uint16 ColorOffsetB_RED;		/* 18011A */
!     volatile Uint16 ColorOffsetB_GREEN;		/* 18011E */
!     volatile Uint16 ColorOffsetB_BLUE;		/* 180120 */
! } SclColOffsetRegister;
! 
! /*---- ｿｽｿｽｿｽWｿｽXｿｽ^ｿｽoｿｽbｿｽtｿｽ@ｿｽﾌダｿｽ[ｿｽeｿｽBｿｽ[ｿｽEｿｽtｿｽｿｽｿｽO */
! typedef struct
! {
!     volatile Uint32 SclOtherPri:1;
!     volatile Uint32 SclSpPriNum:1;
!     volatile Uint32 SclBgPriNum:1;
!     volatile Uint32 SclSpColMix:1;
!     volatile Uint32 SclBgColMix:1;
!     volatile Uint32 SclColOffset:1;
! } SclPriBuffDirtyFlags;
! 
! #endif /* __PRI_REG */
! 
! 
! extern SclOtherPriRegister	SclOtherPri;
! extern SclSpPriNumRegister	SclSpPriNum;
! extern SclBgPriNumRegister	SclBgPriNum;
! extern SclSpColMixRegister	SclSpColMix;
! extern SclBgColMixRegister	SclBgColMix;
! extern SclColOffsetRegister	SclColOffset;
! extern SclPriBuffDirtyFlags	SclPriBuffDirty;
! 
! /* Following macros never check argument value range.*/
! 
! /* VDP-II manual p.129 */
! #define SCL_SET_SPCCCS(/* 2 bits */ spcccs) /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽFｿｽｿｽｿｽZｿｽｿｽｿｽｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0x0FFF) | ((spcccs) << 12))
! 
! #define SCL_GET_SPCCCS() \
!   ((SclOtherPri.SpriteControl & 0x3000) >> 12)
! 
! #define SCL_SET_SPCCN(/* 3 bits */ spccn) /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽFｿｽｿｽｿｽZｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽo */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xF0FF) | ((spccn) << 8))
! 
! #define SCL_GET_SPCCN() \
!   ((SclOtherPri.SpriteControl & 0x0700) >> 8)
! 
! #define SCL_SET_SPCLMD(/* 1 bit */ spclmd) /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌ色ｿｽ`ｿｽｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFDF) | ((spclmd) << 5))
! 
! #define SCL_GET_SPCLMD() \
!   ((SclOtherPri.SpriteControl & 0x0020) >> 5)
! 
! #define SCL_SET_SPWINEN(/* 1 bit */ spwinen) /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽEｿｽBｿｽｿｽｿｽhｿｽEｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFEF) | ((spwinen) << 4))    /* -> p.121 */
! 
! #define SCL_GET_SPWINEN() \
!   ((SclOtherPri.SpriteControl & 0x0010) >> 4)
! 
! #define SCL_SET_SPTYPE(/* 4bits */ sptype) /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌタｿｽCｿｽvｿｽwｿｽｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1,\
!    SclOtherPri.SpriteControl \
!    = (SclOtherPri.SpriteControl & 0xFFF0) | (sptype))
! 
! #define SCL_GET_SPTYPE() \
!   (SclOtherPri.SpriteControl & 0x000F)
! 
! /* VDP-II manual p.131 */
! /*-------------------- ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽpｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽｿｽｿｽWｿｽXｿｽ^ No.0-7 */
! 
! #define SCL_SET_S0PRIN(/* 3 bits */ s0prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1,\
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xFFF0) | (s0prin))
! 
! #define SCL_GET_S0PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0007))
! 
! #define SCL_SET_S1PRIN(/* 3 bits */ s1prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP01 \
!    = (SclSpPriNum.PriorityNumberSP01 & 0xF0FF) | ((s1prin) << 8))
! 
! #define SCL_GET_S1PRIN() \
!   ((SclSpPriNum.PriorityNumberSP01 & 0x0700) >> 8)
! 
! #define SCL_SET_S2PRIN(/* 3 bits */ s2prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xFFF0) | ((s2prin)))
! 
! #define SCL_GET_S2PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0007))
! 
! #define SCL_SET_S3PRIN(/* 3 bits */ s3prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP23 \
!    = (SclSpPriNum.PriorityNumberSP23 & 0xF0FF) | ((s3prin) << 8))
! 
! #define SCL_GET_S3PRIN() \
!   ((SclSpPriNum.PriorityNumberSP23 & 0x0700) >> 8)
! 
! #define SCL_SET_S4PRIN(/* 3 bits */ s4prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xFFF0) | ((s4prin)))
! 
! #define SCL_GET_S4PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0007))
! 
! #define SCL_SET_S5PRIN(/* 3 bits */ s5prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP45 \
!    = (SclSpPriNum.PriorityNumberSP45 & 0xF0FF) | ((s5prin) << 8))
! 
! #define SCL_GET_S5PRIN() \
!   ((SclSpPriNum.PriorityNumberSP45 & 0x0700) >> 8)
! 
! #define SCL_SET_S6PRIN(/* 3 bits */ s6prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xFFF0) | ((s6prin)))
! 
! #define SCL_GET_S6PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0007))
! 
! #define SCL_SET_S7PRIN(/* 3 bits */ s7prin) \
!   (SclPriBuffDirty.SclSpPriNum = 1, \
!    SclSpPriNum.PriorityNumberSP67 \
!    = (SclSpPriNum.PriorityNumberSP67 & 0xF0FF) | ((s7prin) << 8))
! 
! #define SCL_GET_S7PRIN() \
!   ((SclSpPriNum.PriorityNumberSP67 & 0x0700) >> 8)
! 
! /* VDP-II manual p.132 */
! /*------------------- ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽpｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽｿｽｿｽｿｽｿｽｿｽｿｽWｿｽXｿｽ^ No.0-7 */
! 
! #define SCL_SET_S0CCRT(/* 5bits */ s0ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0xFF00) | ((s0ccrt)))
! 
! #define SCL_GET_S0CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x001F) >> 0)
! 
! #define SCL_SET_S1CCRT(/* 5bits */ s1ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP01 \
!    = (SclSpColMix.ColMixRateSP01 & 0x00FF) | ((s1ccrt) << 8))
! 
! #define SCL_GET_S1CCRT() \
!   ((SclSpColMix.ColMixRateSP01 & 0x1F00) >> 8)
! 
! #define SCL_SET_S2CCRT(/* 5bits */ s2ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0xFF00) | ((s2ccrt)))
! 
! #define SCL_GET_S2CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x001F))
! 
! #define SCL_SET_S3CCRT(/* 5bits */ s3ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP23 \
!    = (SclSpColMix.ColMixRateSP23 & 0x00FF) | ((s3ccrt) << 8))
! 
! #define SCL_GET_S3CCRT() \
!   ((SclSpColMix.ColMixRateSP23 & 0x1F00) >> 8)
! 
! #define SCL_SET_S4CCRT(/* 5bits */ s4ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0xFF00) | ((s4ccrt)))
! 
! #define SCL_GET_S4CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x001F))
! 
! #define SCL_SET_S5CCRT(/* 5bits */ s5ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP45 \
!    = (SclSpColMix.ColMixRateSP45 & 0x00FF) | ((s5ccrt) << 8))
! 
! #define SCL_GET_S5CCRT() \
!   ((SclSpColMix.ColMixRateSP45 & 0x1F00) >> 8)
! 
! #define SCL_SET_S6CCRT(/* 5bits */ s6ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0xFF00) | ((s6ccrt)))
! 
! #define SCL_GET_S6CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x001F))
! 
! #define SCL_SET_S7CCRT(/* 5bits */ s7ccrt) \
!   (SclPriBuffDirty.SclSpColMix = 1, \
!    SclSpColMix.ColMixRateSP67 \
!    = (SclSpColMix.ColMixRateSP67 & 0x00FF) | ((s7ccrt) << 8))
! 
! #define SCL_GET_S7CCRT() \
!   ((SclSpColMix.ColMixRateSP67 & 0x1F00) >> 8)
! 
! /* VDP-II manual p.138 */
! /*-- ｿｽJｿｽｿｽｿｽ[ RAM ｿｽAｿｽhｿｽｿｽｿｽXｿｽIｿｽtｿｽZｿｽbｿｽg N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0CAOS(/* 3bits */ n0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFFF0) | ((n0caos)))
! 
! #define SCL_GET_N0CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0007))
! 
! #define SCL_SET_N1CAOS(/* 3bits */ n1caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xFF0F) | ((n1caos) << 4))
! 
! #define SCL_GET_N1CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0070) >> 4)
! 
! #define SCL_SET_N2CAOS(/* 3bits */ n2caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0xF0FF) | ((n2caos) << 8))
! 
! #define SCL_GET_N2CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x0700) >> 8)
! 
! #define SCL_SET_N3CAOS(/* 3bits */ n3caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset0 \
!    = (SclOtherPri.ColorRamOffset0 & 0x0FFF) | ((n3caos) << 12))
! 
! #define SCL_GET_N3CAOS() \
!   ((SclOtherPri.ColorRamOffset0 & 0x7000) >> 12)
! 
! #define SCL_SET_R0CAOS(/* 3bits */ r0caos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFFF0) | ((r0caos) << 0))
! 
! #define SCL_GET_R0CAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0007) >> 0)
! 
! #define SCL_SET_SPCAOS(/* 3bits */ spcaos) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorRamOffset1 \
!    = (SclOtherPri.ColorRamOffset1 & 0xFF0F) | ((spcaos) << 4))
! 
! #define SCL_GET_SPCAOS() \
!   ((SclOtherPri.ColorRamOffset1 & 0x0070) >> 4)
! 
! 
! /*----- ｿｽｿｽｿｽCｿｽｿｽｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽﾊイｿｽlｿｽ[ｿｽuｿｽｿｽ N0|R1, N1|EXBG, N2, N3, R0, SPRITE */
! 
! #define SCL_SET_N0LCEN(/* 1bit */ n0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFE) | ((n0lcen)))
! 
! #define SCL_GET_N0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0001))
! 
! #define SCL_SET_N1LCEN(/* 1bit */ n1lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFD) | ((n1lcen) << 1))
! 
! #define SCL_GET_N1LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2LCEN(/* 1bit */ n2lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFFB) | ((n2lcen) << 2))
! 
! #define SCL_GET_N2LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3LCEN(/* 1bit */ n3lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFF7) | ((n3lcen) << 3))
! 
! #define SCL_GET_N3LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0LCEN(/* 1bit */ r0lcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFEF) | ((r0lcen) << 4))
! 
! #define SCL_GET_R0LCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0010) >> 4)
! 
! #define SCL_SET_SPLCEN(/* 1bit */ splcen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.LineColorEnable \
!    = (SclOtherPri.LineColorEnable & 0xFFDF) | ((splcen) << 5))
! 
! #define SCL_GET_SPLCEN() \
!   ((SclOtherPri.LineColorEnable & 0x0020) >> 5)
! 
! /*-------- ｿｽｿｽｿｽｿｽｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽｿｽｿｽ[ｿｽh N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0SPRM(/* 2bits */ n0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFFC) | ((n0sprm)))
! 
! #define SCL_GET_N0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0003))
! 
! #define SCL_SET_N1SPRM(/* 2bits */ n1sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFF3) | ((n1sprm) << 2))
! 
! #define SCL_GET_N1SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SPRM(/* 2bits */ n2sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFFCF) | ((n2sprm) << 4))
! 
! #define SCL_GET_N2SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SPRM(/* 2bits */ n3sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFF3F) | ((n3sprm) << 6))
! 
! #define SCL_GET_N3SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SPRM(/* 2bits */ r0sprm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialPriorityMode \
!    = (SclOtherPri.SpecialPriorityMode & 0xFCFF) | ((r0sprm) << 8))
! 
! #define SCL_GET_R0SPRM() \
!   ((SclOtherPri.SpecialPriorityMode & 0x0300) >> 8)
! 
! /*---------ｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽ[ｿｽﾔ搾ｿｽ N0|R1, N1|EXBG, N2, N3, R0 */
! 
! #define SCL_SET_N0PRIN(/* 3 bits */ n0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0xFF00) | ((n0prin)))
! 
! #define SCL_GET_N0PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0007))
! 
! #define SCL_SET_N1PRIN(/* 3 bits */ n1prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG01 \
!    = (SclBgPriNum.PriorityNumberNBG01 & 0x00FF) | ((n1prin) << 8))
! 
! #define SCL_GET_N1PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG01 & 0x0700) >> 8)
! 
! #define SCL_SET_N2PRIN(/* 3 bits */ n2prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0xFF00) | ((n2prin)))
! 
! #define SCL_GET_N2PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0007))
! 
! #define SCL_SET_N3PRIN(/* 3 bits */ n3prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberNBG23 \
!    = (SclBgPriNum.PriorityNumberNBG23 & 0x00FF) | ((n3prin) << 8))
! 
! #define SCL_GET_N3PRIN() \
!   ((SclBgPriNum.PriorityNumberNBG23 & 0x0700) >> 8)
! 
! #define SCL_SET_R0PRIN(/* 3 bits */ r0prin) \
!   (SclPriBuffDirty.SclBgPriNum = 1, \
!    SclBgPriNum.PriorityNumberRBG0 \
!    = ((r0prin)))
! 
! #define SCL_GET_R0PRIN() \
!    ((SclBgPriNum.PriorityNumberRBG0 & 0x0007))
! 
! #define SCL_SET_BOKEN(/* 1 bits */ boken) /* ｿｽ{ｿｽJｿｽVｿｽｿｽｿｽZｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x7FFF) | ((boken) << 15))
! 
! #define SCL_GET_B0KEN() \
!   ((SclOtherPri.ColorMixControl & 0x8000) >> 15)
! 
! #define SCL_SET_BOKN(/* 3 bits */ bokn) /* ｿｽ{ｿｽJｿｽVｿｽｿｽｿｽﾊ番搾ｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0x8FFF) | ((bokn) << 12))
! 
! #define SCL_GET_BOKN() \
!   ((SclOtherPri.ColorMixControl & 0x7000) >> 12)
! 
! #define SCL_SET_EXCCEN(/* 1 bit */ exccn) /* ｿｽgｿｽｿｽｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽ */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFBFF) | ((exccn) << 10))
! 
! #define SCL_GET_EXCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0400) >> 10)
! 
! #define SCL_SET_CCRTMD(/* 1 bit */ ccrtmd) /* ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽh */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFDFF) | ((Uint32)(ccrtmd) << 9))
! 
! #define SCL_GET_CCRTMD() \
!   ((SclOtherPri.ColorMixControl & 0x0200) >> 9)
! 
! #define SCL_SET_CCMD(/* 1 bit */ ccmd) /* ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽｿｽｿｽ[ｿｽh */\
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFEFF) | ((Uint32)(ccmd) << 8))
! 
! #define SCL_GET_CCMD() \
!   ((SclOtherPri.ColorMixControl & 0x0100) >> 8)
! 
! /*------ ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽ N0|R1, N1|EXBG, N2, N3, R0, LC, SPRITE */
! #define SCL_SET_SPCCEN(/* 1 bit */ spccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFBF) | ((spccen) << 6))
! 
! #define SCL_GET_SPCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0040) >> 6)
! 
! #define SCL_SET_LCCCEN(/* 1 bit */ lcccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFDF) | ((lcccen) << 5))
! 
! #define SCL_GET_LCCCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0020) >> 5)
! 
! #define SCL_SET_R0CCEN(/* 1 bit */ r0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFEF) | ((r0ccen) << 4))
! 
! #define SCL_GET_R0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0010) >> 4)
! 
! #define SCL_SET_N3CCEN(/* 1 bit */ n3ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFF7) | ((n3ccen) << 3))
! 
! #define SCL_GET_N3CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0008) >> 3)
! 
! #define SCL_SET_N2CCEN(/* 1 bit */ n2ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFB) | ((n2ccen) << 2))
! 
! #define SCL_GET_N2CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0004) >> 2)
! 
! #define SCL_SET_N1CCEN(/* 1 bit */ n1ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFD) | ((n1ccen) << 1))
! 
! #define SCL_GET_N1CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0002) >> 1)
! 
! #define SCL_SET_N0CCEN(/* 1 bit */ n0ccen) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ColorMixControl \
!    = (SclOtherPri.ColorMixControl & 0xFFFE) | ((n0ccen)))
! 
! #define SCL_GET_N0CCEN() \
!   ((SclOtherPri.ColorMixControl & 0x0001))
! 
! 
! /*-------------- ｿｽｿｽｿｽｿｽｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽｿｽｿｽ[ｿｽh N0|R1, N1|EXBG, N2, N3, R0 */
! #define SCL_SET_N0SCCM(/* 2 bits */ n0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFFC) | ((n0sccm)))
! 
! #define SCL_GET_N0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0003))
! 
! #define SCL_SET_N1SCCM(/* 2 bits */ n1sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFF3) | ((n1sccm) << 2))
! 
! #define SCL_GET_N1SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x000C) >> 2)
! 
! #define SCL_SET_N2SCCM(/* 2 bits */ n2sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFFCF) | ((n2sccm) << 4))
! 
! #define SCL_GET_N2SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0030) >> 4)
! 
! #define SCL_SET_N3SCCM(/* 2 bits */ n3sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!    = (SclOtherPri.SpecialColorMixMode & 0xFF3F) | ((n3sccm) << 6))
! 
! #define SCL_GET_N3SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x00C0) >> 6)
! 
! #define SCL_SET_R0SCCM(/* 2 bits */ r0sccm) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.SpecialColorMixMode \
!   = (SclOtherPri.SpecialColorMixMode & 0xFCFF) | ((r0sccm) << 8))
! 
! #define SCL_GET_R0SCCM() \
!   ((SclOtherPri.SpecialColorMixMode & 0x0300) >> 8)
! 
! /*------ ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾊ用ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽｿｽｿｽｿｽ N0|R1, N1|EXBG, N2, N3, R0, LC, BACK */
! #define SCL_SET_N0CCRT(/* 5 bits */ n0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0xFF00) | ((n0ccrt)))
! 
! #define SCL_GET_N0CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x001F))
! 
! #define SCL_SET_N1CCRT(/* 5 bits */ n1ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG01 \
!    = (SclBgColMix.ColMixRateNBG01 & 0x00FF) | ((n1ccrt) << 8))
! 
! #define SCL_GET_N1CCRT() \
!   ((SclBgColMix.ColMixRateNBG01 & 0x1F00) >> 8)
! 
! #define SCL_SET_N2CCRT(/* 5 bits */ n2ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0xFF00) | ((n2ccrt)))
! 
! #define SCL_GET_N2CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x001F))
! 
! #define SCL_SET_N3CCRT(/* 5 bits */ n3ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateNBG23 \
!    = (SclBgColMix.ColMixRateNBG23 & 0x00FF) | ((n3ccrt) << 8))
! 
! #define SCL_GET_N3CCRT() \
!   ((SclBgColMix.ColMixRateNBG23 & 0x1F00) >> 8)
! 
! #define SCL_SET_R0CCRT(/* 5 bits */ r0ccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateRBG0 \
!    = ((r0ccrt)))
! 
! #define SCL_GET_R0CCRT() \
!   ((SclBgColMix.ColMixRateRBG0 & 0x001F))
! 
! #define SCL_SET_LCCCRT(/* 5 bits */ lcccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0xFF00) | ((lcccrt)))
! 
! #define SCL_GET_LCCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x001F))
! 
! #define SCL_SET_BKCCRT(/* 5 bits */ bkccrt) \
!   (SclPriBuffDirty.SclBgColMix = 1, \
!    SclBgColMix.ColMixRateLCBAK \
!    = (SclBgColMix.ColMixRateLCBAK & 0x00FF) | ((bkccrt) << 8))
! 
! #define SCL_GET_BKCCRT() \
!   ((SclBgColMix.ColMixRateLCBAK & 0x1F00) >> 8)
! 
! /*-- ｿｽJｿｽｿｽｿｽ[ｿｽIｿｽtｿｽZｿｽbｿｽgｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽ N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COEN(/* 1 bit */ n0coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFE) | ((n0coen)))
! 
! #define SCL_GET_N0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0001))
! 
! #define SCL_SET_N1COEN(/* 1 bit */ n1coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFD) | ((n1coen) << 1))
! 
! #define SCL_GET_N1COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0002) >> 1)
! 
! #define SCL_SET_N2COEN(/* 1 bit */ n2coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFFB) | ((n2coen) << 2))
! 
! #define SCL_GET_N2COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0004) >> 2)
! 
! #define SCL_SET_N3COEN(/* 1 bit */ n3coen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFF7) | ((n3coen) << 3))
! 
! #define SCL_GET_N3COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0008) >> 3)
! 
! #define SCL_SET_R0COEN(/* 1 bit */ r0coen) \
!    (SclPriBuffDirty.SclColOffset = 1, \
!     SclColOffset.ColorOffsetEnable \
!     = (SclColOffset.ColorOffsetEnable & 0xFFEF) | ((r0coen) << 4))
! 
! #define SCL_GET_R0COEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOEN(/* 1 bit */ bkcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFDF) | ((bkcoen) << 5))
! 
! #define SCL_GET_BKCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOEN(/* 1 bit */ spcoen) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetEnable \
!    = (SclColOffset.ColorOffsetEnable & 0xFFBF) | ((spcoen) << 6))
! 
! #define SCL_GET_SPCOEN() \
!   ((SclColOffset.ColorOffsetEnable & 0x0040) >> 6)
! 
! /*--- ｿｽJｿｽｿｽｿｽ[ｿｽIｿｽtｿｽZｿｽbｿｽgｿｽｿｽｿｽWｿｽXｿｽ^ｿｽIｿｽｿｽ N0|R1, N1|EXBG, N2, N3, R0, BACK, SPRITE */
! 
! #define SCL_SET_N0COSL(/* 1 bit */ n0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFE) | (n0cosl))
! 
! #define SCL_GET_N0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0001))
! 
! #define SCL_SET_N1COSL(/* 1 bit */ n1cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFD) | ((n1cosl) << 1))
! 
! #define SCL_GET_N1COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0002) >> 1)
! 
! #define SCL_SET_N2COSL(/* 1 bit */ n2cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFFB) | ((n2cosl) << 2))
! 
! #define SCL_GET_N2COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0004) >> 2)
! 
! #define SCL_SET_N3COSL(/* 1 bit */ n3cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFF7) | ((n3cosl) << 3))
! 
! #define SCL_GET_N3COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0008) >> 3)
! 
! #define SCL_SET_R0COSL(/* 1 bit */ r0cosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFEF) | ((r0cosl) << 4))
! 
! #define SCL_GET_R0COSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0010) >> 4)
! 
! #define SCL_SET_BKCOSL(/* 1 bit */ bkcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFDF) | ((bkcosl) << 5))
! 
! #define SCL_GET_BKCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0020) >> 5)
! 
! #define SCL_SET_SPCOSL(/* 1 bit */ spcosl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetSelect \
!    = (SclColOffset.ColorOffsetSelect & 0xFFBF) | ((spcosl) << 6))
! 
! #define SCL_GET_SPCOSL() \
!   ((SclColOffset.ColorOffsetSelect & 0x0040) >> 6)
! 
! /* ｿｽJｿｽｿｽｿｽ[ｿｽIｿｽtｿｽZｿｽbｿｽgｿｽｿｽｿｽWｿｽXｿｽ^ A */
! #define SCL_SET_COARD(/* 9 bit */ coard) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_RED \
!    = (coard))
! 
! #define SCL_GET_COARD() \
!   (SclColOffset.ColorOffsetA_RED & 0x01FF)
! 
! #define SCL_SET_COAGR(/* 9 bit */ coagr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_GREEN \
!    = (coagr))
! 
! #define SCL_GET_COAGR() \
!   (SclColOffset.ColorOffsetA_GREEN & 0x01FF)
! 
! #define SCL_SET_COABL(/* 9 bit */ coabl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetA_BLUE \
!    = (coabl))
! 
! #define SCL_GET_COABL() \
!   (SclColOffset.ColorOffsetA_BLUE & 0x01FF)
! 
! /* ｿｽJｿｽｿｽｿｽ[ｿｽIｿｽtｿｽZｿｽbｿｽgｿｽｿｽｿｽWｿｽXｿｽ^ B*/
! #define SCL_SET_COBRD(/* 9 bit */ cobrd) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_RED \
!    = (cobrd))
! 
! #define SCL_GET_COBRD() \
!    (SclColOffset.ColorOffsetB_RED & 0x01FF)
! 
! #define SCL_SET_COBGR(/* 9 bit */ cobgr) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_GREEN \
!    = (cobgr))
! 
! #define SCL_GET_COBGR() \
!   (SclColOffset.ColorOffsetB_GREEN & 0x01FF)
! 
! #define SCL_SET_COBBL(/* 9 bit */ cobbl) \
!   (SclPriBuffDirty.SclColOffset = 1, \
!    SclColOffset.ColorOffsetB_BLUE \
!    = (cobbl))
! 
! #define SCL_GET_COBBL() \
!   (SclColOffset.ColorOffsetB_BLUE & 0x01FF)
! 
! /*----------- ｿｽVｿｽｿｽｿｽhｿｽEｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽ N0|R1, N1|EXBG, N2, N3, R0, BACK */
! 
! #define SCL_SET_N0SDEN(/* 1 bit */ n0sden) \
!    (SclPriBuffDirty.SclOtherPri = 1, \
!     SclOtherPri.ShadowControl \
!     = (SclOtherPri.ShadowControl & 0xFFFE) | ((n0sden)))
! 
! #define SCL_GET_N0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0001))
! 
! #define SCL_SET_N1SDEN(/* 1 bit */ n1sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFD) | ((n1sden) << 1))
! 
! #define SCL_GET_N1SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0002) >> 1)
! 
! #define SCL_SET_N2SDEN(/* 1 bit */ n2sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFFB) | ((n2sden) << 2))
! 
! #define SCL_GET_N2SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0004) >> 2)
! 
! #define SCL_SET_N3SDEN(/* 1 bit */ n3sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFF7) | ((n3sden) << 3))
! 
! #define SCL_GET_N3SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0008) >> 3)
! 
! #define SCL_SET_R0SDEN(/* 1 bit */ r0sden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFEF) | ((r0sden) << 4))
! 
! #define SCL_GET_R0SDEN() \
!   ((SclOtherPri.ShadowControl & 0x0010) >> 4)
! 
! #define SCL_SET_BKSDEN(/* 1 bit */ bksden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFFDF) | ((bksden) << 5))
! 
! #define SCL_GET_BKSDEN() \
!   ((SclOtherPri.ShadowControl & 0x0020) >> 5)
! 
! /*--------------------------------------- ｿｽｿｽｿｽｿｽｿｽVｿｽｿｽｿｽhｿｽEｿｽZｿｽｿｽｿｽNｿｽg */
! #define SCL_SET_TPSDSL(/* 1 bit */ tpsden) \
!   (SclPriBuffDirty.SclOtherPri = 1, \
!    SclOtherPri.ShadowControl \
!    = (SclOtherPri.ShadowControl & 0xFEFF) | ((tpsden) << 8))
! 
! #define SCL_GET_TPSDSL() \
!   ((SclOtherPri.ShadowControl & 0x0100) >> 8)
! 
! /*---------------------------ｿｽJｿｽｿｽｿｽ[ RAM ｿｽｿｽｿｽ[ｿｽh */
! /* 0x1800E ｿｽﾔ地ｿｽﾉゑｿｽｿｽｿｽｿｽﾌゑｿｽ ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾅ設定すｿｽｿｽ */
! 
! /* ｿｽlｿｽﾌ抵ｿｽｿｽ` */
! 
! #define SCL_RBG0	0x00000001
! #define SCL_RBG1	0x00000002
! #define SCL_NBG0	0x00000004
! #define SCL_NBG1	0x00000008
! #define SCL_NBG2	0x00000010
! #define SCL_NBG3	0x00000020
! 
! #define SCL_EXBG	0x00000080
! #define SCL_SPR 	0x00000100
! #define SCL_SP0 	0x00000100
! #define SCL_SP1 	0x00000200
! #define SCL_SP2 	0x00000400
! #define SCL_SP3 	0x00000800
! #define SCL_SP4 	0x00001000
! #define SCL_SP5 	0x00002000
! #define SCL_SP6 	0x00004000
! #define SCL_SP7 	0x00008000
! #define SCL_RP  	0x00010000
! #define SCL_RP_R	0xfffeffff
! #define SCL_CC  	0x00020000
! #define SCL_LNCL	0x00040000
! #define SCL_BACK	0x00080000
! 
! #define SCL_RBG_TB_A	SCL_RBG0
! #define SCL_RBG_TB_B	SCL_RBG1
! 
! #define SCL_CRM15_1024 0
! #define SCL_CRM15_2048 1
! #define SCL_CRM24_1024 2
! 
! /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌタｿｽCｿｽvｿｽwｿｽｿｽ */
! #define SCL_TYPE0	0
! #define SCL_TYPE1	1
! #define SCL_TYPE2	2
! #define SCL_TYPE3	3
! #define SCL_TYPE4	4
! #define SCL_TYPE5	5
! #define SCL_TYPE6	6
! #define SCL_TYPE7	7
! #define SCL_TYPE8	8
! #define SCL_TYPE9	9
! #define SCL_TYPEA	10
! #define SCL_TYPEB	11
! #define SCL_TYPEC	12
! #define SCL_TYPED	13
! #define SCL_TYPEE	14
! #define SCL_TYPEF	15
! 
! #define SCL_PALETTE	0
! #define SCL_MIX 	1
! 
! #define SCL_MSB_SHADOW	0
! #define SCL_SP_WINDOW	1
! 
! #define SCL_IF_BEHIND	0
! #define SCL_IF_EQUAL	1
! #define SCL_IF_FRONT	2
! #define SCL_MSB_ON	3
! 
! #define SCL_OFFSET_A	0
! #define SCL_OFFSET_B	1
! 
! #endif /* __PRI_MACRO */
! 
! extern SclOtherPriRegister  SclOtherPri;  /* ｿｽｿｽｿｽいｿｽｿｽ */
! 
! extern SclSpPriNumRegister  SclSpPriNum;  /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌプｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽﾔ搾ｿｽ */
! 
! extern SclBgPriNumRegister  SclBgPriNum;  /* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌプｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽﾔ搾ｿｽ */
! 
! extern SclSpColMixRegister  SclSpColMix;  /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌ色ｿｽｿｽｿｽZ */
! 
! extern SclBgColMixRegister  SclBgColMix;  /* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ色ｿｽｿｽｿｽZ */
! 
! extern SclColOffsetRegister SclColOffset; /* ｿｽJｿｽｿｽｿｽ[ｿｽIｿｽtｿｽZｿｽbｿｽg */
! 
! extern SclPriBuffDirtyFlags SclPriBuffDirty; /* ｿｽｿｽｿｽWｿｽXｿｽ^ｿｽoｿｽbｿｽtｿｽ@ｿｽﾌダｿｽ[ｿｽeｿｽBｿｽ[ｿｽEｿｽtｿｽｿｽｿｽO */
! 
! /*--- REAL Priority Registers (Pointer) ---*/
! 
! extern SclOtherPriRegister  *SclRealOtherPri;
! 
! extern SclSpPriNumRegister  *SclRealSpPriNum;
! 
! extern SclBgPriNumRegister  *SclRealBgPriNum;
! 
! extern SclSpColMixRegister  *SclRealSpColMix;
! 
! extern SclBgColMixRegister  *SclRealBgColMix;
! 
! extern SclColOffsetRegister *SclRealColOffset;
! 
! #endif /* __PRI_GLVAR */
! 
! /* ｿｽuｿｽcｿｽoｿｽQｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌプｿｽｿｽｿｽgｿｽ^ｿｽCｿｽvｿｽ骭ｾ */
! #ifndef	SEGA_SCL_PROTO
! #define SEGA_SCL_PROTO
! 
! extern	void	SCL_Vdp2Init(void);
! extern	void	SCL_SetDisplayMode(Uint8 interlace,Uint8 vertical,Uint8 horizontal);
! extern	void	SCL_InitVramConfigTb(SclVramConfig *tp);
! extern	void	SCL_InitConfigTb(SclConfig *scfg);
! extern	void	SCL_InitLineParamTb(SclLineparam *lp);
! extern	void	SCL_SetVramConfig(SclVramConfig *tp);
! extern	void	SCL_SetConfig(Uint16 sclnum, SclConfig *scfg);
! extern	void	SCL_SetCycleTable(Uint16 *tp);
! extern	void	SCL_Open(Uint32 sclnum);
! extern	void	SCL_Close(void);
! extern	void	SCL_SetLineParam(SclLineparam *lp);
! extern	void	SCL_MoveTo(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Move(Fixed32 x,Fixed32 y,Fixed32 z);
! extern	void	SCL_Scale(Fixed32 Sx, Fixed32 Sy);
! extern	void	SCL_SetColRamMode(Uint32 ComRamMode);
! extern	Uint32	SCL_InitRotateTable(Uint32 Address,Uint16 Mode,Uint32 rA,Uint32 rB);
! extern	void	SCL_RotateTo(Fixed32 xy,Fixed32 z,Fixed32 disp,Uint16 mode);
! extern	void	SCL_Rotate(Fixed32 xy,Fixed32 z,Fixed32 disp);
! extern	void	SCL_SetRotateViewPoint(Uint16 x,Uint16 y,Uint16 z);
! extern	void    SCL_SetRotateZoom(Fixed32 x,Fixed32 y);
! extern	void	SCL_SetRotateCenter(Uint16 x,Uint16 y,Uint16 z);
! extern	void	SCL_SetRotateCenterDisp(Uint16 x,Uint16 y);
! extern	void	SCL_SetCoefficientData(Uint32 sclnum,Uint16 *data,Uint16 x,Uint16 y);
! extern	void	SCL_SetLncl(Uint32 addr,Uint16 tbnum,Uint16 *palNumTb);
! extern	void	SCL_SetBack(Uint32 addr,Uint16 dataSize,Uint16 *dataTb);
! extern	void	SCL_SetMosaic(Uint32 surface,Uint8 x,Uint8 y);
! extern	void	SCL_SetSpriteMode(Uint8 Type, Uint8 ColMode, Uint8 WinMode);
! extern	Uint32	SCL_GetColRamMode(void);
! extern	void	SCL_SetColRam(Uint32 Object, Uint32 Index,Uint32 num,void *Color);
! extern	Uint32	SCL_AllocColRam(Uint32 Surface, Uint32 NumOfColors, Uint8 transparent);
! extern	void	SCL_FreeColRam(Uint32 Surface);
! extern	void	SCL_SetAutoColChg(Uint32 Surface,Uint32 Interval,Uint32 Index,
! 			Uint32 NumOfCol,Uint32 NumOfTbl,Uint32 *ChangeTbl);
! extern	Uint32	SCL_GetColRamOffset(Uint32 Object);
! extern	void	SCL_SetPriority(Uint32 Object, Uint8 Priority);
! extern	Uint8	SCL_GetPriority(Uint32 Object);
! extern	void	SCL_SetColMixMode(Uint32 ColMixPriority, Uint8 Mode);
! extern	void	SCL_SetColMixRate(Uint32 Surfaces, Uint8 Rate);
! extern	void	SCL_SetAutoColMix(Uint32 Surfaces,Uint32 Interval,Uint32 Time,
! 			Uint8 StartRate,Uint8 EndRate);
! extern	void	SCL_SetColOffset(Uint32 OffsetReg, Uint32 Surfaces,
! 			Sint16 red, Sint16 green, Sint16 blue);
! extern	void	SCL_IncColOffset(Uint32 OffsetReg,Sint16 red,Sint16 green,Sint16 blue);
! extern	void	SCL_SetAutoColOffset(Uint32 OffsetReg,Uint32 Interval,Uint32 Time,
! 				SclRgb *start,SclRgb *end);
! extern	void	SCL_EnableBlur(Uint32 Surface);
! extern	void	SCL_DisableBlur(void);
! extern	void	SCL_EnableLineCol(Uint32 Surface);
! extern	void	SCL_DisableLineCol(Uint32 Surface);
! extern	void	SCL_SetWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint16 sx,Uint16 sy,Uint16 ex,Uint16 ey);
! extern	void	SCL_SetLineWindow(Uint8 win,Uint32 logic,Uint32 enable,Uint32 area,
! 			Uint32 addr,Uint32 sy,Uint32 tbSize,SclLineWindowTb *tp);
! extern	void	SCL_SetSpriteWindow(Uint32 logic,Uint32 enable,Uint32 area);
! extern	void	SCL_SetFrameInterval(Uint16 count);
! extern	void	SCL_DisplayFrame(void);
! extern	void	SCL_VblankStart(void);
! extern	void	SCL_VblankEnd(void);
! extern	void	SCL_AbortAutoVe(void);
! 
! /* ｿｽｿｽｿｽﾊサｿｽCｿｽYｿｽfｿｽtｿｽHｿｽｿｽｿｽg */
! extern	Uint16	SclDisplayX;
! extern	Uint16	SclDisplayY;
! 
! /* ｿｽｿｽｿｽWｿｽXｿｽ^ｿｽoｿｽbｿｽtｿｽ@ */
! extern	SclSysreg	Scl_s_reg;
! extern	SclDataset	Scl_d_reg;
! extern	SclNorscl	Scl_n_reg;
! extern	SclRotscl	Scl_r_reg;
! extern	SclWinscl	Scl_w_reg;
! extern	Uint16		SclProcess;
! 
! void	SCL_SglOn(void);		/*	use SGL	*/
! void	SCL_SglOff(void);		/*	use SGL	*/
! 
! #endif /* SEGA_SCL_PROTO */
diff -crBN --binary sbl6/segalib/include/sega_spr.h sbl6_patch/segalib/include/sega_spr.h
*** sbl6/segalib/include/sega_spr.h	1996-02-08 05:23:50.000000000 -0500
--- sbl6_patch/segalib/include/sega_spr.h	2021-11-17 07:11:02.000000000 -0500
***************
*** 1,787 ****
! /*----------------------------------------------------------------------------
!  *  sega_spr.h -- SPR ライブラリ インクルードファイル
!  *  Copyright(c) 1994 SEGA
!  *  Written by H.E on 1994-07-25 Ver.1.00
!  *  Updated by H.E on 1994-07-25 Ver.1.00
!  *  Updated by H.O on 1995-11-14 Ver.1.00a SSHOFF対策
!  *
!  *  スプライト表示用インクルードファイルで使用スプライト表示ライブラリの種別に
!  *  より以下のように定義します。
!  *
!  *  （１）スプライト表示基本処理のみの場合
!  *
!  *        #include "sega_spr.h"
!  *
!  *  （２）スプライト表示拡張処理の場合
!  *
!  *        #define  _SPR2_
!  *        #include "sega_spr.h"
!  *
!  *  （３）スプライト３Ｄ表示処理の場合
!  *
!  *        #define  _SPR3_
!  *        #include "sega_spr.h"
!  *
!  *
!  *----------------------------------------------------------------------------
!  */
! 
! #ifndef SEGA_SPR_H
! #define SEGA_SPR_H
! 
! #include        "sega_xpt.h"
! #include        "sega_def.h"
! #include        "sega_mth.h"
! 
! /*------------------------------------------
!  * Select 3D & Sprite Execute Environment
!  *----------------------------------------*/
! #define  SPR_SYNC_VB_OUT
! #define  USE_SLAVE
! #define  USE_DSP
! #define  USE_INBETWEEN_OBJECT
! #define  USE_DEBUG_INFO
! 
! /*-----------------------------------
!  * Select 3D Execute Machine
!  *---------------------------------*/
! #define  _PC_         0
! #define  _INDIGO2_    1
! #define  _SH_         2
! 
! 
! /*
!  * Set Machine Environment
!  */
! #define NO_EXIST    0
! #define    EXIST    1
! 
! #if defined(_PC)
!    #define _MACHINE  _PC_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_INDIGO2)
!    #define _MACHINE  _INDIGO2_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_SH)
!    #define _MACHINE  _SH_
!    #define _DSP         EXIST
!    #define _MATH     NO_EXIST
! #endif
! 
! #ifdef _SPR3_
!    #define _SPR2_
! #endif
! 
! 
! /*
!  * EXTERNAL FUNCTION PROTOTYPE DECLARATIONS
!  */
! typedef void PARA_RTN(void *parm);
! void  SPR_InitSlaveSH(void);
! void  SPR_RunSlaveSH(PARA_RTN *routine, void *parm);
! void  SPR_WaitEndSlaveSH(void);
! 
! 
! /**************** SEGA_SP1.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! 
! #define  VRAM_SIZE           512*1024   /* 512 Kbyte                        */
! #define  FBUF_SIZE           256*1024   /* 256 Kbyte * 2 bank               */
! 
! #define  AUTO_FRAME_CHG           0     /* auto frame change mode           */
! #define  MANUAL_FRAME_CHG         1     /* manual frame change mode         */
! #define  NO_INTER_FRAME_CHG       2     /* no interval frame change mode    */
! #define  NO_INTER_VBE_FRAME_CHG   3     /* v-blank erase no interval frm chg*/
! 
! #define  SPR_FBCR_MANUAL     0x0003     /* frame buffer manual change       */
! #define  SPR_FBCR_AUTO       0x0000     /* frame buffer auto change         */
! #define  SPR_FBCR_ERASE      0x0002     /* frame buffer next erase on       */
! #define  SPR_FBCR_DIE        0x0008     /* double interlace on              */
! #define  SPR_FBCR_DIL        0x0004     /* double interlace plot line       */
! #define  SPR_FBCR_EOS        0x0010     /* even/odd data sampling select bit*/
! 
! #define  SPR_TV_NORMAL       0          /* Normal TV mode                   */
! #define  SPR_TV_HIRESO       1          /* High Resolution TV mode          */
! #define  SPR_TV_ROT16        2          /* Rotate 16 bit TV mode            */
! #define  SPR_TV_ROT8         3          /* Rotate 8 bit TV mode             */
! #define  SPR_TV_HDTV         4          /* HDTV TV mode                     */
! 
! #define  SPR_TV_320X224      0          /* Screen size 320 x 224            */
! #define  SPR_TV_320X240      1          /* Screen size 320 x 240            */
! #define  SPR_TV_352X224      2          /* Screen size 352 x 224            */
! #define  SPR_TV_352X240      3          /* Screen size 352 x 240            */
! #define  SPR_TV_640X224      4          /* Screen size 640 x 224            */
! #define  SPR_TV_640X240      5          /* Screen size 640 x 240            */
! #define  SPR_TV_704X224      6          /* Screen size 704 x 224            */
! #define  SPR_TV_704X240      7          /* Screen size 704 x 240            */
! 
! #define  SPR_W_TVMR          0x00000000 /* TV mode selection                */
! #define  SPR_W_FBCR          0x00000002 /* Frame buf change mode            */
! #define  SPR_W_PTMR          0x00000004 /* Draw start control               */
! #define  SPR_W_EWDR          0x00000006 /* Erase write data                 */
! #define  SPR_W_EWLR          0x00000008 /* Erase write area left top point  */
! #define  SPR_W_EWRR          0x0000000A /* Erase write area right bot point */
! #define  SPR_W_ENDR          0x0000000C /* Stop VDP1                        */
! #define  SPR_R_EDSR          0x00000010 /* Transfer complete status         */
! #define  SPR_R_LOPR          0x00000012 /* End command table address        */
! #define  SPR_R_COPR          0x00000014 /* Executing command table address  */
! #define  SPR_R_MODR          0x00000016 /* Write register Mode status       */
! 
! #define  SPR_R_EXTEN         0x00000002 /* VDP2 External Signal Enable Reg  */
! #define  SPR_R_TVSTAT        0x00000004 /* VDP2 TV Status Reg               */
! #define  SPR_R_VCNT          0x0000000A /* VDP2 V Counter Reg               */
! 
! #define  VRAM_ADDR           0x25C00000 /* Sprite IC VRAM area address      */
! #define  FBUF_ADDR           0x25C80000 /* Sprite frame buffer address      */
! #define  VDP1_REG_BASE       0x25D00000 /* Sprite IC Register base address  */
! #define  VDP2_REG_BASE       0x25F80000 /* Sprite IC Register base address  */
! 
! struct SprSpStatus {
!     Uint16  frameChgMode;             /* Frame Change Mode                 */
!     Uint16  frameEraseMode;           /* Frame Erase  Mode                 */
!     Uint16  vbInterval;               /* V-Blank Interval for Frame Change */
!     Uint16  eraseData;
!     Uint16  eraseLeftX;
!     Uint16  eraseTopY;
!     Uint16  eraseRightX;
!     Uint16  eraseBotY;
! };
! 
! typedef struct SprSpStatus SprSpStatus;
! 
! #define SPR_WRITE_REG(reg, val) \
!       *(volatile Uint16*)(VDP1_REG_BASE+(reg)) = (val)
! #define SPR_READ_REG(reg) \
!       (*(volatile Uint16*)(VDP1_REG_BASE+(reg)))
! #define SPR_SCLWRITE_REG(reg, val) \
!       *(volatile Uint16*)(VDP2_REG_BASE+(reg)) = (val)
! #define SPR_SCLREAD_REG(reg) \
!       (*(volatile Uint16*)(VDP2_REG_BASE+(reg)))
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! #if	0
! /*
! **■1995-09-19	高橋智延
! **	幾つかのオブジェクトは、割り込み処理の中で触られるので、volatile にする。
! */
! extern Sint32  SpScreenX;               /* TV Screen X Size                  */
! extern Sint32  SpScreenY;               /* TV Screen Y Size                  */
! extern Uint16  SpFrameChgMode;          /* Frame Change Mode                 */
! extern Sint32  SpFrameEraseMode;        /* Frame Erase  Mode                 */
! extern Sint32  VBInterval;              /* V-Blank Interval for Frame Change */
! extern Sint32  VBIntervalCounter;       /* V-Blank Interval Counter          */
! extern Sint32  ReqDisplayFlag;          /* Display Request flag              */
! extern Uint16  SpTvMode;                /* TV Mode                           */
! extern Uint16  SpFbcrMode;              /* Frame Buffer Chane Mode           */
! extern Uint16  SpDie;                   /* Double Interlace Enable Flag      */
! extern Uint16  SpDil;                   /* Double Interlace Plot Line        */
! #else
! extern Sint32			SpScreenX;			/* TV Screen X Size                  */
! extern Sint32			SpScreenY;			/* TV Screen Y Size                  */
! extern volatile Uint16	SpFrameChgMode;		/* Frame Change Mode                 */
! extern volatile Sint32	SpFrameEraseMode;	/* Frame Erase  Mode                 */
! extern volatile Sint32	VBInterval;			/* V-Blank Interval for Frame Change */
! extern volatile Sint32	VBIntervalCounter;	/* V-Blank Interval Counter          */
! extern volatile Sint32	ReqDisplayFlag;		/* Display Request flag              */
! extern Uint16			SpTvMode;			/* TV Mode                           */
! extern Uint16			SpFbcrMode;			/* Frame Buffer Chane Mode           */
! extern Uint16			SpDie;				/* Double Interlace Enable Flag      */
! extern Uint16			SpDil;				/* Double Interlace Plot Line        */
! #endif
! 
! /*
!  * EXTERNAL FUNCTION PROTOTYPE DECLARATIONS
!  */
! void SPR_Initial (Uint8 **VRAM);
! void SPR_SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void SPR_GetStatus (SprSpStatus *spStatus);
! void SPR_SetEraseData (Uint16 eraseData, Uint16 leftX,  Uint16 topY,
!                                          Uint16 rightX, Uint16 botY);
! void SPR_WaitDrawEnd (void);
! void SPR_SetEosMode(Sint32 eosFlag);
! void sprMemCpyL(void *dst, void *src, int count);
! void sprMemCpyW(void *dst, void *src, int count);
! 
! 
! #ifdef _SPR2_
! /**************** SEGA_SP2.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define  FIXED32_MIN         0x80000000
! #define  FIXED32_MAX         0x7fffffff
! 
! #define  CTRL_END            0x8000     /* control word end bit mask        */
! #define  CTRL_SKIP           0x4000     /* control word skip bit mask       */
! #define  CTRL_JUMP           0x3000     /* control word jump bit mask       */
! #define  CTRL_ZOOM           0x0f00     /* control word zoom point bit mask */
! #define  CTRL_FUNC           0x000f     /* control word function bit mask   */
! #define  CTRL_DIR            0x0030     /* control word char read bit mask  */
! 
! #define  DRAW_COMPO          0x0003     /* draw mode word color compose mask*/
! #define  DRAW_GOURAU         0x0004     /* draw mode word gouraud shading   */
! #define  DRAW_GOURAU_GRAY    0x0804     /* draw mode word gray gour shading */
! #define  DRAW_COLOR          0x0038     /* draw mode word color mode mask   */
! #define  DRAW_MESH           0x0100     /* draw mode word mesh on           */
! 
! #define  COMPO_REP           0x0000     /* color compose reprace mode       */
! #define  COMPO_SHADOW        0x0001     /* color compose shadow mode        */
! #define  COMPO_HARF          0x0002     /* color compose harf luminance mode*/
! #define  COMPO_TRANS         0x0003     /* color compose trunslucent mode   */
! 
! #define  FUNC_NORMALSP       0x0000     /* draw normal sprite function      */
! #define  FUNC_SCALESP        0x0001     /* draw scaled sprite function      */
! #define  FUNC_DISTORSP       0x0002     /* draw distorted sprite function   */
! #define  FUNC_POLYGON        0x0004     /* draw polygon function            */
! #define  FUNC_POLYLINE       0x0005     /* draw polyline function           */
! #define  FUNC_LINE           0x0006     /* draw line function               */
! #define  FUNC_SCLIP          0x0009     /* set system clipping function     */
! #define  FUNC_UCLIP          0x0008     /* set user clipping function       */
! #define  FUNC_LCOORD         0x000a     /* set local coordinate function    */
! #define  FUNC_TEXTURE        0x0004     /* texture command group mask       */
! 
! #define  JUMP_NEXT           0x0000     /* jump next command                */
! #define  JUMP_ASSIGN         0x1000     /* jump assign command              */
! #define  JUMP_CALL           0x2000     /* call assign command              */
! #define  JUMP_RETURN         0x3000     /* return command subroutine        */
! #define  SKIP_NEXT           0x4000     /* skip next command                */
! #define  SKIP_ASSIGN         0x5000     /* skip assign command              */
! #define  SKIP_CALL           0x6000     /* skip call assign command         */
! #define  SKIP_RETURN         0x7000     /* skip return command subroutine   */
! 
! #define  ZOOM_NOPOINT        0x0000     /* zoom no point                    */
! #define  ZOOM_TL             0x0500     /* zoom point top left              */
! #define  ZOOM_TM             0x0600     /* zoom point top middle            */
! #define  ZOOM_TR             0x0700     /* zoom point top right             */
! #define  ZOOM_ML             0x0900     /* zoom point middle left           */
! #define  ZOOM_MM             0x0a00     /* zoom point center                */
! #define  ZOOM_MR             0x0b00     /* zoom point middle right          */
! #define  ZOOM_BL             0x0c00     /* zoom point bottom left           */
! #define  ZOOM_BM             0x0e00     /* zoom point bottom middle         */
! #define  ZOOM_BR             0x0f00     /* zoom point bottom right          */
! 
! #define  DIR_NOREV           0x0000     /* char read not reverse            */
! #define  DIR_TBREV           0x0020     /* char read top/bottom reverse     */
! #define  DIR_LRREV           0x0010     /* char read left/right reverse     */
! #define  DIR_LRTBREV         0x0030     /* char read left/right/top/bot rev */
! 
! #define  ECD_DISABLE         0x0080     /* ECD disabe & SPD enable          */
! #define  SPD_DISABLE         0x0040     /* ECD enable & SPD disable         */
! #define  ECDSPD_DISABLE      0x00c0     /* ECD & SPD disable                */
! #define  UCLPIN_ENABLE       0x0400     /* CLIP IN enable                   */
! #define  UCLPOUT_ENABLE      0x0600     /* CLIP OUT enable                  */
! #define  HSS_ENABLE          0x1000     /* HSS enable                       */
! #define  PCLP_ENABLE         0x0800     /* PCLP disable                     */
! 
! #define  COLOR_0             0x0000     /* 4 bit/pixel & 16 color bank mode */
! #define  COLOR_1             0x0008     /* 4 bit/pixel & 16 color lookup tbl*/
! #define  COLOR_2             0x0010     /* 8 bit/pixel &  64 color bank mode*/
! #define  COLOR_3             0x0018     /* 8 bit/pixel & 128 color bank mode*/
! #define  COLOR_4             0x0020     /* 8 bit/pixel & 256 color bank mode*/
! #define  COLOR_5             0x0028     /* 16 bit/pixel & RGB mode          */
! 
! #define  NO_GOUR             0xffff     /* no use Gouraud Shading Table No. */
! 
! #define  SPR_2DRAW_PRTY_ON   1          /* command draw priority on         */
! #define  SPR_2DRAW_PRTY_OFF  0          /* command draw priority off        */
! #define  SPR_2MOST_FAR       0          /* draw sprite most far position    */
! #define  SPR_2MOST_NEAR      0x7fffffff /* draw sprite most near position   */
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprSpCmd {                       /* Sprite Command Table             */
!     Uint16  control;                    /* control word                     */
!     Uint16  link;                       /* command link                     */
!     Uint16  drawMode;                   /* draw mode                        */
!     Uint16  color;                      /* color info.                      */
!     Uint16  charAddr;                   /* character address                */
!     Uint16  charSize;                   /* character size                   */
!     Sint16  ax;                         /* point A x                        */
!     Sint16  ay;                         /* point A y                        */
!     Sint16  bx;                         /* point B x                        */
!     Sint16  by;                         /* point B y                        */
!     Sint16  cx;                         /* point C x                        */
!     Sint16  cy;                         /* point C y                        */
!     Sint16  dx;                         /* point D x                        */
!     Sint16  dy;                         /* point D y                        */
!     Uint16  grshAddr;                   /* gouraud shading table address    */
!     Uint16  dummy;                      /* dummy area                       */
! };
! 
! struct SprSpCmdR {
!     Uint32  dummy[8];                   /* dummy area                       */
! };
! 
! 
! struct SprGourTbl {
!     Uint16  entry[4];
! };
! 
! struct SprGourTblR {
!     Uint32  entry[2];
! };
! 
! struct SprLookupTbl {
!     Uint16  entry[16];
! };
! 
! /*
!  * TYPEDEFS
!  */
! typedef Uint16 Vaddr;                       /* Relative Address in The VRAM  */
! typedef struct SprSpCmd     SprSpCmd;
! typedef struct SprSpCmdR    SprSpCmdR;
! typedef struct SprGourTbl   SprGourTbl;
! typedef struct SprGourTblR  SprGourTblR;
! typedef struct SprLookupTbl SprLookupTbl;
! typedef struct SprAreaSize  SprAreaSize;
! /* internal data type */
! typedef	struct SprCharTbl    SprCharTbl;
! typedef struct SprDrawPrtyBlk SprDrawPrtyBlk;
! typedef	struct Spr2WorkArea   Spr2WorkArea;
! 
! struct SprCharTbl {                         /* Character Entry Table         */
!     Vaddr     addr;                         /* Character Relative Address    */
!     Uint16    xySize;                       /* Charcter Size (X * Y)         */
!     Uint16    mode;                         /* Charcter Mode (0-5)           */
!     Uint16    color;                        /* Color Bank or LookUp Tbl No   */
!     Uint16    size;                         /* Charcter Size (by the 32 byte)*/
! };
! 
! struct SprDrawPrtyBlk {         /* 描画プライオリティブロックテーブル        */
!     Uint16      topNo;          /* 先頭コマンドチェインエントリ番号          */
!     Uint16      botNo;          /* 末尾コマンドチェインエントリ番号          */
! };
! 
! struct Spr2WorkArea {                    /* SP2 Work Area Define             */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     SprCharTbl     *charTbl;             /* Character Tbl Pointer            */
!     SprSpCmd       *mstCmd;              /* Master Command Buffer            */
!     SprDrawPrtyBlk *mstDrawPrtyBlk;      /* Master Draw Priority Block       */
!     SprSpCmd       *slvCmd;              /* Slave Command Buffer             */
!     SprDrawPrtyBlk *slvDrawPrtyBlk;      /* Slave Draw Priority Block        */
!     SprGourTbl     *gourTbl;             /* Gour Tbl Max                     */
! };
! 
! struct SprAreaSize {                     /* SP2 Work Area Size               */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     Uint16         useCommandCount;      /* Using Command Block Count        */
!     Uint16         charRemainBlkCount;   /* Char Total Remain Null Blk Count */
!     Uint16         charNullBlkMaxSize;   /* Char Null Block Max Size         */
! };
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! extern Sint32  SpLCoordX;                   /* Local Origin X Position       */
! extern Sint32  SpLCoordY;                   /* Local Origin Y Position       */
! 
! #ifdef _SPR3_
! #define   SPR_2DefineWork(sp2WorkArea, sp2CommandMax, sp2GourTblMax, \
! 			  sp2LookupTblMax, sp2CharMax, sp2DrawPrtyBlkMax) \
! static SprCharTbl      sp2CharTbl         [sp2CharMax]; \
! static SprSpCmdR       sp2MstSpCmd        [sp2CommandMax/2]; \
! static SprDrawPrtyBlk  sp2MstDrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static SprSpCmdR       sp2SlvSpCmd        [sp2CommandMax/2]; \
! static SprDrawPrtyBlk  sp2SlvDrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static SprGourTblR     sp2GourTbl         [sp2GourTblMax+32]; \
! static Spr2WorkArea sp2WorkArea  = {  \
! 	sp2CommandMax, sp2GourTblMax+32, sp2LookupTblMax, sp2CharMax, \
! 	sp2DrawPrtyBlkMax, sp2CharTbl, \
! 	(SprSpCmd*)sp2MstSpCmd, sp2MstDrawPrtyBlk, (SprSpCmd*)sp2SlvSpCmd, \
!         sp2SlvDrawPrtyBlk, (SprGourTbl*)sp2GourTbl };
! #else
! #define   SPR_2DefineWork(sp2WorkArea, sp2CommandMax, sp2GourTblMax, \
! 			  sp2LookupTblMax, sp2CharMax, sp2DrawPrtyBlkMax) \
! static SprCharTbl      sp2CharTbl         [sp2CharMax]; \
! static SprSpCmdR       sp2MstSpCmd        [sp2CommandMax]; \
! static SprDrawPrtyBlk  sp2MstDrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static SprGourTblR     sp2GourTbl         [sp2GourTblMax+1]; \
! static Spr2WorkArea sp2WorkArea  = {  \
! 	sp2CommandMax, sp2GourTblMax, sp2LookupTblMax, sp2CharMax, \
! 	sp2DrawPrtyBlkMax, sp2CharTbl, \
! 	(SprSpCmd*)sp2MstSpCmd, sp2MstDrawPrtyBlk, NULL, \
!         NULL, (SprGourTbl*)sp2GourTbl };
! #endif
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_2Initial (Spr2WorkArea  *workArea);
! /** SSHOFF対策。SPR_2Initial2追加 '95-11/14 **/
! void   SPR_2Initial2(Spr2WorkArea  *workArea);
! void   SPR_2SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void   SPR_2FrameChgIntr (Uint16);
! void   SPR_2FrameEraseData (Uint16);
! void   SPR_2SetGourTbl (Uint16, SprGourTbl *);
! void   SPR_2SetLookupTbl (Uint16, SprLookupTbl *);
! #if	0
! /*
! **■1995-09-11	高橋智延
! **	＜仕様変更＞
! **	領域の確保に失敗したら、あるいは、確保されている領域のサイズよりもセッ
! **	トしようとするデータのサイズが大きい場合には、エラーコードを返すように
! **	する。
! */
! void   SPR_2SetChar (Uint16, Uint16, Uint16, Uint16, Uint16, Uint8 *);
! #else
! int		SPR_2SetChar(Uint16, Uint16, Uint16, Uint16, Uint16, Uint8 *);
! #endif
! void   SPR_2ClrChar (Uint16);
! void   SPR_2ClrAllChar (void);
! Uint16 SPR_2GourTblNoToVram (Uint16);
! Uint16 SPR_2LookupTblNoToVram (Uint16);
! Uint16 SPR_2CharNoToVram (Uint16);
! void   SPR_2GetAreaSizeInfo(SprAreaSize  *areaSizeInfo);
! void   SPR_2OpenCommand (Uint16);
! void   SPR_2CloseCommand (void);
! void   SPR_2FlushDrawPrty (void);
! void   SPR_2LocalCoord (Sint32, XyInt *);
! void   SPR_2SysClip (Sint32, XyInt *);
! void   SPR_2UserClip (Sint32, XyInt *);
! void   SPR_2Line (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2PolyLine (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2Polygon (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2NormSpr (Sint32, Uint16, Uint16, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2ScaleSpr (Sint32, Uint16, Uint16, Uint16, 
!                                       Uint16, XyInt *xy, Uint16);
! void   SPR_2DistSpr (Sint32, Uint16, Uint16, Uint16,
!                                      Uint16, XyInt *xy, Uint16);
! void   SPR_2Cmd (Sint32, SprSpCmd *);
! 
! #endif /* _SPR2_ */
! 
! #ifdef _SPR3_
! /**************** SEGA_SP3.H *************************************************/
! /*
!  * TYPEDEFS
!  */
! typedef	struct SprCluster   SprCluster;
! typedef	struct SprObject3D  SprObject3D;
! typedef	struct SprSurface   SprSurface;
! typedef	struct SprInbetInf  SprInbetInf;
! typedef	struct SprTexture   SprTexture;
! typedef struct Spr3dStatus  Spr3dStatus;
! /* internal data type */
! typedef	struct Spr3WorkArea Spr3WorkArea;
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprCluster {
!     Uint16	no;             /* クラスタ番号                              */
!     Uint16	angleSeq;       /* 回転順序                                  */
!     MthXyz	angle;	        /* 親クラスタの座標系における回転            */
!     MthXyz	point;	        /* 親クラスタの座標系における原点の座標      */
!     SprObject3D	*object;        /* ３Ｄオブジェクト                          */
!     SprCluster	*next;       	/* 次クラスタ                                */
!     SprCluster	*child;      	/* 子クラスタ                                */
!     SprInbetInf *inbetInf;     	/* ３Ｄオブジェクト間接続ポリゴン情報        */
!     void        (*transStart)(SprCluster*);
!                                 /* 座標変換開始前ユーザコールバックルーチン  */
!     void        (*transEnd)(SprCluster*, SprObject3D*, MthMatrix*, MthXyz*);
!                                 /* 座標変換終了後ユーザコールバックルーチン  */
!     void        *context;       /* ユーザコンテキストエリア                  */
! };
! 
! struct SprObject3D {
!     Uint16	no;             /* オブジェクト番号                          */
!     Uint16      dispFlag;       /* 表示フラグ                                */
!     Uint16      vertCount;      /* 頂点数                                    */
!     Uint16      surfaceCount;   /* 面数                                      */
!     MthXyz      *vertPoint;     /* 頂点座標テーブル                          */
!     MthXyz      *vertNormal;    /* 頂点の法線ベクトルテーブル                */
!     SprSurface  *surface;       /* 面定義テーブル                            */
!     MthXyz      *surfaceNormal; /* 面の法線ベクトルテーブル                  */
!     void        *filler;        /* 未使用                                    */
!     Uint16      **shdIdxTbl;    /* シェーディングインデックステーブル        */
!     Fixed32     surfNormK;      /* 面法線ベクトルの計算補正値                */
!     SprObject3D *next;          /* 次３Ｄオブジェクト                        */
! };
! 
! struct SprSurface {
!     Uint16     vertNo[4];       /* 面を構成する頂点番号                      */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
! };
! 
! struct SprInbetInf {
!     Sint32       vertCount;     /* 取り出し頂点数                            */
!     SprObject3D  *fromObj;      /* 接続頂点データ取り出しオブジェクト        */
!     Uint16       *fromVertNo;   /* 取り出し頂点番号配列                      */
!     SprObject3D  *toObj;        /* 接続頂点データ設定オブジェクト            */
!     Uint16       *toVertNo;     /* 設定頂点番号配列                          */
!     SprInbetInf  *next;         /* 次３Ｄオブジェクト間接続ポリゴン情報      */
! };
! 
! struct SprTexture {
!     Uint16       charNo;        /* キャラクタ番号                            */
!     Uint16       colorMode;     /* カラーモード                              */
!     Uint16       color;         /* カラーデータ（ｶﾗｰﾊﾞﾝｸorﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙNo）   */
!     Uint16       width;         /* キャラクタの幅                            */
!     Uint16       height;        /* キャラクタの高さ                          */
!     Uint8        *charData;     /* キャラクタデータのポインタ                */
!     SprLookupTbl *lookupTbl;    /* ルックアップテーブルのポインタ            */
! };
! 
! struct Spr3WorkArea {
!     Uint16      objSurfMax;        /* オブジェクト内最大面数                 */
!     Uint16      objVertMax;        /* オブジェクト内最大頂点数               */
!     Sint32      *surfBright;       /* 面輝度テーブル                         */
!     Sint32      *vertBright;       /* 頂点輝度テーブル                       */
!     MthXyz      *coordView3D;      /* ３Ｄ視点座標変換後テーブル             */
!     XyInt       *coord2D;          /* ２Ｄ透視変換後テーブル                 */
!     MthXyz      *coordWorld3D;     /* ３Ｄワールド座標変換後テーブル         */
! };
! 
! struct Spr3dStatus {
!     MthXyz    lightAngle;       /* 光源アングル                           */
!     MthXyz    viewCoordPoint;   /* 視点座標系内の視点位置                 */
!     MthXyz    viewPoint;        /* 視点座標                               */
!     MthXyz    viewAngle;        /* 視点アングル                           */
!     Sint32    viewAngleSeq;     /* 視点アングル回転操作                   */
!     Sint32    zSortMode;        /* ＺソートＺ座標値の採用モード           */
!     Fixed32   zSortZMin;        /* フラッシュ単位現Ｚ座標最小値           */
!     Fixed32   zSortZMax;        /* フラッシュ単位現Ｚ座標最大値           */
!     Fixed32   clipZMin;         /* 視点座標系クリップＺ最小値座標         */
!     Fixed32   clipZMax;         /* 視点座標系クリップＺ最大値座標         */
!     Sint32    clipLevel;        /* クリッピングレベル                     */
!     Sint32    unitPixelX;       /* X 1.0 に対するスクリーンのピクセル数   */
!     Sint32    unitPixelY;       /* Y 1.0 に対するスクリーンのピクセル数   */
! };
! 
! typedef struct TComTbl  TComTbl;
! struct TComTbl {
!     Fixed32     zSortBZMin;     /* i   フラッシュ単位前Ｚ座標最小値          */
!     int         zSftCnt;        /* i   ＺソートＺシフト数                    */
!     int         zSortBlkCnt;    /* i   Ｚソートブロック数                    */
!     Sint32      spriteDrawFlag; /* i   変形スプライト描画フラグ              */
!     Sint32      otherDrawFlag;  /* i   その他ポリゴン描画フラグ              */
!     Sint32      *unitPixel;     /* i   X,Y 1.0に対するスクリーンのピクセル数 */
!     Fixed32     *clipRatio;     /* i   ３Ｄクリッピング率 [0]=X, [1]=Y       */
!     Fixed32     *clipZ;         /* i   視点座標系クリップＺ [0]=min, [1]=max */
!     SprCharTbl  *charTbl;       /* i   スプライトキャラクタテーブル          */
!     Sint32      *vertBright;    /* i   頂点輝度テーブル                      */
!     MthXyz      *coordView3D;   /* i   ３Ｄ視点座標変換後テーブル            */
!     XyInt       *coord2D;       /* i   ２Ｄ透視変換後テーブル                */
!     int         dispFlag;       /* i   表示フラグ                            */
!     Uint16      **shdIdxTbl;    /* i   シェーディングインデックステーブル    */
!     Uint32      gourGrayTopR;   /* i   グーログレイ先頭ＶＲＡＭアドレス      */
!     Uint32      lookupTblR;     /* i   ルックアップテーブルＶＲＡＭ内位置    */
!     MthXyz      *lightVector;   /* i   光源ベクタ                            */
!     MthMatrix   *viewMatrix;    /* i   視点座標系への座標変換マトリックス    */
!     MthMatrix   *worldMatrix;   /* i   ワールド座標系への座標変換マトリックス*/
! };
! 
! typedef struct T3Dto2D  T3Dto2D;
! struct T3Dto2D {
!     int         vertCount;      /* i   頂点数                                */
!     int         surfaceCount;   /* i   面数                                  */
!     SprSurface  *surfInfo;      /* i   面定義テーブル                        */
!     MthXyz      *vertPoint;     /* i   頂点座標テーブル                      */
!     MthXyz      *surfaceNormal; /* i   面の法線ベクトルテーブル              */
!     MthXyz      *vertNormal;    /* i   頂点の法線ベクトルテーブル            */
!     MthXyz      *coordView3D;   /* o   ３Ｄ視点座標変換後テーブル            */
!     XyInt       *coord2D;       /* o   ２Ｄ透視変換後テーブル                */
!     Sint32      *surfBright;    /* o   面輝度テーブル                        */
!     Sint32      *vertBright;    /* o   頂点輝度テーブル                      */
!     MthXyz      *coordWorld3D;  /* o   頂点のワールド座標テーブル            */
! };
! 
! typedef struct T2DtoCmd  T2DtoCmd;
! struct T2DtoCmd {
!     int         surfaceCount;   /* i   面数                                  */
!     SprSurface  *surface;       /* i   面定義テーブル                        */
!     Sint32      *surfBright;    /* i   面輝度テーブル                        */
!     Fixed32     zSortZMin;      /* i/o フラッシュ単位現Ｚ座標最小値          */
!     Fixed32     zSortZMax;      /* i/o フラッシュ単位現Ｚ座標最大値          */
!     SprDrawPrtyBlk *prtyTbl;    /* i/o 描画プライオリティブロックテーブル    */
!     SprSpCmd    *cmdBuf;        /* o   スプライトコマンドバッファ            */
!     int         outCmdPos;      /* o   書き込みコマンド数                    */
!     SprGourTbl  *gourTblCur;    /* i/o グーロテーブルカレントアドレス        */
!     Uint32      gourTblCurR;    /* i/o グーロカレントＶＲＡＭアドレス        */
! };
! 
! typedef struct GetSurfNormPara  GetSurfNormPara;
! struct GetSurfNormPara {
!     int         surfaceCount;   /* i   面数                                  */
!     SprSurface  *surface;       /* i   面定義テーブル                        */
!     MthXyz      *vertPoint;     /* i   頂点座標テーブル                      */
!     Fixed32     surfNormK;      /* i   面法線ベクトルの計算補正値            */
!     MthXyz      *surfaceNormal; /* o   面の法線ベクトルテーブル              */
! };
! 
! 
! 
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define   ROT_SEQ_ZYX       0x0000
! #define   ROT_SEQ_ZXY       0x0001
! #define   ROT_SEQ_YZX       0x0002
! #define   ROT_SEQ_YXZ       0x0003
! #define   ROT_SEQ_XYZ       0x0004
! #define   ROT_SEQ_XZY       0x0005
! 
! #define   DISP_POLYGON      0x0000
! #define   DISP_POLYLINE     0x8000
! #define   DISP_MASK         0xc000
! #define   BOTH_FACE         0x1000
! 
! #define   NO_SHADING        0x0000
! #define   FLAT_SHADING      0x0100
! #define   GOURAUD_SHADING   0x0200
! #define   SHADING_MASK      0x0300
! #define   INBETWEEN_OBJECT  0x0010
! 
! #define   MATE_COLOR        0x0000
! #define   MATE_TEXTURE      0x4000
! #define   MATE_SHADING_TBL  0x8000
! #define   MATE_AUTO_SHADING 0xc000
! #define   MATE_MASK         0xc000
! 
! #define   ZSORT_MIN         0x0000
! #define   ZSORT_MAX         0x1000
! #define   ZSORT_MID         0x2000
! #define   ZSORT_MASK        0x3000
! #define   ZSORT_FLOAT_MODE  0
! #define   ZSORT_FIXED_MODE  1
! 
! #define   DRAW_MODE_MASK    0x07ff
! 
! 
! #define   SPR_3mac1(sp3ObjSurfMax) \
! static Sint32    sp3SurfBright [sp3ObjSurfMax];
! 
! #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac2(sp3ObjVertMax) \
! static MthXyz    sp3CoordView3D   [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Sint32    sp3VertBright    [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D  [sp3ObjVertMax];
! #else
! #define   SPR_3mac2(sp3ObjVertMax) \
! static MthXyz    sp3CoordView3D   [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Sint32    sp3VertBright    [sp3ObjVertMax];
! #endif
! 
! 
! 
! #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, sp3SurfBright, \
!    sp3VertBright, sp3CoordView3D, sp3Coord2D, sp3CoordWorld3D };
! #else
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, sp3SurfBright, \
!    sp3VertBright, sp3CoordView3D, sp3Coord2D, NULL };
! #endif
! 
! #define   SPR_3DefineWork(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
!  SPR_3mac1(sp3ObjSurfMax) \
!  SPR_3mac2(sp3ObjVertMax) \
!  SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)
! 
! 
! #ifdef USE_DEBUG_INFO
! extern int  dbgComputePol;
! extern int  dbgDrawPol;
! #endif
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_3Initial       (Spr3WorkArea  *workArea);
! void   SPR_3SetLight      (Uint16 moveKind, MthXyz *lightAngle);
! void   SPR_3SetView       (Uint16 moveKind, MthXyz *viewPoint,
!                            MthXyz *viewAngle, Uint16 angleSeq,
!                            MthXyz *viewCoordPoint);
! void   SPR_3MoveCluster   (SprCluster *cluster, Uint16 moveKind,
! 					   MthXyz *angle, MthXyz *point);
! void   SPR_3DrawModel     (SprCluster *rootCluster);
! void   SPR_3Flush         (void);
! void   SPR_3SetTexture    (SprTexture *texture);
! void   SPR_3ChangeTexColor(Uint16 charNo, Uint16 color,
!                                           SprLookupTbl *lookupTbl);
! void   SPR_3ClrTexture    (SprTexture *texture);
! void   SPR_3SetZSortMinMax(Uint16 pZSortMode,
!                                        Fixed32 pZSortZMin, Fixed32 pZSortZMax);
! void   SPR_3SetClipLevel  (Uint16 pClipLevel,
! 				       Fixed32 pClipZMin, Fixed32 pClipZMax);
! void   SPR_3SetPixelCount (Uint16 pixelCountX, Uint16 pixelCountY);
! void   SPR_3GetStatus (Spr3dStatus *spr3dStatus);
! void   SPR_3CallAllCluster(SprCluster *cluster, void (*userFunc)(SprCluster*));
! void   SPR_3SetSurfNormVect(SprObject3D  *obj);
! void   SPR_3SetDrawSpeed(Sint32 hssFlag, Sint32 eosFlag, Sint32 pclpFlag);
! void   SPR_3AllCoordTransClipPers(MthMatrix *matrix,
!                        MthXyz *src, MthXyz *ans, XyInt *ans2D, int vertCnt,
!                        Sint32 *unitPixel, Fixed32 *clipRatio, Fixed32 *clipZ);
! void   SPR_3AllCoordTrans(MthMatrix *matrix, MthXyz *src, int vertCnt,
!                           MthXyz *ans);
! void   SPR_3AllSurfaceBright(MthMatrix *matrix, SprSurface *surfInfo,
!                           MthXyz *surfaceNormal, Sint32 *surfaceBright,
!                      MthXyz *lightVector, Sint32 surfCnt, MthXyz *coordView3D);
! void   SPR_3AllVertBright(MthMatrix *matrix, MthXyz *vertNormal,
!                       Sint32 *vertBright, MthXyz *lightVector, Sint32 vertCnt);
! 
! 
! /*
!  * ＤＳＰによるマトリックス合成
!  */
! #define MTX_OP_CLEAR	1            /*　出力マトリックスエリアのクリア      */
! #define MTX_OP_REV_Z	2            /*　Ｚの符号反転合成                    */
! #define MTX_OP_MOV_XYZ	3            /*　平行移動合成                        */
! #define MTX_OP_ROT_X	4            /*　Ｘ回転移動合成                      */
! #define MTX_OP_ROT_Y	5            /*　Ｙ回転移動合成                      */
! #define MTX_OP_ROT_Z	6            /*　Ｚ回転移動合成                      */
! #define MTX_OP_END	7            /*　処理終了                            */
! 
! typedef struct  SprDspMatrixOp {     /* マトリックス合成オペレーション       */
!          Fixed32     x;              /* Ｘ値                                 */
!          Fixed32     y;              /* Ｙ値                                 */
!          Fixed32     z;              /* Ｚ値                                 */
!          Sint32      opCode;         /* オペレーションコード                 */
! } SprDspMatrixOp;
! 
! typedef struct  SprDspMatrixParm {   /* ＤＳＰ用マトリックス合成パラメータ   */
!          MthMatrix   *inputMatrix;   /* 入力マトリックスのアドレス           */
!          MthMatrix   *outputMatrix;  /* 出力マトリックスのアドレス           */
!          SprDspMatrixOp  op[15];     /* マトリックス合成オペレーション       */
! } SprDspMatrixParm;
! 
! void    SPR_3MatrixCompoInit(void);
! void    SPR_3MatrixCompoExec(SprDspMatrixParm *dspMatrixParm);
! void    SPR_3MatrixCompoCheck(void);
! 
! 
! #endif /* _SPR3_ */
! 
! 
! #endif /* ifndef SEGA_SPR_H */
! #define SLAVE
! /*  end of file */
! 
\ No newline at end of file
--- 1,642 ----
! /*----------------------------------------------------------------------------
!  *  sega_spr.h -- SPR ライブラリ インクルードファイル
!  *  Copyright(c) 1994 SEGA
!  *  Written by H.E on 1994-07-25 Ver.1.00
!  *  Updated by H.E on 1994-07-25 Ver.1.00
!  *
!  *  スプライト表示用インクルードファイルで使用スプライト表示ライブラリの種別に
!  *  より以下のように定義します。
!  *
!  *  （１）スプライト表示基本処理のみの場合
!  *
!  *        #include "sega_spr.h"
!  *
!  *  （２）スプライト表示拡張処理の場合
!  *
!  *        #define  _SPR2_
!  *        #include "sega_spr.h"
!  *
!  *  （３）スプライト３Ｄ表示処理の場合
!  *
!  *        #define  _SPR3_
!  *        #include "sega_spr.h"
!  *
!  *
!  *----------------------------------------------------------------------------
!  */
! 
! #ifndef SEGA_SPR_H
! #define SEGA_SPR_H
! 
! #include        "sega_xpt.h"
! #include        "sega_def.h"
! #include        "sega_mth.h"
! 
! /*-----------------------------------
!  * Select 3D Execute Machine
!  *---------------------------------*/
! #define  _PC_         0
! #define  _INDIGO2_    1
! #define  _SH_         2
! 
! 
! /*
!  * Set Machine Environment
!  */
! #define NO_EXIST    0
! #define    EXIST    1
! 
! #if defined(_PC)
!    #define _MACHINE  _PC_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_INDIGO2)
!    #define _MACHINE  _INDIGO2_
!    #define _DSP      NO_EXIST
!    #define _MATH        EXIST
! #endif
! 
! #if defined(_SH)
!    #define _MACHINE  _SH_
!    #define _DSP         EXIST
!    #define _MATH     NO_EXIST
! #endif
! 
! #ifdef _SPR3_
!    #define _SPR2_
! #endif
! 
! 
! /**************** SEGA_SP1.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! 
! #define  VRAM_SIZE           512*1024   /* 512 Kbyte                        */
! #define  FBUF_SIZE           256*1024   /* 256 Kbyte * 2 bank               */
! 
! #define  AUTO_FRAME_CHG           0     /* auto frame change mode           */
! #define  MANUAL_FRAME_CHG         1     /* manual frame change mode         */
! #define  NO_INTER_FRAME_CHG       2     /* no interval frame change mode    */
! #define  NO_INTER_VBE_FRAME_CHG   3     /* v-blank erase no interval frm chg*/
! 
! #define  SPR_FBCR_MANUAL     0x0003     /* frame buffer manual change       */
! #define  SPR_FBCR_AUTO       0x0000     /* frame buffer auto change         */
! #define  SPR_FBCR_ERASE      0x0002     /* frame buffer next erase on       */
! #define  SPR_FBCR_DIE        0x0008     /* double interlace on              */
! #define  SPR_FBCR_DIL        0x0004     /* double interlace plot line       */
! #define  SPR_FBCR_EOS        0x0010     /* even/odd data sampling select bit*/
! 
! #define  SPR_TV_NORMAL       0          /* Normal TV mode                   */
! #define  SPR_TV_HIRESO       1          /* High Resolution TV mode          */
! #define  SPR_TV_ROT16        2          /* Rotate 16 bit TV mode            */
! #define  SPR_TV_ROT8         3          /* Rotate 8 bit TV mode             */
! #define  SPR_TV_HDTV         4          /* HDTV TV mode                     */
! 
! #define  SPR_TV_320X224      0          /* Screen size 320 x 224            */
! #define  SPR_TV_320X240      1          /* Screen size 320 x 240            */
! #define  SPR_TV_352X224      2          /* Screen size 352 x 224            */
! #define  SPR_TV_352X240      3          /* Screen size 352 x 240            */
! #define  SPR_TV_640X224      4          /* Screen size 640 x 224            */
! #define  SPR_TV_640X240      5          /* Screen size 640 x 240            */
! #define  SPR_TV_704X224      6          /* Screen size 704 x 224            */
! #define  SPR_TV_704X240      7          /* Screen size 704 x 240            */
! 
! #define  SPR_W_TVMR          0x00000000 /* TV mode selection                */
! #define  SPR_W_FBCR          0x00000002 /* Frame buf change mode            */
! #define  SPR_W_PTMR          0x00000004 /* Draw start control               */
! #define  SPR_W_EWDR          0x00000006 /* Erase write data                 */
! #define  SPR_W_EWLR          0x00000008 /* Erase write area left top point  */
! #define  SPR_W_EWRR          0x0000000A /* Erase write area right bot point */
! #define  SPR_W_ENDR          0x0000000C /* Stop VDP1                        */
! #define  SPR_R_EDSR          0x00000010 /* Transfer complete status         */
! #define  SPR_R_LOPR          0x00000012 /* End command table address        */
! #define  SPR_R_COPR          0x00000014 /* Executing command table address  */
! #define  SPR_R_MODR          0x00000016 /* Write register Mode status       */
! 
! #define  SPR_R_EXTEN         0x00000002 /* VDP2 External Signal Enable Reg  */
! #define  SPR_R_TVSTAT        0x00000004 /* VDP2 TV Status Reg               */
! #define  SPR_R_VCNT          0x0000000A /* VDP2 V Counter Reg               */
! 
! #define  VRAM_ADDR           0x25C00000 /* Sprite IC VRAM area address      */
! #define  FBUF_ADDR           0x25C80000 /* Sprite frame buffer address      */
! #define  VDP1_REG_BASE       0x25D00000 /* Sprite IC Register base address  */
! #define  VDP2_REG_BASE       0x25F80000 /* Sprite IC Register base address  */
! 
! struct SprSpStatus {
!     Uint16  frameChgMode;             /* Frame Change Mode                 */
!     Uint16  frameEraseMode;           /* Frame Erase  Mode                 */
!     Uint16  vbInterval;               /* V-Blank Interval for Frame Change */
!     Uint16  eraseData;
!     Uint16  eraseLeftX;
!     Uint16  eraseTopY;
!     Uint16  eraseRightX;
!     Uint16  eraseBotY;
! };
! 
! typedef struct SprSpStatus SprSpStatus;
! 
! #define SPR_WRITE_REG(reg, val) \
!       *(Uint16*)(VDP1_REG_BASE+(reg)) = (val)
! #define SPR_READ_REG(reg) \
!       (*(volatile Uint16*)(VDP1_REG_BASE+(reg)))
! #define SPR_SCLWRITE_REG(reg, val) \
!       *(Uint16*)(VDP2_REG_BASE+(reg)) = (val)
! #define SPR_SCLREAD_REG(reg) \
!       (*(volatile Uint16*)(VDP2_REG_BASE+(reg)))
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! extern Sint32  SpScreenX;               /* TV Screen X Size                  */
! extern Sint32  SpScreenY;               /* TV Screen Y Size                  */
! extern volatile Uint16  SpFrameChgMode;          /* Frame Change Mode                 */
! extern volatile Sint32  SpFrameEraseMode;        /* Frame Erase  Mode                 */
! extern volatile Sint32  VBInterval;              /* V-Blank Interval for Frame Change */
! extern volatile Sint32  VBIntervalCounter;       /* V-Blank Interval Counter          */
! extern volatile Sint32  ReqDisplayFlag;          /* Display Request flag              */
! extern Uint16  SpTvMode;                /* TV Mode                           */
! extern Uint16  SpFbcrMode;              /* Frame Buffer Chane Mode           */
! extern Uint16  SpDie;                   /* Double Interlace Enable Flag      */
! extern Uint16  SpDil;                   /* Double Interlace Plot Line        */
! 
! /*
!  * EXTERNAL FUNCTION PROTOTYPE DECLARATIONS
!  */
! void SPR_Initial (Uint8 **VRAM);
! void SPR_SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void SPR_GetStatus (SprSpStatus *spStatus);
! void SPR_SetEraseData (Uint16 eraseData, Uint16 leftX,  Uint16 topY,
!                                          Uint16 rightX, Uint16 botY);
! void SPR_WaitDrawEnd (void);
! void SPR_SetEosMode(Sint32 eosFlag);
! 
! 
! #ifdef _SPR2_
! /**************** SEGA_SP2.H *************************************************/
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define  CTRL_END            0x8000     /* control word end bit mask        */
! #define  CTRL_SKIP           0x4000     /* control word skip bit mask       */
! #define  CTRL_JUMP           0x3000     /* control word jump bit mask       */
! #define  CTRL_ZOOM           0x0f00     /* control word zoom point bit mask */
! #define  CTRL_FUNC           0x000f     /* control word function bit mask   */
! #define  CTRL_DIR            0x0030     /* control word char read bit mask  */
! 
! #define  DRAW_COMPO          0x0003     /* draw mode word color compose mask*/
! #define  DRAW_GOURAU         0x0004     /* draw mode word gouraud shading   */
! #define  DRAW_GOURAU_GRAY    0x0804     /* draw mode word gray gour shading */
! #define  DRAW_COLOR          0x0038     /* draw mode word color mode mask   */
! #define  DRAW_MESH           0x0100     /* draw mode word mesh on           */
! 
! #define  COMPO_REP           0x0000     /* color compose reprace mode       */
! #define  COMPO_SHADOW        0x0001     /* color compose shadow mode        */
! #define  COMPO_HARF          0x0002     /* color compose harf luminance mode*/
! #define  COMPO_TRANS         0x0003     /* color compose trunslucent mode   */
! 
! #define  FUNC_NORMALSP       0x0000     /* draw normal sprite function      */
! #define  FUNC_SCALESP        0x0001     /* draw scaled sprite function      */
! #define  FUNC_DISTORSP       0x0002     /* draw distorted sprite function   */
! #define  FUNC_POLYGON        0x0004     /* draw polygon function            */
! #define  FUNC_POLYLINE       0x0005     /* draw polyline function           */
! #define  FUNC_LINE           0x0006     /* draw line function               */
! #define  FUNC_SCLIP          0x0009     /* set system clipping function     */
! #define  FUNC_UCLIP          0x0008     /* set user clipping function       */
! #define  FUNC_LCOORD         0x000a     /* set local coordinate function    */
! #define  FUNC_TEXTURE        0x0004     /* texture command group mask       */
! 
! #define  JUMP_NEXT           0x0000     /* jump next command                */
! #define  JUMP_ASSIGN         0x1000     /* jump assign command              */
! #define  JUMP_CALL           0x2000     /* call assign command              */
! #define  JUMP_RETURN         0x3000     /* return command subroutine        */
! 
! #define  ZOOM_NOPOINT        0x0000     /* zoom no point                    */
! #define  ZOOM_TL             0x0500     /* zoom point top left              */
! #define  ZOOM_TM             0x0600     /* zoom point top middle            */
! #define  ZOOM_TR             0x0700     /* zoom point top right             */
! #define  ZOOM_ML             0x0900     /* zoom point middle left           */
! #define  ZOOM_MM             0x0a00     /* zoom point center                */
! #define  ZOOM_MR             0x0b00     /* zoom point middle right          */
! #define  ZOOM_BL             0x0c00     /* zoom point bottom left           */
! #define  ZOOM_BM             0x0e00     /* zoom point bottom middle         */
! #define  ZOOM_BR             0x0f00     /* zoom point bottom right          */
! 
! #define  DIR_NOREV           0x0000     /* char read not reverse            */
! #define  DIR_TBREV           0x0020     /* char read top/bottom reverse     */
! #define  DIR_LRREV           0x0010     /* char read left/right reverse     */
! #define  DIR_LRTBREV         0x0030     /* char read left/right/top/bot rev */
! 
! #define  ECD_DISABLE         0x0080     /* ECD disabe & SPD enable          */
! #define  SPD_DISABLE         0x0040     /* ECD enable & SPD disable         */
! #define  ECDSPD_DISABLE      0x00c0     /* ECD & SPD disable                */
! #define  UCLPIN_ENABLE       0x0400     /* CLIP IN enable                   */
! #define  UCLPOUT_ENABLE      0x0600     /* CLIP OUT enable                  */
! #define  HSS_ENABLE          0x1000     /* HSS enable                       */
! #define  PCLP_ENABLE         0x0800     /* PCLP disable                     */
! 
! #define  COLOR_0             0x0000     /* 4 bit/pixel & 16 color bank mode */
! #define  COLOR_1             0x0008     /* 4 bit/pixel & 16 color lookup tbl*/
! #define  COLOR_2             0x0010     /* 8 bit/pixel &  64 color bank mode*/
! #define  COLOR_3             0x0018     /* 8 bit/pixel & 128 color bank mode*/
! #define  COLOR_4             0x0020     /* 8 bit/pixel & 256 color bank mode*/
! #define  COLOR_5             0x0028     /* 16 bit/pixel & RGB mode          */
! 
! #define  NO_GOUR             0xffff     /* no use Gouraud Shading Table No. */
! 
! #define  SPR_2DRAW_PRTY_ON   1          /* command draw priority on         */
! #define  SPR_2DRAW_PRTY_OFF  0          /* command draw priority off        */
! #define  SPR_2MOST_FAR       0          /* draw sprite most far position    */
! #define  SPR_2MOST_NEAR      0x7fffffff /* draw sprite most near position   */
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprSpCmd {                       /* Sprite Command Table             */
!     Uint16  control;                    /* control word                     */
!     Uint16  link;                       /* command link                     */
!     Uint16  drawMode;                   /* draw mode                        */
!     Uint16  color;                      /* color info.                      */
!     Uint16  charAddr;                   /* character address                */
!     Uint16  charSize;                   /* character size                   */
!     Sint16  ax;                         /* point A x                        */
!     Sint16  ay;                         /* point A y                        */
!     Sint16  bx;                         /* point B x                        */
!     Sint16  by;                         /* point B y                        */
!     Sint16  cx;                         /* point C x                        */
!     Sint16  cy;                         /* point C y                        */
!     Sint16  dx;                         /* point D x                        */
!     Sint16  dy;                         /* point D y                        */
!     Uint16  grshAddr;                   /* gouraud shading table address    */
!     Uint16  dummy;                      /* dummy area                       */
! };
! 
! struct SprGourTbl {
!     Uint16  entry[4];
! };
! 
! struct SprLookupTbl {
!     Uint16  entry[16];
! };
! 
! /*
!  * TYPEDEFS
!  */
! typedef Uint16 Vaddr;                       /* Relative Address in The VRAM  */
! typedef struct SprSpCmd     SprSpCmd;
! typedef struct SprGourTbl   SprGourTbl;
! typedef struct SprLookupTbl SprLookupTbl;
! /* internal data type */
! typedef	struct SprCharTbl     SprCharTbl;
! typedef	struct SprCmdChain    SprCmdChain;
! typedef struct SprDrawPrtyBlk SprDrawPrtyBlk;
! typedef	struct Spr2WorkArea   Spr2WorkArea;
! typedef	struct SprAreaSize    SprAreaSize;
! 
! struct SprCharTbl {                         /* Character Entry Table         */
!     Vaddr     addr;                         /* Character Relative Address    */
!     Uint16    xySize;                       /* Charcter Size (X * Y)         */
!     Uint16    mode;                         /* Charcter Mode (0-5)           */
!     Uint16    color;                        /* Color Bank or LookUp Tbl No   */
!     Uint16    size;                         /* Charcter Size (by the 32 byte)*/
! };
! 
! struct SprCmdChain {            /* コマンドチェイン管理テーブル              */
!     Uint16      nextNo;         /* 次のコマンドチェインエントリ番号          */
!     Uint16      cmdNo;          /* 対応するコマンド番号                      */
! };
! 
! struct SprDrawPrtyBlk {         /* 描画プライオリティブロックテーブル        */
!     Uint16      topNo;          /* 先頭コマンドチェインエントリ番号          */
!     Uint16      botNo;          /* 末尾コマンドチェインエントリ番号          */
! };
! 
! struct Spr2WorkArea {                    /* SP2 Work Area Define             */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     SprCharTbl     *charTbl;             /* Character Tbl Pointer            */
!     SprCmdChain    *cmdChain;            /* Command Draw Priority Chain Tbl  */
!     SprDrawPrtyBlk *drawPrtyBlk;         /* Draw Priority Block Start        */
! };
! 
! struct SprAreaSize {                     /* SP2 Work Area Size               */
!     Uint16         commandMax;           /* Command Max                      */
!     Uint16         gourTblMax;           /* Gour Tbl Max                     */
!     Uint16         lookupTblMax;         /* Lookup Tbl Max                   */
!     Uint16         charMax;              /* Char Max                         */
!     Uint16         drawPrtyBlkMax;       /* Draw Priority Block Max          */
!     Uint16         useCommandCount;      /* Using Command Block Count        */
!     Uint16         charRemainBlkCount;   /* Char Total Remain Null Blk Count */
!     Uint16         charNullBlkMaxSize;   /* Char Null Block Max Size         */
! };
! 
! /*
!  * EXTERNAL VARIABLE DECLARATIONS
!  */
! extern Sint32  SpLCoordX;                   /* Local Origin X Position       */
! extern Sint32  SpLCoordY;                   /* Local Origin Y Position       */
! 
! 
! #define   SPR_2DefineWork(sp2WorkArea, sp2CommandMax, sp2GourTblMax, \
! 		          sp2LookupTblMax, sp2CharMax, sp2DrawPrtyBlkMax) \
! static SprCharTbl      sp2CharTbl      [sp2CharMax]; \
! static SprCmdChain     sp2CmdChain     [sp2CommandMax]; \
! static SprDrawPrtyBlk  sp2DrawPrtyBlk  [sp2DrawPrtyBlkMax]; \
! static Spr2WorkArea sp2WorkArea  = {  \
!         sp2CommandMax, sp2GourTblMax, sp2LookupTblMax, sp2CharMax, \
!         sp2DrawPrtyBlkMax, sp2CharTbl, sp2CmdChain, sp2DrawPrtyBlk };
! 
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_2Initial (Spr2WorkArea  *workArea);
! void   SPR_2SetTvMode(Uint16 mode, Uint16 screenSize, Uint16 doubleInterlace);
! void   SPR_2FrameChgIntr (Uint16);
! void   SPR_2FrameEraseData (Uint16);
! void   SPR_2SetGourTbl (Uint16, SprGourTbl *);
! void   SPR_2SetLookupTbl (Uint16, SprLookupTbl *);
! void   SPR_2SetChar (Uint16, Uint16, Uint16, Uint16, Uint16, Uint8 *);
! void   SPR_2ClrChar (Uint16);
! void   SPR_2ClrAllChar (void);
! Uint16 SPR_2GourTblNoToVram (Uint16);
! Uint16 SPR_2LookupTblNoToVram (Uint16);
! Uint16 SPR_2CharNoToVram (Uint16);
! void   SPR_2GetAreaSizeInfo(SprAreaSize  *areaSizeInfo);
! void   SPR_2OpenCommand (Uint16);
! void   SPR_2CloseCommand (void);
! void   SPR_2FlushDrawPrty (void);
! void   SPR_2LocalCoord (Sint32, XyInt *);
! void   SPR_2SysClip (Sint32, XyInt *);
! void   SPR_2UserClip (Sint32, XyInt *);
! void   SPR_2Line (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2PolyLine (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2Polygon (Sint32, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2NormSpr (Sint32, Uint16, Uint16, Uint16, Uint16, XyInt *, Uint16);
! void   SPR_2ScaleSpr (Sint32, Uint16, Uint16, Uint16, 
!                                       Uint16, XyInt *xy, Uint16);
! void   SPR_2DistSpr (Sint32, Uint16, Uint16, Uint16,
!                                      Uint16, XyInt *xy, Uint16);
! void   SPR_2Cmd (Sint32, SprSpCmd *);
! 
! #endif /* _SPR2_ */
! 
! #ifdef _SPR3_
! /**************** SEGA_SP3.H *************************************************/
! /*
!  * TYPEDEFS
!  */
! typedef	struct SprCluster   SprCluster;
! typedef	struct SprObject3D  SprObject3D;
! typedef	struct SprSurface   SprSurface;
! typedef	struct SprInbetInf  SprInbetInf;
! typedef	struct SprTexture   SprTexture;
! typedef struct Spr3dStatus  Spr3dStatus;
! /* internal data type */
! typedef	struct Spr3WorkArea Spr3WorkArea;
! 
! 
! /*
!  * STRUCTURE DECLARATIONS
!  */
! struct SprCluster {
!     Uint16	no;             /* クラスタ番号                              */
!     Uint16	angleSeq;       /* 回転順序                                  */
!     MthXyz	angle;	        /* 親クラスタの座標系における回転            */
!     MthXyz	point;	        /* 親クラスタの座標系における原点の座標      */
!     SprObject3D	*object;        /* ３Ｄオブジェクト                          */
!     SprCluster	*next;       	/* 次クラスタ                                */
!     SprCluster	*child;      	/* 子クラスタ                                */
!     SprInbetInf *inbetInf;     	/* ３Ｄオブジェクト間接続ポリゴン情報        */
!     void        (*transStart)(SprCluster*);
!                                 /* 座標変換開始前ユーザコールバックルーチン  */
!     void        (*transEnd)(SprCluster*, SprObject3D*, MthMatrix*, MthXyz*);
!                                 /* 座標変換終了後ユーザコールバックルーチン  */
!     void        *context;       /* ユーザコンテキストエリア                  */
! };
! 
! struct SprObject3D {
!     Uint16	no;             /* オブジェクト番号                          */
!     Uint16      dispFlag;       /* 表示フラグ                                */
!     Uint16      vertCount;      /* 頂点数                                    */
!     Uint16      surfaceCount;   /* 面数                                      */
!     MthXyz      *vertPoint;     /* 頂点座標テーブル                          */
!     MthXyz      *vertNormal;    /* 頂点の法線ベクトルテーブル                */
!     SprSurface  *surface;       /* 面定義テーブル                            */
!     MthXyz      *surfaceNormal; /* 面の法線ベクトルテーブル                  */
!     MthXyz      *surfaceVert;   /* 面の代表頂点座標テーブル                  */
!     Uint16      **shdIdxTbl;    /* シェーディングインデックステーブル        */
!     Fixed32     surfNormK;      /* 面法線ベクトルの計算補正値                */
!     SprObject3D *next;          /* 次３Ｄオブジェクト                        */
! };
! 
! struct SprSurface {
!     Uint16     vertNo[4];       /* 面を構成する頂点番号                      */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
! };
! 
! struct SprInbetInf {
!     Sint32       vertCount;     /* 取り出し頂点数                            */
!     SprObject3D  *fromObj;      /* 接続頂点データ取り出しオブジェクト        */
!     Uint16       *fromVertNo;   /* 取り出し頂点番号配列                      */
!     SprObject3D  *toObj;        /* 接続頂点データ設定オブジェクト            */
!     Uint16       *toVertNo;     /* 設定頂点番号配列                          */
!     SprInbetInf  *next;         /* 次３Ｄオブジェクト間接続ポリゴン情報      */
! };
! 
! struct SprTexture {
!     Uint16       charNo;        /* キャラクタ番号                            */
!     Uint16       colorMode;     /* カラーモード                              */
!     Uint16       color;         /* カラーデータ（ｶﾗｰﾊﾞﾝｸorﾙｯｸｱｯﾌﾟﾃｰﾌﾞﾙNo）   */
!     Uint16       width;         /* キャラクタの幅                            */
!     Uint16       height;        /* キャラクタの高さ                          */
!     Uint8        *charData;     /* キャラクタデータのポインタ                */
!     SprLookupTbl *lookupTbl;    /* ルックアップテーブルのポインタ            */
! };
! 
! struct Spr3WorkArea {
!     Uint16      objSurfMax;        /* オブジェクト内最大面数                 */
!     Uint16      objVertMax;        /* オブジェクト内最大頂点数               */
!     Sint32      *surfBright[2];    /* 面輝度テーブル                         */
!     Sint32      *vertBright[2];    /* 頂点輝度テーブル                       */
!     MthXyz      *coordView3D[2];   /* ３Ｄ視点座標変換後テーブル             */
!     MthXyz      *coordWorld3D[2];  /* ３Ｄワールド座標変換後テーブル         */
!     XyInt       *coord2D;          /* ２Ｄ透視変換後テーブル                 */
!     Uint8       *coord2DFlag;      /* ２Ｄ透視変換処理フラグテーブル         */
! };
! 
! struct Spr3dStatus {
!     MthXyz    lightAngle;       /* 光源アングル                           */
!     MthXyz    viewCoordPoint;   /* 視点座標系内の視点位置                 */
!     MthXyz    viewPoint;        /* 視点座標                               */
!     MthXyz    viewAngle;        /* 視点アングル                           */
!     Sint32    viewAngleSeq;     /* 視点アングル回転操作                   */
!     Sint32    zSortMode;        /* ＺソートＺ座標値の採用モード           */
!     Fixed32   zSortZMin;        /* フラッシュ単位現Ｚ座標最小値           */
!     Fixed32   zSortZMax;        /* フラッシュ単位現Ｚ座標最大値           */
!     Fixed32   clipZMin;         /* 視点座標系クリップＺ最小値座標         */
!     Fixed32   clipZMax;         /* 視点座標系クリップＺ最大値座標         */
!     Sint32    clipLevel;        /* クリッピングレベル                     */
!     MthXy     unitPixel;        /* X,Y 1.0 に対するスクリーンのピクセル数 */
! };
! 
! 
! 
! /*
!  * GLOBAL DEFINES/MACROS DEFINES
!  */
! #define   ROT_SEQ_ZYX       0x0000
! #define   ROT_SEQ_ZXY       0x0001
! #define   ROT_SEQ_YZX       0x0002
! #define   ROT_SEQ_YXZ       0x0003
! #define   ROT_SEQ_XYZ       0x0004
! #define   ROT_SEQ_XZY       0x0005
! 
! #define   DISP_POLYGON      0x0000
! #define   DISP_POLYLINE     0x8000
! #define   DISP_MASK         0xc000
! #define   BOTH_FACE         0x1000
! 
! #define   NO_SHADING        0x0000
! #define   FLAT_SHADING      0x0100
! #define   GOURAUD_SHADING   0x0200
! #define   SHADING_MASK      0x0300
! #define   INBETWEEN_OBJECT  0x0010
! 
! #define   MATE_COLOR        0x0000
! #define   MATE_TEXTURE      0x4000
! #define   MATE_SHADING_TBL  0x8000
! #define   MATE_AUTO_SHADING 0xc000
! #define   MATE_MASK         0xc000
! 
! #define   ZSORT_MIN         0x0000
! #define   ZSORT_MAX         0x1000
! #define   ZSORT_MID         0x2000
! #define   ZSORT_MASK        0x3000
! #define   ZSORT_FLOAT_MODE  0
! #define   ZSORT_FIXED_MODE  1
! 
! #define   DRAW_MODE_MASK    0x07ff
! 
! #ifdef SPR_3USE_DOUBLE_BUF
! #define   SPR_3mac1(sp3ObjSurfMax) \
! static Sint32    sp3SurfBright1 [sp3ObjSurfMax]; \
! static Sint32    sp3SurfBright2 [sp3ObjSurfMax];
! #else
! #define   SPR_3mac1(sp3ObjSurfMax) \
! static Sint32    sp3SurfBright1 [sp3ObjSurfMax];
! #endif
! 
! #ifdef SPR_3USE_DOUBLE_BUF
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D1 [sp3ObjVertMax];   \
! static Sint32    sp3VertBright2   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D2  [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D2 [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #else
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static Sint32    sp3VertBright2   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D2  [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #endif
! #else
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static MthXyz    sp3CoordWorld3D1 [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #else
! #define   SPR_3mac2(sp3ObjVertMax) \
! static Sint32    sp3VertBright1   [sp3ObjVertMax];   \
! static MthXyz    sp3CoordView3D1  [sp3ObjVertMax];   \
! static XyInt     sp3Coord2D       [sp3ObjVertMax];   \
! static Uint8     sp3Coord2DFlag   [sp3ObjVertMax];
!   #endif
! #endif
! 
! #ifdef SPR_3USE_DOUBLE_BUF
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)  \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1, sp3SurfBright2, sp3VertBright1, sp3VertBright2, \
!    sp3CoordView3D1, sp3CoordView3D2, sp3CoordWorld3D1, sp3CoordWorld3D2, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #else
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)  \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1, sp3SurfBright2, sp3VertBright1, sp3VertBright2, \
!    sp3CoordView3D1, sp3CoordView3D2,              NULL,            NULL, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #endif
! #else
!   #ifdef SPR_3NEED_WORLD_VERT
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1,           NULL, sp3VertBright1,           NULL, \
!    sp3CoordView3D1,          NULL, sp3CoordWorld3D1,         NULL, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #else
! #define   SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
! static Spr3WorkArea  sp3WorkArea = {                          \
!    sp3ObjSurfMax, sp3ObjVertMax, \
!    sp3SurfBright1,            NULL, sp3VertBright1,           NULL, \
!    sp3CoordView3D1,           NULL,             NULL,             NULL, \
!    sp3Coord2D, sp3Coord2DFlag };
!   #endif
! #endif
! 
! #define   SPR_3DefineWork(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax) \
!  SPR_3mac1(sp3ObjSurfMax) \
!  SPR_3mac2(sp3ObjVertMax) \
!  SPR_3mac3(sp3WorkArea, sp3ObjSurfMax, sp3ObjVertMax)
! 
! /*
!  * PROTOTYPE DECLARATIONS
!  */
! void   SPR_3Initial       (Spr3WorkArea  *workArea);
! void   SPR_3SetLight      (Uint16 moveKind, MthXyz *lightAngle);
! void   SPR_3SetView       (Uint16 moveKind, MthXyz *viewPoint,
!                            MthXyz *viewAngle, Uint16 angleSeq,
!                            MthXyz *viewCoordPoint);
! void   SPR_3MoveCluster   (SprCluster *cluster, Uint16 moveKind,
! 					   MthXyz *angle, MthXyz *point);
! void   SPR_3DrawModel     (SprCluster *rootCluster);
! void   SPR_3Flush         (void);
! void   SPR_3SetTexture    (SprTexture *texture);
! void   SPR_3ChangeTexColor(Uint16 charNo, Uint16 color,
!                                           SprLookupTbl *lookupTbl);
! void   SPR_3ClrTexture    (SprTexture *texture);
! void   SPR_3SetZSortMinMax(Uint16 pZSortMode,
!                                        Fixed32 pZSortZMin, Fixed32 pZSortZMax);
! void   SPR_3SetClipLevel  (Uint16 pClipLevel,
! 				       Fixed32 pClipZMin, Fixed32 pClipZMax);
! void   SPR_3SetPixelCount (Uint16 pixelCountX, Uint16 pixelCountY);
! void   SPR_3GetStatus (Spr3dStatus *spr3dStatus);
! void   SPR_3CallAllCluster(SprCluster *cluster, void (*userFunc)(SprCluster*));
! void   SPR_3SetSurfNormVect(SprObject3D  *obj);
! void   SPR_3SetDrawSpeed(Sint32 hssFlag, Sint32 eosFlag, Sint32 pclpFlag);
! #endif /* _SPR3_ */
! 
! #endif /* ifndef SEGA_SPR_H */
! 
! /*  end of file */
diff -crBN --binary sbl6/segalib/include/sega_stm.h sbl6_patch/segalib/include/sega_stm.h
*** sbl6/segalib/include/sega_stm.h	1996-02-08 05:23:50.000000000 -0500
--- sbl6_patch/segalib/include/sega_stm.h	2023-01-07 14:40:38.000000000 -0500
***************
*** 471,476 ****
--- 471,478 ----
  /* エラー状態の取得                     */
  void    STM_GetErrStat(StmErrStat *stat);
  
+ void    STMMNG_ResetLstStm(StmGrpHn grp);
+ 
  #endif  /* SEGA_STM_H   */
  
  /* end of sega_stm.h            */
diff -crBN --binary sbl6/segalib/include/sega_sys.h sbl6_patch/segalib/include/sega_sys.h
*** sbl6/segalib/include/sega_sys.h	1996-02-08 05:23:50.000000000 -0500
--- sbl6_patch/segalib/include/sega_sys.h	2022-03-07 20:57:50.000000000 -0500
***************
*** 41,49 ****
   *      void  test()
   *      {
   *           void (*tmp)();
!  *           Sint32 rep;
!  *           Uint32 msk, clk, lval1;
!  *           Uint8  p0;
   *           const Uint32 PriTab[32] = {
   *              0x00f0ffff, 0x00e0fffe, 0x00d0fffc, 0x00c0fff8,
   *              0x00b0fff0, 0x00a0ffe0, 0x0090ffc0, 0x0080ff80,
--- 41,49 ----
   *      void  test()
   *      {
   *           void (*tmp)();
!  *           Sint32	rep;
!  *           Uint32	msk, clk, lval1;
!  *           Uint8 	p0;
   *           const Uint32 PriTab[32] = {
   *              0x00f0ffff, 0x00e0fffe, 0x00d0fffc, 0x00c0fff8,
   *              0x00b0fff0, 0x00a0ffe0, 0x0090ffc0, 0x0080ff80,
***************
*** 94,158 ****
   *           // ... 実行文 ... //
   *      }
   *
   */
  
! #ifndef SEGA_SYS_H
  #define SEGA_SYS_H
  
- /***********************************************************************
-  *      インクルードファイル
-  ***********************************************************************/
  #include "sega_xpt.h"
  
- /*****************************************************************************
-  *      定数マクロ
-  *****************************************************************************/
- 
- /* バージョン */
-                     /*             1         2         3         4    */
-                     /*    1234567890123456789012345678901234567890    */
-                     /*    ++++++++++++++++++++++++++++++++            */
- #define SYS_VERSION_STR ("SYS Version 2.10 1996-01-31")
- #define SYS_VERSION_LEN         (32)
- 
- /***********************************************************************
-  *      処理マクロ
-  ***********************************************************************/
  #define SYS_SETUINT(_Num_, _Hdr_) \
!         ((**(volatile void(**)(Uint32, void*))0x6000300)((_Num_), (_Hdr_)))
  #define SYS_GETUINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000304)(_Num_))
  
  #define SYS_SETSINT(_Num_, _Hdr_) \
!         ((**(volatile void(**)(Uint32, void*))0x6000310)((_Num_), (_Hdr_)))
  #define SYS_GETSINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000314)(_Num_))
  
  #define SYS_TASSEM(_Num_) \
!         ((**(volatile Uint32(**)(Uint32))0x6000330)(_Num_))
  #define SYS_CLRSEM(_Num_) \
!         ((**(volatile void(**)(Uint32))0x6000334)(_Num_))
  
  #define SYS_SETSCUIM(_MaskPat_) \
!         ((**(volatile void(**)(Uint32))0x6000340)(_MaskPat_))
  #define SYS_CHGSCUIM(_AndMask_, _OrMask_) \
!         ((**(volatile void(**)(Uint32, Uint32))0x6000344)((_AndMask_), (_OrMask_)))
  #define SYS_GETSCUIM \
!         (*(volatile Uint32*)0x6000348)
  
  #define SYS_CHGSYSCK(_CkMode_) \
!         ((**(volatile void(**)(Uint32))0x6000320)(_CkMode_))
  #define SYS_GETSYSCK \
!         (*(volatile Uint32*)0x6000324)
  
  #define SYS_CHGUIPR(_IprTab_) \
!         ((**(volatile void(**)(Uint32*))0x6000280)(_IprTab_))
  
  #define SYS_EXECDMP \
!         (**(volatile void(**)(void))0x600026C)
  
  #define SYS_PCLRMEM \
!         (*(volatile Uint8*)0x6000210)
  
  #define SYS_CHKMPEG(_dummy_) \
          ((**(volatile Sint32(**)(Sint32))0x6000274)(_dummy_))
--- 94,147 ----
   *           // ... 実行文 ... //
   *      }
   *
+  *
+  * 日付:        1994/05/06  for BOOT 0.90,0.901,0.91  by T. S.
+  *              1994/07/16  for BOOT 0.92x,0.95       by T. S.
+  *              1994/07/29  for BOOT 0.96x,1.00       by T. S.
+  *              1994/08/31  how to exec CD multi-player
+  *              1994/09/21  for Ver.1.00 BOOT ROM
   */
  
! #ifndef	SEGA_SYS_H
  #define SEGA_SYS_H
  
  #include "sega_xpt.h"
  
  #define SYS_SETUINT(_Num_, _Hdr_) \
!         ((**(void(**)(Uint32, void*))0x6000300)((_Num_), (_Hdr_)))
  #define SYS_GETUINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000304)(_Num_))
  
  #define SYS_SETSINT(_Num_, _Hdr_) \
!         ((**(void(**)(Uint32, void*))0x6000310)((_Num_), (_Hdr_)))
  #define SYS_GETSINT(_Num_) \
          ((void*)(**(void(*(**)(Uint32))(Uint32))0x6000314)(_Num_))
  
  #define SYS_TASSEM(_Num_) \
!         ((**(Uint32(**)(Uint32))0x6000330)(_Num_))
  #define SYS_CLRSEM(_Num_) \
!         ((**(void(**)(Uint32))0x6000334)(_Num_))
  
  #define SYS_SETSCUIM(_MaskPat_) \
!         ((**(void(**)(Uint32))0x6000340)(_MaskPat_))
  #define SYS_CHGSCUIM(_AndMask_, _OrMask_) \
!         ((**(void(**)(Uint32, Uint32))0x6000344)((_AndMask_), (_OrMask_)))
  #define SYS_GETSCUIM \
!         (*(Uint32*)0x6000348)
  
  #define SYS_CHGSYSCK(_CkMode_) \
!         ((**(void(**)(Uint32))0x6000320)(_CkMode_))
  #define SYS_GETSYSCK \
!         (*(Uint32*)0x6000324)
  
  #define SYS_CHGUIPR(_IprTab_) \
!         ((**(void(**)(Uint32*))0x6000280)(_IprTab_))
  
  #define SYS_EXECDMP \
!         (**(void(**)(void))0x600026C)
  
  #define SYS_PCLRMEM \
!         (*(Uint8*)0x6000210)
  
  #define SYS_CHKMPEG(_dummy_) \
          ((**(volatile Sint32(**)(Sint32))0x6000274)(_dummy_))
***************
*** 164,167 ****
  void SYS_Exit(Sint32 code);
  
  #endif
- 
\ No newline at end of file
--- 153,155 ----
diff -crBN --binary sbl6/segalib/include/sl_def.h sbl6_patch/segalib/include/sl_def.h
*** sbl6/segalib/include/sl_def.h	1996-02-08 05:23:52.000000000 -0500
--- sbl6_patch/segalib/include/sl_def.h	2024-08-26 16:37:14.000000000 -0400
***************
*** 1,29 ****
  /*							*/
  /*  SEGA Library defines	*/
  /*							*/
! 
  #ifndef SEGA_XPT_H
  #define SEGA_XPT_H
! 
  /*****************************************************************************/
! /****************************** 基本データ型宣言 *****************************/
  /*****************************************************************************/
  
! typedef unsigned    char    Uint8;      /* 符号なし１バイト整数 */
! typedef signed      char    Sint8;      /* 符号つき１バイト整数 */
! typedef unsigned    short   Uint16;     /* 符号なし２バイト整数 */
! typedef signed      short   Sint16;     /* 符号つき２バイト整数 */
! typedef unsigned    long    Uint32;     /* 符号なし４バイト整数 */
! typedef signed      long    Sint32;     /* 符号つき４バイト整数 */
! typedef float               Float32;    /* ４バイト実数 */
! typedef double              Float64;    /* ８バイト実数 */
  
! typedef int                 Int;        /* INT型（ツール用）            */
  
! typedef int                 Bool;       /* 論理型（論理定数を値にとる） */
  
  /*****************************************************************************/
! /********************************* 定数マクロ ********************************/
  /*****************************************************************************/
  
  #ifndef NULL
--- 1,44 ----
  /*							*/
  /*  SEGA Library defines	*/
  /*							*/
! 
  #ifndef SEGA_XPT_H
  #define SEGA_XPT_H
! 
! #if 0
! #  define ST_V				/* or ST_VE (for Enhanced ST-V) */
! #  define TITAN
! #endif
! 
! #define		shc		1
! #define		sh_gcc		2
! #define		Compiler	sh_gcc		/* fot Hitachi then "shc" */
! 
! #if Compiler == shc
! #  define  STCNS  static const
! #else
! #  define  STCNS  static
! #endif
! 
  /*****************************************************************************/
! /****************************** ｿｽｿｽｿｽ{ｿｽfｿｽ[ｿｽ^ｿｽ^ｿｽ骭ｾ *****************************/
  /*****************************************************************************/
  
! typedef unsigned    char    Uint8;      /* ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽPｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef signed      char    Sint8;      /* ｿｽｿｽｿｽｿｽｿｽﾂゑｿｽｿｽPｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef unsigned    short   Uint16;     /* ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽQｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef signed      short   Sint16;     /* ｿｽｿｽｿｽｿｽｿｽﾂゑｿｽｿｽQｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef unsigned    long    Uint32;     /* ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽSｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef signed      long    Sint32;     /* ｿｽｿｽｿｽｿｽｿｽﾂゑｿｽｿｽSｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef float               Float32;    /* ｿｽSｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
! typedef double              Float64;    /* ｿｽWｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
  
! typedef int                 Int;        /* INTｿｽ^ｿｽiｿｽcｿｽ[ｿｽｿｽｿｽpｿｽj            */
  
! typedef int                 Bool;       /* ｿｽ_ｿｽｿｽｿｽ^ｿｽiｿｽ_ｿｽｿｽｿｽ關費ｿｽｿｽｿｽlｿｽﾉとゑｿｽｿｽj */
  
  /*****************************************************************************/
! /********************************* ｿｽ關費ｿｽ}ｿｽNｿｽｿｽ ********************************/
  /*****************************************************************************/
  
  #ifndef NULL
***************
*** 31,81 ****
  #endif  /* NULL */
  
  /*****************************************************************************/
! /********************************** 列挙定数 *********************************/
  /*****************************************************************************/
  
! enum BooleanLogic {                     /* 論理定数１（偽、真） */
      FALSE = 0,
      TRUE  = 1
  };
  
! enum BooleanSwitch {                    /* 論理定数２（スイッチ） */
      OFF = 0,
      ON  = 1
  };
  
! enum Judgement {                        /* 結果判定の定数（成功、失敗） */
!     OK = 0,                             /* 成功 */
!     NG = -1                             /* 失敗 */
  };
  
  /*****************************************************************************/
! /********************************* 処理マクロ ********************************/
  /*****************************************************************************/
  
! #define MAX(x, y)       ((x) > (y) ? (x) : (y)) /* 最大値 */
! #define MIN(x, y)       ((x) < (y) ? (x) : (y)) /* 最小値 */
! #define ABS(x)          ((x) < 0 ? -(x) : (x))  /* 絶対値 */
  
  /*---------------------------------------------------------------------------*/
! #endif  /* SEGA_XPT_H */
! 
! 
  #ifndef SL_DEF_H
  #define SL_DEF_H
  
! #define	    DI		15		/* 割り込みの禁止 */
! #define	    EI		 0		/* 割り込みの許可 */
  
! #define	    MAX_EVENT	64		/* 使用できるイベントの数 */
! #define	    MAX_WORK	256		/* 使用できるワークの数 */
! #define	    MAX_NEST	20		/* マトリクスのネストできる数 */
  
! #define	    WORK_SIZE	0x40		/* ワークの大きさ */
! #define	    EVENT_SIZE	0x80		/* イベントの大きさ */
  
! typedef	    Sint16	ANGLE ;		/* 一周３６０度を １６ビットで表す  */
! typedef	    Sint32	FIXED ;		/* 上位１６ビットで整数部、下位１６ビットで小数部を表す固定小数点型 */
  
  enum ps {X , Y , Z , XYZ , XYZS , XY = Z , S = XYZ} ;
  
--- 46,96 ----
  #endif  /* NULL */
  
  /*****************************************************************************/
! /********************************** ｿｽ挙定数 *********************************/
  /*****************************************************************************/
  
! enum BooleanLogic {                     /* ｿｽ_ｿｽｿｽｿｽ關費ｿｽPｿｽiｿｽUｿｽAｿｽ^ｿｽj */
      FALSE = 0,
      TRUE  = 1
  };
  
! enum BooleanSwitch {                    /* ｿｽ_ｿｽｿｽｿｽ關費ｿｽQｿｽiｿｽXｿｽCｿｽbｿｽ`ｿｽj */
      OFF = 0,
      ON  = 1
  };
  
! enum Judgement {                        /* ｿｽｿｽｿｽﾊ費ｿｽｿｽｿｽｿｽﾌ定数ｿｽiｿｽｿｽｿｽｿｽｿｽAｿｽｿｽｿｽsｿｽj */
!     OK = 0,                             /* ｿｽｿｽｿｽｿｽ */
!     NG = -1                             /* ｿｽｿｽｿｽs */
  };
  
  /*****************************************************************************/
! /********************************* ｿｽｿｽｿｽｿｽｿｽ}ｿｽNｿｽｿｽ ********************************/
  /*****************************************************************************/
  
! #define MAX(x, y)       ((x) > (y) ? (x) : (y)) /* ｿｽﾅ托ｿｽｿｽl */
! #define MIN(x, y)       ((x) < (y) ? (x) : (y)) /* ｿｽﾅ擾ｿｽｿｽl */
! #define ABS(x)          ((x) < 0 ? -(x) : (x))  /* ｿｽｿｽｿｽﾎ値 */
  
  /*---------------------------------------------------------------------------*/
! #endif  /* SEGA_XPT_H */
! 
! 
  #ifndef SL_DEF_H
  #define SL_DEF_H
  
! #define	    DI		15		/* ｿｽｿｽｿｽ闕橸ｿｽﾝの禁止 */
! #define	    EI		 0		/* ｿｽｿｽｿｽ闕橸ｿｽﾝの具ｿｽｿｽｿｽ */
  
! #define	    MAX_EVENT	64		/* ｿｽgｿｽpｿｽﾅゑｿｽｿｽｿｽｿｽCｿｽxｿｽｿｽｿｽgｿｽﾌ撰ｿｽ */
! #define	    MAX_WORK	256		/* ｿｽgｿｽpｿｽﾅゑｿｽｿｽ驛擾ｿｽ[ｿｽNｿｽﾌ撰ｿｽ */
! #define	    MAX_NEST	20		/* ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽﾌネｿｽXｿｽgｿｽﾅゑｿｽｿｽ髏 */
  
! #define	    WORK_SIZE	0x40		/* ｿｽｿｽｿｽ[ｿｽNｿｽﾌ大きｿｽｿｽ */
! #define	    EVENT_SIZE	0x80		/* ｿｽCｿｽxｿｽｿｽｿｽgｿｽﾌ大きｿｽｿｽ */
  
! typedef	    Sint16	ANGLE ;		/* ｿｽｿｽｿｽｿｽｿｽRｿｽUｿｽOｿｽxｿｽｿｽ ｿｽPｿｽUｿｽrｿｽbｿｽgｿｽﾅ表ｿｽｿｽ  */
! typedef	    Sint32	FIXED ;		/* ｿｽｿｽｿｽﾊ１ｿｽUｿｽrｿｽbｿｽgｿｽﾅ撰ｿｽｿｽｿｽｿｽｿｽｿｽAｿｽｿｽｿｽﾊ１ｿｽUｿｽrｿｽbｿｽgｿｽﾅ擾ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ\ｿｽｿｽｿｽﾅ定小ｿｽｿｽｿｽ_ｿｽ^ */
  
  enum ps {X , Y , Z , XYZ , XYZS , XY = Z , S = XYZ} ;
  
***************
*** 93,105 ****
  				    + sizeof(void (*)()))] ;
  } EVENT ;
  
! typedef     FIXED	MATRIX[4][3] ;		/* マトリクスデータ */
! typedef     FIXED	VECTOR[XYZ] ;		/* ベクトルデータ */
! typedef     FIXED	POINT[XYZ] ;		/* 頂点の位置データ */
  
! #define	    CURRENT		0	/* Current Matrix */
  
! enum mtrx {M00 , M01 , M02 ,		/* マトリクスの要素番号 */
  	   M10 , M11 , M12 ,
  	   M20 , M21 , M22 ,
  	   M30 , M31 , M32 ,
--- 108,121 ----
  				    + sizeof(void (*)()))] ;
  } EVENT ;
  
! typedef     FIXED	MATRIX[4][3] ;		/* ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽfｿｽ[ｿｽ^ */
! typedef     FIXED	VECTOR[XYZ] ;		/* ｿｽxｿｽNｿｽgｿｽｿｽｿｽfｿｽ[ｿｽ^ */
! typedef     FIXED	POINT[XYZ] ;		/* ｿｽｿｽｿｽ_ｿｽﾌ位置ｿｽfｿｽ[ｿｽ^ */
  
! #define	    CURRENT		0		/* Current Matrix */
! #define	    ORIGINAL		(0.99999)	/* Original Scale */
  
! enum mtrx {M00 , M01 , M02 ,		/* ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽﾌ要ｿｽfｿｽﾔ搾ｿｽ */
  	   M10 , M11 , M12 ,
  	   M20 , M21 , M22 ,
  	   M30 , M31 , M32 ,
***************
*** 107,129 ****
  	   } ;
  
  enum tvsz {
! 	TV_320x224 ,
! 	TV_320x240 ,
! 	TV_352x224 ,
! 	TV_352x240 ,
! 	TV_640x224 ,
! 	TV_640x240 ,
! 	TV_704x224 ,
! 	TV_704x240 ,
! 
! 	TV_320x448 ,
! 	TV_320x480 ,
! 	TV_352x448 ,
! 	TV_352x480 ,
! 	TV_640x448 ,
! 	TV_640x480 ,
! 	TV_704x448 ,
! 	TV_704x480
      } ;
  
  #define		_SysPause		64
--- 123,137 ----
  	   } ;
  
  enum tvsz {
! 	TV_320x224 , TV_320x240 , TV_320x256 , TV_dummy1 ,
! 	TV_352x224 , TV_352x240 , TV_352x256 , TV_dummy2 ,
! 	TV_640x224 , TV_640x240 , TV_640x256 , TV_dummy3 ,
! 	TV_704x224 , TV_704x240 , TV_704x256 , TV_dummy4 ,
! 
! 	TV_320x448 , TV_320x480 , TV_320x512 , TV_dummy5 ,
! 	TV_352x448 , TV_352x480 , TV_352x512 , TV_dummy6 ,
! 	TV_640x448 , TV_640x480 , TV_640x512 , TV_dummy7 ,
! 	TV_704x448 , TV_704x480 , TV_704x512 , TV_dummy8
      } ;
  
  #define		_SysPause		64
***************
*** 132,144 ****
--- 140,158 ----
  
  /*----------------------------------------------------------------------------------*/
  
+ #ifndef M_PI
+ #define     M_PI                3.1415926535897932
+ #endif
+ 
  #define	    toFIXED(a)		((FIXED)(65536.0 * (a)))
  #define	    POStoFIXED(x,y,z)	{toFIXED(x),toFIXED(y),toFIXED(z)}
  #define	    ATTRIBUTE(f,s,t,c,g,a,d,o)	{f,(s)|(((d)>>16)&0x1c)|(o),t,(a)|(((d)>>24)&0xc0),c,g,(d)&0x3f}
  #define	    SPR_ATTRIBUTE(t,c,g,a,d)	{t,(a)|(((d)>>24)&0xc0),c,g,(d)&0x0f3f}
  #define	    DEGtoANG(d)		((ANGLE)((65536.0 * (d)) / 360.0))
+ #define     RADtoANG(d)         ((ANGLE)((65536.0 * (d)) / (2*M_PI)))
  #define	    RGB(r,g,b)		(0x8000|((b)<<10)|((g)<<5)|(r))
  #define	    DGTtoRGB(c)		(0x8000|(((c)&0x0f00)<<3)|(((c)&0x4000)>>4)|(((c)&0x00f0)<<2)|(((c)&0x2000)>>8)|(((c)&0x000f)<<1)|(((c)&0x1000)>>12))
+ #define	    SLocate(x,y,p)	((p) * Page + (y) * Line + (x))
  
  /*  Sprite control function */
  
***************
*** 162,293 ****
  #define	    _ZmRC		(0x0b << 8)	/* Zoom base Right Center */
  #define	    _ZmRB		(0x0f << 8)	/* Zoom base Right Bottom */
  
! #define	    No_Window		(0 << 9)	/* ウィンドウの制限を受けない(default)*/
! #define	    Window_In		(2 << 9)	/* ウィンドウの内側に表示 */
! #define	    Window_Out		(3 << 9)	/* ウィンドウの外側に表示 */
! #define	    MESHoff		(0 << 8)	/* 通常表示(default) */
! #define	    MESHon		(1 << 8)	/* メッシュで表示 */
! #define	    ECdis		(1 << 7)	/* エンドコードをパレットのひとつとして使用 */
! #define	    ECenb		(0 << 7)	/* エンドコード有効 */
! #define	    SPdis		(1 << 6)	/* スペースコードをパレットのひとつとして使用 */
! #define	    SPenb		(0 << 6)	/* スペースは表示しない(default) */
! #define	    CL16Bnk		(0 << 3)	/* カラーバンク１６色モード (default) */
! #define	    CL16Look		(1 << 3)	/* カラールックアップ１６色モード */
! #define	    CL64Bnk		(2 << 3)	/* カラーバンク６４色モード */
! #define	    CL128Bnk		(3 << 3)	/* カラーバンク１２８色モード */
! #define	    CL256Bnk		(4 << 3)	/* カラーバンク２５６色モード */
! #define	    CL32KRGB		(5 << 3)	/* ＲＧＢ３２Ｋ色モード */
! #define	    CL_Replace		0		/* 重ね書き(上書き)モード */
! #define	    CL_Shadow		1		/* 影モード */
! #define	    CL_Half		2		/* 半輝度モード */
! #define	    CL_Trans		3		/* 半透明モード */
! #define	    CL_Gouraud		4		/* グーローシェーディングモード */
! 
! #define	    UseTexture		(1 << 2)	/* テクスチャを貼るポリゴン */
! #define	    UseLight		(1 << 3)	/* 光源の影響を受けるポリゴン */
! #define	    UseClip		(1 << 4)	/* 画面外に頂点が出たら表示しない */
! #define	    UsePalette		(1 << 5)	/*  */
! 
! #define	    sprHflip		(1 << 4) | FUNC_Texture | (UseTexture << 16)
! #define	    sprVflip		(1 << 5) | FUNC_Texture | (UseTexture << 16)
! #define	    sprHVflip		(3 << 4) | FUNC_Texture | (UseTexture << 16)
! #define	    sprNoflip		(0) | FUNC_Texture | (UseTexture << 16)
! #define	    sprPolygon		FUNC_Polygon | ((ECdis | SPdis) << 24)
! #define	    sprPolyLine		FUNC_PolyLine | ((ECdis | SPdis) << 24)
! #define	    sprLine		FUNC_Line | ((ECdis | SPdis) << 24)
! 
! #define	    No_Texture		0		/* テクスチャを使用しない時 */
! #define	    No_Option		0		/* オプションを使用しない時 */
! #define	    No_Gouraud		0		/* グーローシェーディングを使用しない時 */
! #define	    No_Palet	        0		/* カラーパレットの指定がいらない時 */
! #define	    GouraudRAM		(0x00080000 - (33*8))	/* 光源の影響用のグーローバッファ */
  
  typedef struct {
!     VECTOR	 norm ;				/* 法線ベクトル */
!     Uint16	 Vertices[4] ;		/* ポリゴンを構成する頂点番号 */
  } POLYGON ;
  
  typedef struct {
!     Uint8	 flag ;			/* 片面か両面かのフラグ */
!     Uint8	 sort ;			/* ソートの基準位置とオプション設定 */
!     Uint16	 texno ;		/* テクスチャ番号 */
!     Uint16	 atrb ;			/* アトリビュートデータ(表示モード) */
!     Uint16	 colno ;		/* カラーナンバー */
!     Uint16	 gstb ;			/* グーローシェーディングテーブル */
!     Uint16	 dir ; 			/* テクスチャの反転とファンクションナンバー */
  } ATTR ;
  
  typedef struct spratr{
!     Uint16	 texno ;		/* テクスチャ番号 */
!     Uint16	 atrb ;			/* アトリビュートデータ(表示モード) */
!     Uint16	 colno ;		/* カラーナンバー */
!     Uint16	 gstb ;			/* グーローシェーディングテーブル */
!     Uint16	 dir ;			/* テクスチャの反転とファンクションナンバー */
  } SPR_ATTR ;
  
  typedef struct {
!     POINT	*pntbl ;		/* 頂点の位置データテーブル */
!     Uint32	 nbPoint ;		/* 頂点の数 */
!     POLYGON	*pltbl ;		/* ポリゴン定義テーブル */
!     Uint32	 nbPolygon ;		/* ポリゴンの数 */
!     ATTR	*attbl ;		/* ポリゴンのアトリビュートテーブル */
  } PDATA ;
  
  typedef struct {
!     Uint16	 Hsize ;		/* スプライトのＨサイズ */
!     Uint16	 Vsize ;		/* スプライトのＶサイズ */
!     Uint16	 CGadr ;		/* スプライトＣＧアドレス / ８ */
!     Uint16	 HVsize ;		/* Ｈサイズ/８、Ｖサイズ(ハード用) */
  } TEXTURE ;
  
  typedef struct {
!     Uint16	 texno ;		/* テクスチャ番号 */
!     Uint16	 cmode ;		/* カラーモード */
!     void	*pcsrc ;		/* 元データの所在 */
  } PICTURE ;
  
! #define	    COL_16	(2+1)		/* カラーバンク１６色モード */
! #define	    COL_64	(2+0)		/* カラーバンク６４色モード */
! #define	    COL_128	(2+0)		/* カラーバンク１２８色モード */
! #define	    COL_256	(2+0)		/* カラーバンク２５６色モード */
! #define	    COL_32K	(2-1)		/* ＲＧＢ３２Ｋ色モード */
  
      enum base {
! 	SORT_MIN ,			/* ４点の内、一番手前の点を使う */
! 	SORT_CEN ,			/* ４点の平均位置を使う */
! 	SORT_MAX ,			/* ４点の内一番遠い点を使う */
! 	SORT_BFR			/* 直前に表示したポリゴンの位置を使う */
      } ;
  
      enum pln {
! 	Single_Plane ,			/* 片面ポリゴン */
! 	Dual_Plane			/* 両面ポリゴン(表裏判定の結果を見ない) */
      } ;
  
  typedef struct {
!     Uint16	CTRL ;			/* コントロールファンクション */
!     Uint16	LINK ;			/* リンクアドレス */
!     Uint16	PMOD ;			/* プットモード */
!     Uint16	COLR ;			/* カラーデータ */
!     Uint16	SRCA ;			/* ＣＧアドレス */
!     Uint16	SIZE ;			/* キャラクタサイズ */
!     Uint16	  XA ;			/* 表示位置 Ａ */
!     Uint16	  YA ;
!     Uint16	  XB ;			/* 表示位置 Ｂ */
!     Uint16	  YB ;
!     Uint16	  XC ;			/* 表示位置 Ｃ */
!     Uint16	  YC ;
!     Uint16	  XD ;			/* 表示位置 Ｄ */
!     Uint16	  YD ;
!     Uint16	GRDA ;			/* グーローシェーディングテーブル */
!     Uint16	DMMY ;			/* サイズ合わせ用 ダミーデータ */
  } SPRITE ;
  
  #define	    SpriteVRAM		0x25c00000
  
  /*-----------------------------------------------------------------------*/
  
! /* ＲＧＢモードカラーサンプルデータ */
  
  #define	    RGB_Flag		0x8000
  
--- 176,423 ----
  #define	    _ZmRC		(0x0b << 8)	/* Zoom base Right Center */
  #define	    _ZmRB		(0x0f << 8)	/* Zoom base Right Bottom */
  
! #define	    MSBon		(1 << 15)	/* ｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾉ擾ｿｽｿｽｿｽｿｽｿｽｿｽﾞＭｿｽrｿｽaｿｽｿｽｿｽPｿｽﾉゑｿｽｿｽｿｽ */
! #define	    HSSon		(1 << 12)	/* ｿｽnｿｽCｿｽXｿｽsｿｽ[ｿｽhｿｽVｿｽｿｽｿｽｿｽｿｽｿｽｿｽNｿｽLｿｽｿｽ */
! #define	    HSSoff		(0 << 12)	/* ｿｽnｿｽCｿｽXｿｽsｿｽ[ｿｽhｿｽVｿｽｿｽｿｽｿｽｿｽｿｽｿｽNｿｽｿｽｿｽｿｽ(default) */
! #define	    No_Window		(0 << 9)	/* ｿｽEｿｽBｿｽｿｽｿｽhｿｽEｿｽﾌ撰ｿｽｿｽｿｽｿｽｿｽｿｽけなゑｿｽ(default)*/
! #define	    Window_In		(2 << 9)	/* ｿｽEｿｽBｿｽｿｽｿｽhｿｽEｿｽﾌ難ｿｽｿｽｿｽｿｽﾉ表ｿｽｿｽ */
! #define	    Window_Out		(3 << 9)	/* ｿｽEｿｽBｿｽｿｽｿｽhｿｽEｿｽﾌ外ｿｽｿｽｿｽﾉ表ｿｽｿｽ */
! #define	    MESHoff		(0 << 8)	/* ｿｽﾊ擾ｿｽｿｽ\ｿｽｿｽ(default) */
! #define	    MESHon		(1 << 8)	/* ｿｽｿｽｿｽbｿｽVｿｽｿｽｿｽﾅ表ｿｽｿｽ */
! #define	    ECdis		(1 << 7)	/* ｿｽGｿｽｿｽｿｽhｿｽRｿｽ[ｿｽhｿｽｿｽｿｽpｿｽｿｽｿｽbｿｽgｿｽﾌひとつとゑｿｽｿｽﾄ使ｿｽp */
! #define	    ECenb		(0 << 7)	/* ｿｽGｿｽｿｽｿｽhｿｽRｿｽ[ｿｽhｿｽLｿｽｿｽ */
! #define	    SPdis		(1 << 6)	/* ｿｽXｿｽyｿｽ[ｿｽXｿｽRｿｽ[ｿｽhｿｽｿｽｿｽpｿｽｿｽｿｽbｿｽgｿｽﾌひとつとゑｿｽｿｽﾄ使ｿｽp */
! #define	    SPenb		(0 << 6)	/* ｿｽXｿｽyｿｽ[ｿｽXｿｽﾍ表ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ(default) */
! #define	    CL16Bnk		(0 << 3)	/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽPｿｽUｿｽFｿｽｿｽｿｽ[ｿｽh (default) */
! #define	    CL16Look		(1 << 3)	/* ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽbｿｽNｿｽAｿｽbｿｽvｿｽPｿｽUｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    CL64Bnk		(2 << 3)	/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽUｿｽSｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    CL128Bnk		(3 << 3)	/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽPｿｽQｿｽWｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    CL256Bnk		(4 << 3)	/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽQｿｽTｿｽUｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    CL32KRGB		(5 << 3)	/* ｿｽqｿｽfｿｽaｿｽRｿｽQｿｽjｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    CL_Replace		0		/* ｿｽdｿｽﾋ擾ｿｽｿｽｿｽ(ｿｽ繽托ｿｽｿｽ)ｿｽｿｽｿｽ[ｿｽh */
! #define	    CL_Shadow		1		/* ｿｽeｿｽｿｽｿｽ[ｿｽh */
! #define	    CL_Half		2		/* ｿｽｿｽｿｽPｿｽxｿｽｿｽｿｽ[ｿｽh */
! #define	    CL_Trans		3		/* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽh */
! #define	    CL_Gouraud		4		/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽh */
! 
! #define	    UseTexture		(1 << 2)	/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽｿｽｿｽ\ｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽ */
! #define	    UseLight		(1 << 3)	/* ｿｽｿｽｿｽｿｽｿｽﾌ影ｿｽｿｽｿｽｿｽｿｽけゑｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽ */
! #define	    UsePalette		(1 << 5)	/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌカｿｽｿｽｿｽ[ */
! 
! /* SGL Ver3.0 Add */
! #define	    UseNearClip		(1 << 6)	/* ｿｽjｿｽAｿｽEｿｽNｿｽｿｽｿｽbｿｽsｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽｿｽ */
! #define	    UseGouraud		(1 << 7)	/* ｿｽｿｽｿｽAｿｽｿｽｿｽOｿｽ[ｿｽｿｽｿｽ[ */
! #define	    UseDepth		(1 << 4)	/* ｿｽfｿｽvｿｽXｿｽLｿｽｿｽｿｽ[ */
! /* */
! 
! #if 0 /* SGL Ver3.0 Delete */
! #define	    UseClip		(1 << 4)		/* ｿｽｿｽｿｽﾊ外ｿｽﾉ抵ｿｽｿｽ_ｿｽｿｽｿｽoｿｽｿｽｿｽｿｽｿｽ\ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ */
! #else
! #define	    UseClip		UseNearClip		/* ｿｽjｿｽAｿｽEｿｽNｿｽｿｽｿｽbｿｽsｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽｿｽ */
! #endif
! 
! #define	    sprHflip		((1 << 4) | FUNC_Texture | (UseTexture << 16))
! #define	    sprVflip		((1 << 5) | FUNC_Texture | (UseTexture << 16))
! #define	    sprHVflip		((3 << 4) | FUNC_Texture | (UseTexture << 16))
! #define	    sprNoflip		((0) | FUNC_Texture | (UseTexture << 16))
! #define	    sprPolygon		(FUNC_Polygon | ((ECdis | SPdis) << 24))
! #define	    sprPolyLine		(FUNC_PolyLine | ((ECdis | SPdis) << 24))
! #define	    sprLine		(FUNC_Line | ((ECdis | SPdis) << 24))
! 
! #define	    No_Texture		0		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽﾈゑｿｽｿｽｿｽ */
! #define	    No_Option		0		/* ｿｽIｿｽvｿｽVｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽﾈゑｿｽｿｽｿｽ */
! #define	    No_Gouraud		0		/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽﾈゑｿｽｿｽｿｽ */
! #define	    No_Palet	        0		/* ｿｽJｿｽｿｽｿｽ[ｿｽpｿｽｿｽｿｽbｿｽgｿｽﾌ指ｿｽ閧ｪｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽｿｽ */
! #define	    GouraudRAM		(0x00080000 - (32*8))	/* ｿｽｿｽｿｽｿｽｿｽﾌ影ｿｽｿｽｿｽpｿｽﾌグｿｽ[ｿｽｿｽｿｽ[ｿｽoｿｽbｿｽtｿｽ@ */
  
  typedef struct {
!     VECTOR	 norm ;			/* ｿｽ@ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽ */
!     Uint16	 Vertices[4] ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽ\ｿｽｿｽｿｽｿｽｿｽ髓ｸｿｽ_ｿｽﾔ搾ｿｽ */
  } POLYGON ;
  
  typedef struct {
!     Uint8	 flag ;			/* ｿｽﾐ面ゑｿｽｿｽｿｽｿｽﾊゑｿｽｿｽﾌフｿｽｿｽｿｽO */
!     Uint8	 sort ;			/* ｿｽ\ｿｽ[ｿｽgｿｽﾌ基準ｿｽﾊ置ｿｽﾆオｿｽvｿｽVｿｽｿｽｿｽｿｽｿｽﾝ抵ｿｽ */
!     Uint16	 texno ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾔ搾ｿｽ */
!     Uint16	 atrb ;			/* ｿｽAｿｽgｿｽｿｽｿｽrｿｽｿｽｿｽ[ｿｽgｿｽfｿｽ[ｿｽ^(ｿｽ\ｿｽｿｽｿｽｿｽｿｽ[ｿｽh) */
!     Uint16	 colno ;		/* ｿｽJｿｽｿｽｿｽ[ｿｽiｿｽｿｽｿｽoｿｽ[ */
!     Uint16	 gstb ;			/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     Uint16	 dir ;			/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾌ費ｿｽｿｽ]ｿｽﾆフｿｽ@ｿｽｿｽｿｽNｿｽVｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽoｿｽ[ */
  } ATTR ;
  
  typedef struct spratr{
!     Uint16	 texno ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾔ搾ｿｽ */
!     Uint16	 atrb ;			/* ｿｽAｿｽgｿｽｿｽｿｽrｿｽｿｽｿｽ[ｿｽgｿｽfｿｽ[ｿｽ^(ｿｽ\ｿｽｿｽｿｽｿｽｿｽ[ｿｽh) */
!     Uint16	 colno ;		/* ｿｽJｿｽｿｽｿｽ[ｿｽiｿｽｿｽｿｽoｿｽ[ */
!     Uint16	 gstb ;			/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     Uint16	 dir ;			/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾌ費ｿｽｿｽ]ｿｽﾆフｿｽ@ｿｽｿｽｿｽNｿｽVｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽoｿｽ[ */
  } SPR_ATTR ;
  
  typedef struct {
!     POINT	*pntbl ;		/* ｿｽｿｽｿｽ_ｿｽﾌ位置ｿｽfｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     Uint32	 nbPoint ;		/* ｿｽｿｽｿｽ_ｿｽﾌ撰ｿｽ */
!     POLYGON	*pltbl ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽ`ｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     Uint32	 nbPolygon ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ撰ｿｽ */
!     ATTR	*attbl ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌアｿｽgｿｽｿｽｿｽrｿｽｿｽｿｽ[ｿｽgｿｽeｿｽ[ｿｽuｿｽｿｽ */
  } PDATA ;
  
+ /* SGL Ver3.0 Add */
+ typedef struct {
+     POINT	*pntbl ;		/* ｿｽｿｽｿｽ_ｿｽﾌ位置ｿｽfｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     Uint32	 nbPoint ;		/* ｿｽｿｽｿｽ_ｿｽﾌ撰ｿｽ */
+     POLYGON	*pltbl ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽ`ｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     Uint32	 nbPolygon ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ撰ｿｽ */
+     ATTR	*attbl ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌアｿｽgｿｽｿｽｿｽrｿｽｿｽｿｽ[ｿｽgｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     VECTOR	*vntbl;
+ } XPDATA ;
+ /* */
+ 
+ #ifdef ST_VE
+ 
+ typedef struct {
+     Uint16	 pmod ;			/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ\ｿｽｿｽｿｽｿｽｿｽ[ｿｽh */
+     Uint16	 colno ;		/* ｿｽJｿｽｿｽｿｽ[ｿｽiｿｽｿｽｿｽoｿｽ[ */
+     Uint16	 CGadr ;		/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽbｿｽfｿｽAｿｽhｿｽｿｽｿｽX / ｿｽW */
+     Uint16	 HVsize ;		/* ｿｽgｿｽTｿｽCｿｽY/ｿｽWｿｽAｿｽuｿｽTｿｽCｿｽY(ｿｽnｿｽ[ｿｽhｿｽp) */
+ } gxATTR_VDP1 ;
+ 
+ typedef struct {
+     Uint32	 texcel ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽZｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽX */
+     Uint16	 dspmode ;		/* ｿｽfｿｽBｿｽXｿｽvｿｽｿｽｿｽCｿｽｿｽｿｽ[ｿｽhｿｽtｿｽｿｽｿｽO */
+     Uint16	 colno ;		/* ｿｽJｿｽｿｽｿｽ[ｿｽfｿｽ[ｿｽ^ */
+     Uint8	 TXA , TYA ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽ|ｿｽCｿｽｿｽｿｽg */
+     Uint8	 TXB , TYB ;
+     Uint8	 TXC , TYC ;
+     Uint8	 TXD , TYD ;
+ } gxATTR_ENHC ;
+ 
+ typedef struct{
+     Uint16	 texno ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾔ搾ｿｽ */
+     Uint16	 atrb ;			/* ｿｽAｿｽgｿｽｿｽｿｽrｿｽｿｽｿｽ[ｿｽgｿｽfｿｽ[ｿｽ^(ｿｽ\ｿｽｿｽｿｽｿｽｿｽ[ｿｽh) */
+     Uint16	 colno ;		/* ｿｽJｿｽｿｽｿｽ[ｿｽiｿｽｿｽｿｽoｿｽ[ */
+     Uint16	 gstb ;			/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     Uint16	 dir ;			/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾌ費ｿｽｿｽ]ｿｽﾆフｿｽ@ｿｽｿｽｿｽNｿｽVｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽoｿｽ[ */
+ } gxSPR_ATTR ;
+ 
+ typedef struct {
+     Uint16	texno ;			/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽIｿｽtｿｽZｿｽbｿｽgｿｽAｿｽhｿｽｿｽｿｽX */
+     Uint8	attr ;			/* ｿｽｿｽｿｽｿｽｿｽRｿｽ[ｿｽhｿｽAｿｽ\ｿｽ[ｿｽeｿｽBｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽhｿｽｿｽ */
+     Uint8	nvface ;		/* ｿｽﾊ法ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽｿｽiｿｽｿｽｿｽoｿｽ[ */
+     Uint8	nvnum[4] ;		/* ｿｽｿｽｿｽ_ｿｽ@ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽｿｽiｿｽｿｽｿｽoｿｽ[ */
+     Uint8	Vertices[4] ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽ\ｿｽｿｽｿｽｿｽｿｽ髓ｸｿｽ_ｿｽﾔ搾ｿｽ */
+ } gxPOLYGON ;
+ 
+ typedef struct {
+     POINT	*pntbl ;		/* ｿｽｿｽｿｽ_ｿｽﾌ位置ｿｽfｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     Uint16	 nbPoint ;		/* ｿｽｿｽｿｽ_ｿｽﾌ撰ｿｽ */
+     Uint16	 nbNVector ;		/* ｿｽ@ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽｿｽﾌ撰ｿｽ */
+     VECTOR	*nvtbl ;		/* ｿｽ@ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     gxPOLYGON	*pltbl ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽ`ｿｽeｿｽ[ｿｽuｿｽｿｽ */
+     Uint32	 nbPolygon ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ撰ｿｽ */
+     gxATTR_VDP1	*attbl ;		/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌアｿｽgｿｽｿｽｿｽrｿｽｿｽｿｽ[ｿｽgｿｽeｿｽ[ｿｽuｿｽｿｽ */
+ } gxPDATA ;
+ 
  typedef struct {
!     Uint32	 texadr ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     Uint8	 BD ;			/* ｿｽeｿｽｿｽｿｽ_ｿｽﾌ輝ｿｽx */
!     Uint8	 BC ;
!     Uint8	 BB ;
!     Uint8	 BA ;
!     Sint16	 XA ;			/* ｿｽeｿｽｿｽｿｽ_ｿｽﾌ位置 */
!     Sint16	 YA ;
!     Sint16	 XB ;
!     Sint16	 YB ;
!     Sint16	 XC ;
!     Sint16	 YC ;
!     Sint16	 XD ;
!     Sint16	 YD ;
!     Uint16	 ZA ;			/* ｿｽeｿｽｿｽｿｽ_ｿｽﾌＺｿｽl */
!     Uint16	 ZB ;
!     Uint16	 ZC ;
!     Uint16	 ZD ;
!     Uint16	 winno ;		/* ｿｽEｿｽBｿｽｿｽｿｽhｿｽEｿｽiｿｽｿｽｿｽoｿｽ[ */
!     Uint16	 ZF ;			/* ｿｽｿｽｿｽ\ｿｽyｿｽl */
! } gxDIRECT ;
! 
! #define		winEXn		0	/* ｿｽGｿｽｿｽｿｽnｿｽｿｽｿｽTｿｽｿｽ ｿｽｿｽｿｽO(near) */
! #define		winEXf		1	/* ｿｽGｿｽｿｽｿｽnｿｽｿｽｿｽTｿｽｿｽ ｿｽｿｽ(far) */
! #define		winSTn		2	/* ｿｽrｿｽs-ｿｽuｿｽｿｽ ｿｽｿｽｿｽO(near) */
! #define		winSTf		3	/* ｿｽrｿｽs-ｿｽuｿｽｿｽ ｿｽｿｽ(far) */
! 
! #define	    gxPOLYTBL(f,s,t,m,n)	{((f)<<16)|((t)<<20)|((s)<<12)|((m)<<8)|(n)
! #define	    gxNormal(a,b,c,d)		(a,b,c,d)
! #define	    gxVertices(a,b,c,d)		(a,b,c,d)}
! #define	    gxATTRVDP1(p,c,a,s)		{p,c,a,s}
! #define	    gxATTRENHC(cx,cy,sx,sy,cm,cl,an,hf,ms,sp,te,fm)	{\
! 					((cx)<<4)|((cy)<<14)|(sx)|((sy)<<10)|(cm),\
! 					((ms)>>5)|(((sp)^SPdis)>>4)|((te)<<1)|\
! 					((an)<<8)|((hf)<<6)|(fm),(cl)
! #endif
! 
! typedef struct obj{
!     PDATA	*pat ;			/* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽfｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     FIXED	 pos[XYZ] ;		/* ｿｽｿｽｿｽﾎ位置ｿｽfｿｽ[ｿｽ^ */
!     ANGLE	 ang[XYZ] ;		/* ｿｽｿｽｿｽ]ｿｽpｿｽfｿｽ[ｿｽ^ */
!     FIXED	 scl[XYZ] ;		/* ｿｽXｿｽPｿｽ[ｿｽｿｽｿｽｿｽｿｽOｿｽfｿｽ[ｿｽ^ */
!     struct obj	*child ;		/* ｿｽqｿｽIｿｽuｿｽWｿｽFｿｽNｿｽgｿｽfｿｽ[ｿｽ^ */
!     struct obj	*sibling ;		/* ｿｽZｿｽｿｽｿｽIｿｽuｿｽWｿｽFｿｽNｿｽgｿｽfｿｽ[ｿｽ^ */
! } OBJECT ;
! 
! typedef struct {
!     Uint16	 Hsize ;		/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌＨｿｽTｿｽCｿｽY */
!     Uint16	 Vsize ;		/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌＶｿｽTｿｽCｿｽY */
!     Uint16	 CGadr ;		/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽbｿｽfｿｽAｿｽhｿｽｿｽｿｽX / ｿｽW */
!     Uint16	 HVsize ;		/* ｿｽgｿｽTｿｽCｿｽY/ｿｽWｿｽAｿｽuｿｽTｿｽCｿｽY(ｿｽnｿｽ[ｿｽhｿｽp) */
  } TEXTURE ;
  
  typedef struct {
!     Uint16	 texno ;		/* ｿｽeｿｽNｿｽXｿｽ`ｿｽｿｽｿｽﾔ搾ｿｽ */
!     Uint16	 cmode ;		/* ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽ[ｿｽh */
!     void	*pcsrc ;		/* ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽﾌ擾ｿｽｿｽｿｽ */
  } PICTURE ;
  
! #define	    COL_16	(2+1)		/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽPｿｽUｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    COL_64	(2+0)		/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽUｿｽSｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    COL_128	(2+0)		/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽPｿｽQｿｽWｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    COL_256	(2+0)		/* ｿｽJｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽNｿｽQｿｽTｿｽUｿｽFｿｽｿｽｿｽ[ｿｽh */
! #define	    COL_32K	(2-1)		/* ｿｽqｿｽfｿｽaｿｽRｿｽQｿｽjｿｽFｿｽｿｽｿｽ[ｿｽh */
  
      enum base {
! 	SORT_MIN ,			/* ｿｽSｿｽ_ｿｽﾌ難ｿｽｿｽAｿｽｿｽｿｽﾔ趣ｿｽｿｽOｿｽﾌ点ｿｽｿｽｿｽgｿｽｿｽ */
! 	SORT_CEN ,			/* ｿｽSｿｽ_ｿｽﾌ包ｿｽｿｽﾏ位置ｿｽｿｽｿｽgｿｽｿｽ */
! 	SORT_MAX ,			/* ｿｽSｿｽ_ｿｽﾌ難ｿｽｿｽｿｽｿｽﾔ会ｿｽｿｽｿｽｿｽ_ｿｽｿｽｿｽgｿｽｿｽ */
! 	SORT_BFR			/* ｿｽｿｽｿｽOｿｽﾉ表ｿｽｿｽｿｽｿｽｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ位置ｿｽｿｽｿｽgｿｽｿｽ */
      } ;
  
      enum pln {
! 	Single_Plane ,			/* ｿｽﾐ面ポｿｽｿｽｿｽSｿｽｿｽ */
! 	Dual_Plane			/* ｿｽｿｽｿｽﾊポｿｽｿｽｿｽSｿｽｿｽ(ｿｽ\ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ鯉ｿｽｿｽﾊゑｿｽｿｽｿｽｿｽﾈゑｿｽ) */
      } ;
  
  typedef struct {
!     Uint16	CTRL ;			/* ｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽtｿｽ@ｿｽｿｽｿｽNｿｽVｿｽｿｽｿｽｿｽ */
!     Uint16	LINK ;			/* ｿｽｿｽｿｽｿｽｿｽNｿｽAｿｽhｿｽｿｽｿｽX */
!     Uint16	PMOD ;			/* ｿｽvｿｽbｿｽgｿｽｿｽｿｽ[ｿｽh */
!     Uint16	COLR ;			/* ｿｽJｿｽｿｽｿｽ[ｿｽfｿｽ[ｿｽ^ */
!     Uint16	SRCA ;			/* ｿｽbｿｽfｿｽAｿｽhｿｽｿｽｿｽX */
!     Uint16	SIZE ;			/* ｿｽLｿｽｿｽｿｽｿｽｿｽNｿｽ^ｿｽTｿｽCｿｽY */
!     Sint16	  XA ;			/* ｿｽ\ｿｽｿｽｿｽﾊ置 ｿｽ` */
!     Sint16	  YA ;
!     Sint16	  XB ;			/* ｿｽ\ｿｽｿｽｿｽﾊ置 ｿｽa */
!     Sint16	  YB ;
!     Sint16	  XC ;			/* ｿｽ\ｿｽｿｽｿｽﾊ置 ｿｽb */
!     Sint16	  YC ;
!     Sint16	  XD ;			/* ｿｽ\ｿｽｿｽｿｽﾊ置 ｿｽc */
!     Sint16	  YD ;
!     Uint16	GRDA ;			/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽeｿｽ[ｿｽuｿｽｿｽ */
!     Uint16	DMMY ;			/* ｿｽTｿｽCｿｽYｿｽｿｽｿｽせｿｽp ｿｽ_ｿｽ~ｿｽ[ｿｽfｿｽ[ｿｽ^ */
  } SPRITE ;
  
  #define	    SpriteVRAM		0x25c00000
  
  /*-----------------------------------------------------------------------*/
  
! /* ｿｽqｿｽfｿｽaｿｽｿｽｿｽ[ｿｽhｿｽJｿｽｿｽｿｽ[ｿｽTｿｽｿｽｿｽvｿｽｿｽｿｽfｿｽ[ｿｽ^ */
  
  #define	    RGB_Flag		0x8000
  
***************
*** 330,387 ****
  #define	    VDP2_VRAM_B0	0x25e40000
  #define	    VDP2_VRAM_B1	0x25e60000
  
! #define	    CGN01_RAM		VDP2_VRAM_B1		/* スクロール０、１用ＣＧデータ */
! #define	    NBG0_MAP		(CGN01_RAM+0x16000)	/* スクロール０のＶＲＡＭアドレス */
! #define	    NBG1_MAP		(CGN01_RAM+0x18000)	/* スクロール１のＶＲＡＭアドレス */
  
! #define	    KTBL0_RAM		VDP2_VRAM_A1		/* 回転スクロール用係数テーブル */
  #define	    BACK_CRAM		(KTBL0_RAM + 0x1fffe)	/* Back color */
  #define     RBG_PARA_ADR	(KTBL0_RAM + 0x1ff00)
  #define     RBG_PARB_ADR	(RBG_PARA_ADR+ 0x80)
  
! #define	    CGR0_RAM		VDP2_VRAM_A0		/* 回転スクロール用ＣＧデータ*/
! #define	    RBG0_MAP		VDP2_VRAM_B0		/* 回転スクロール０のＶＲＡＭアドレス */
  #define	    VDP2_COLRAM    		0x25f00000
  
! #define	    CG_Size		(8*8)		/* １セルの大きさ(CG) */
! typedef     Uint16		CELL ;		/* １セルの大きさ(Pattern name) */
! #define	    Line		64		/* １ラインの大きさ */
! #define	    Page		(64*Line)	/* １ページの大きさ */
  
  typedef struct rdat{
!     FIXED	XST ;		/* スクリーン画面スタート座標 Ｘst */
!     FIXED	YST ;		/* スクリーン画面スタート座標 Ｙst */
!     FIXED	ZST ;		/* スクリーン画面スタート座標 Ｚst */
!     FIXED	DXST ;		/* スクリーン画面垂直方向座標増分 ｄＸst */
!     FIXED	DYST ;		/* スクリーン画面垂直方向座標増分 ｄＹst */
!     FIXED	DX ;		/* スクリーン画面水平方向座標増分 ｄＸ */
!     FIXED	DY ;		/* スクリーン画面水平方向座標増分 ｄＹ */
!     FIXED	MATA ;		/* 回転マトリクスパラメータＡ */
!     FIXED	MATB ;		/* 回転マトリクスパラメータＢ */
!     FIXED	MATC ;		/* 回転マトリクスパラメータＣ */
!     FIXED	MATD ;		/* 回転マトリクスパラメータＤ */
!     FIXED	MATE ;		/* 回転マトリクスパラメータＥ */
!     FIXED	MATF ;		/* 回転マトリクスパラメータＦ */
! 
!     Sint16	PX ;		/* 視点座標 Ｐx */
!     Sint16	PY ;		/* 視点座標 Ｐy */
!     Sint16	PZ ;		/* 視点座標 Ｐz */
      Sint16	dummy0 ;
!     Sint16	CX ;		/* 中心座標 Ｃx */
!     Sint16	CY ;		/* 中心座標 Ｃy */
!     Sint16	CZ ;		/* 中心座標 Ｃz */
      Sint16	dummy1 ;
  
!     FIXED	MX ;		/* 平行移動量 Ｍx */
!     FIXED	MY ;		/* 平行移動量 Ｍy */
!     FIXED	KX ;		/* 拡大縮小係数 kx */
!     FIXED	KY ;		/* 拡大縮小係数 ky */
! 
!     Uint32	KAST ;		/* 係数テーブルスタートアドレス ＫＡst */
!     Sint32	DKAST ;		/* 係数テーブル垂直方向アドレス増分 ＫＡst */
!     Sint32	DKA ;		/* 係数テーブル水平方向アドレス増分 ＫＡ */
  } ROTSCROLL ;
  
  
  /* slColRAMMode */
  #define		CRM16_1024		0
--- 460,527 ----
  #define	    VDP2_VRAM_B0	0x25e40000
  #define	    VDP2_VRAM_B1	0x25e60000
  
! #define	    CGN01_RAM		VDP2_VRAM_B1		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽAｿｽPｿｽpｿｽbｿｽfｿｽfｿｽ[ｿｽ^ */
! #define	    NBG0_MAP		(CGN01_RAM+0x16000)	/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽﾌＶｿｽqｿｽ`ｿｽlｿｽAｿｽhｿｽｿｽｿｽX */
! #define	    NBG1_MAP		(CGN01_RAM+0x18000)	/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽPｿｽﾌＶｿｽqｿｽ`ｿｽlｿｽAｿｽhｿｽｿｽｿｽX */
  
! #define	    KTBL0_RAM		VDP2_VRAM_A1		/* ｿｽｿｽｿｽ]ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽpｿｽWｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽ */
  #define	    BACK_CRAM		(KTBL0_RAM + 0x1fffe)	/* Back color */
  #define     RBG_PARA_ADR	(KTBL0_RAM + 0x1ff00)
  #define     RBG_PARB_ADR	(RBG_PARA_ADR+ 0x80)
  
! #define	    CGR0_RAM		VDP2_VRAM_A0		/* ｿｽｿｽｿｽ]ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽpｿｽbｿｽfｿｽfｿｽ[ｿｽ^*/
! #define	    RBG0_MAP		VDP2_VRAM_B0		/* ｿｽｿｽｿｽ]ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽﾌＶｿｽqｿｽ`ｿｽlｿｽAｿｽhｿｽｿｽｿｽX */
  #define	    VDP2_COLRAM    		0x25f00000
  
! #define	    CG_Size		(8*8)		/* ｿｽPｿｽZｿｽｿｽｿｽﾌ大きｿｽｿｽ(CG) */
! #define     CG16Size            (8*8/2)         /* ｿｽPｿｽZｿｽｿｽｿｽﾌ大きｿｽｿｽ(CG 16Colors) */
! #define     CG256Size           (8*8)           /* ｿｽPｿｽZｿｽｿｽｿｽﾌ大きｿｽｿｽ(CG 256Colors) */
! #define     CG2048Size          (8*8*2)         /* ｿｽPｿｽZｿｽｿｽｿｽﾌ大きｿｽｿｽ(CG 2048Colors) */
! #define     CG32KSize           (8*8*2)         /* ｿｽPｿｽZｿｽｿｽｿｽﾌ大きｿｽｿｽ(CG 32KColors) */
! 
! typedef     Uint16		CELL ;		/* ｿｽPｿｽZｿｽｿｽｿｽﾌ大きｿｽｿｽ(Pattern name) */
! #define	    Line		64		/* ｿｽPｿｽｿｽｿｽCｿｽｿｽｿｽﾌ大きｿｽｿｽ */
! #define	    Page		(64*Line)	/* ｿｽPｿｽyｿｽ[ｿｽWｿｽﾌ大きｿｽｿｽ */
  
  typedef struct rdat{
!     FIXED	XST ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊスｿｽ^ｿｽ[ｿｽgｿｽｿｽｿｽW ｿｽwst */
!     FIXED	YST ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊスｿｽ^ｿｽ[ｿｽgｿｽｿｽｿｽW ｿｽxst */
!     FIXED	ZST ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊスｿｽ^ｿｽ[ｿｽgｿｽｿｽｿｽW ｿｽyst */
!     FIXED	DXST ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊ撰ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽWｿｽｿｽｿｽｿｽ ｿｽｿｽｿｽwst */
!     FIXED	DYST ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊ撰ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽWｿｽｿｽｿｽｿｽ ｿｽｿｽｿｽxst */
!     FIXED	DX ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊ撰ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽWｿｽｿｽｿｽｿｽ ｿｽｿｽｿｽw */
!     FIXED	DY ;		/* ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊ撰ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽWｿｽｿｽｿｽｿｽ ｿｽｿｽｿｽx */
!     FIXED	MATA ;		/* ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽ` */
!     FIXED	MATB ;		/* ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽa */
!     FIXED	MATC ;		/* ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽb */
!     FIXED	MATD ;		/* ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽc */
!     FIXED	MATE ;		/* ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽd */
!     FIXED	MATF ;		/* ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽe */
! 
!     Sint16	PX ;		/* ｿｽｿｽｿｽ_ｿｽｿｽｿｽW ｿｽox */
!     Sint16	PY ;		/* ｿｽｿｽｿｽ_ｿｽｿｽｿｽW ｿｽoy */
!     Sint16	PZ ;		/* ｿｽｿｽｿｽ_ｿｽｿｽｿｽW ｿｽoz */
      Sint16	dummy0 ;
!     Sint16	CX ;		/* ｿｽｿｽｿｽSｿｽｿｽｿｽW ｿｽbx */
!     Sint16	CY ;		/* ｿｽｿｽｿｽSｿｽｿｽｿｽW ｿｽby */
!     Sint16	CZ ;		/* ｿｽｿｽｿｽSｿｽｿｽｿｽW ｿｽbz */
      Sint16	dummy1 ;
  
!     FIXED	MX ;		/* ｿｽｿｽｿｽsｿｽﾚ難ｿｽｿｽｿｽ ｿｽlx */
!     FIXED	MY ;		/* ｿｽｿｽｿｽsｿｽﾚ難ｿｽｿｽｿｽ ｿｽly */
!     FIXED	KX ;		/* ｿｽgｿｽｿｽｿｽkｿｽｿｽｿｽWｿｽｿｽ kx */
!     FIXED	KY ;		/* ｿｽgｿｽｿｽｿｽkｿｽｿｽｿｽWｿｽｿｽ ky */
! 
!     Uint32	KAST ;		/* ｿｽWｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽｿｽXｿｽ^ｿｽ[ｿｽgｿｽAｿｽhｿｽｿｽｿｽX ｿｽjｿｽ`st */
!     Sint32	DKAST ;		/* ｿｽWｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽXｿｽｿｽｿｽｿｽ ｿｽjｿｽ`st */
!     Sint32	DKA ;		/* ｿｽWｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽXｿｽｿｽｿｽｿｽ ｿｽjｿｽ` */
  } ROTSCROLL ;
  
+ /* slExtSignal */
+ #define		EXLTEN			0x0200		/* External latch enable */
+ #define		EXSYEN			0x0100		/* External synch enable */
+ #define		DASEL			0x0002		/* Display area select */
+ #define		EXBGEN			0x0001		/* External background screen enable */
  
  /* slColRAMMode */
  #define		CRM16_1024		0
***************
*** 515,520 ****
--- 655,662 ----
  #define		scnNBG2			3
  #define		scnNBG3			2
  #define		scnRBG0			5
+ #define		scnRBGA			5
+ #define		scnRBGB			4
  #define		scnSPR			4
  #define		scnROT			7
  #define		scnCCAL			6
***************
*** 660,689 ****
  #define		SoundRAM		0x25a00000
  
  /*------[ System Work Assignments ]---------------------------------------*/
! 
! /*
!     extern const Uint16  MaxVertices ;
!     extern const Uint16  MaxPolygons ;
!     extern const void*   SortList ;	
!     extern const void*   TransList ;
!     extern const void*   Zbuffer ;	
!     extern const void*   SlSpriteBuf ;	
!     extern const void*   MsSpriteBuf ;	
!     extern const Uint16  SpriteBufSize ;
!     extern const void*   Pbuffer ;	
!     extern const void*   CLOfstBuf ;	
!     extern const void*   CommandBuf ;	
! */
! 
! 
  /*------[ Prottype ]------------------------------------------------------*/
  
  /*  Int library	*/
  
      extern  void  BlankIn(void) ;
      extern  void  BlankOut(void) ;
! 
! 
  /*  Math library	*/
  
      extern  FIXED  slSin(ANGLE) ;
--- 802,840 ----
  #define		SoundRAM		0x25a00000
  
  /*------[ System Work Assignments ]---------------------------------------*/
! 
!     extern const void*   MasterStack ;	/* Stack area End */
!     extern const Uint16  MaxVertices ;	/* Calculatable vertice numbers */
!     extern const Uint16  MaxPolygons ;	/* Calculatable polygon numbers */
!     extern const Uint16  EventSize ;	/* sizeof(EVENT) */
!     extern const Uint16  WorkSize ;	/* sizeof(WORK) */
!     extern const Uint16  MaxEvents ;	/* Useful Event count */
!     extern const Uint16  MaxWorks ;	/* Useful Work count */
!     extern const void*   SortList ;	/* SCU D.M.A. Table */
!     extern const Uint32  SortListSize ;	/* Sprite transfer request table size */
!     extern const void*   TransList ;	/* SCU D.M.A. Table */
!     extern const void*   Zbuffer ;	/* (128 + 128 + 256) * 4 Bytes fix */
!     extern const void*   SpriteBuf ;	/* Sprite control data buffer */
!     extern const Uint32  SpriteBufSize ; /* Sprite control data buffer size */
!     extern const void*   Pbuffer ;	/* Point calculate buffer */
!     extern const void*   CLOfstBuf ;	/* 32 * 32 Bytes fix */
!     extern const void*   CommandBuf ;	/* Command for slave CPU buffer */
!     extern const void*   PCM_Work ;	/* PCM data buffer */
!     extern const Uint32  PCM_WkSize ;	/* PCM data buffer size */
! 
!     extern EVENT  EventBuf[] ;		/* buffer for Event use */
!     extern WORK   WorkBuf[] ;		/* buffer for Work use */
!     extern EVENT* RemainEvent[] ;	/* Remain Event address buffer */
!     extern WORK*  RemainWork[] ;	/* Remain Work address buffer */
! 
  /*------[ Prottype ]------------------------------------------------------*/
  
  /*  Int library	*/
  
      extern  void  BlankIn(void) ;
      extern  void  BlankOut(void) ;
! 
! 
  /*  Math library	*/
  
      extern  FIXED  slSin(ANGLE) ;
***************
*** 696,715 ****
--- 847,877 ----
      extern  FIXED  slDivFX(FIXED , FIXED) ;
      extern  FIXED  slInnerProduct(VECTOR vct1 , VECTOR vct2) ;
      extern  FIXED  slCalcPoint(FIXED , FIXED , FIXED , FIXED ans[XYZ]) ;
+     extern  FIXED  slCalcVector(VECTOR vct , VECTOR ans) ;
      extern  FIXED  slRandom(void) ;
      extern  void   slNormalVector(VECTOR , VECTOR , VECTOR , VECTOR) ;
+     extern  void   slRevNormalVector(VECTOR , VECTOR , VECTOR , VECTOR) ;
  
      extern  void   slInitMatrix(void) ;
      extern  void   slUnitMatrix(MATRIX) ;
      extern  Bool   slPushMatrix(void) ;
      extern  Bool   slPopMatrix(void) ;
      extern  Bool   slPushUnitMatrix(void) ;
+     extern  Bool   slIncMatrixPtr(void) ;
+     extern  Bool   slDecMatrixPtr(void) ;
      extern  void   slLoadMatrix(MATRIX) ;
      extern  void   slGetMatrix(MATRIX) ;
+     extern  Bool   slCopyMatrix() ;
+     extern  void   slGetTranslate(FIXED*) ;
+     extern  void   slLoadTranslate(FIXED , FIXED , FIXED) ;
+     extern  void   slRegistMatrix(MATRIX) ;
      extern  void   slInversMatrix(void) ;
      extern  void   slTransposeMatrix(void) ;
+     extern  void   slUnitAngle(MATRIX) ;
+     extern  void   slUnitTranslate(MATRIX) ;
  
      extern  void   slTranslate(FIXED , FIXED , FIXED) ;
+     extern  void   slRegistTranslate(FIXED , FIXED , FIXED) ;
      extern  void   slMultiMatrix(MATRIX) ;
      extern  void   slScale(FIXED , FIXED , FIXED) ;
      extern  void   slRotX(ANGLE) ;
***************
*** 722,732 ****
--- 884,899 ----
      extern  void   slLookAt(FIXED *camera , FIXED *target , ANGLE) ;
      extern  FIXED  slBallCollision(FIXED *pos1 , FIXED size1 , FIXED *pos2 , FIXED size2) ;
      extern  FIXED  slCheckOnScreen(FIXED *pos , FIXED size) ;
+     extern  FIXED  slCheckOnScreen0(FIXED size) ;
      extern  void   slBezier(VECTOR p1,VECTOR p2,VECTOR p3,VECTOR p4,FIXED time,VECTOR ans) ;
+     extern  FIXED  slConvert3Dto2D( FIXED pos[XYZ], Sint32 ans[XY]) ;
+     extern  FIXED  slConvert3Dto2DFX( FIXED pos[XYZ], FIXED ans[XY]) ;
  
  /*  Text display library	*/
  
      extern void   *slLocate(Uint16 , Uint16) ;
+     extern void    slCurScrn(Uint16) ;
+     extern void    slCurColor(Uint16) ;
      extern void    slDispHex(Uint32 , void *) ;
      extern void    slPrintHex(Uint32 , void *) ;
      extern void    slPrintMatrix(MATRIX , void *) ;
***************
*** 740,763 ****
      extern void    set_vbar(Uint16) ;
      extern void    reset_vbar(Uint16) ;
      extern void    slExtendScroll(Uint8 * , void *) ;
  
  /*  Sprite library	*/
  
!     extern  void   slPutPolygon(PDATA *) ;
!     extern  void   slPutPolygonS(PDATA *) ;
!     extern  void   slDispPolygon(PDATA *, Uint16) ;
!     extern  void   slPutSprite(FIXED * , SPR_ATTR *attr , ANGLE) ;
!     extern  void   slDispSprite(FIXED * , SPR_ATTR *attr , ANGLE) ;
      extern  void   slPerspective(ANGLE) ;
!     extern  void   slWindow(Sint16 , Sint16 , Sint16 , Sint16 , Sint16 , Sint16 , Sint16) ;
      extern  void   slLight(VECTOR) ;
!     extern  void   slSetSprite(SPRITE * , FIXED) ;
      extern  void   slZdspLevel(Uint16) ;
  
  /*  Scroll library	*/
  
      extern  void    slTVOn(void) ;
      extern  void    slTVOff(void) ;
      extern  void    slColRAMMode(Uint16) ;
      extern  void    slVRAMMode(Uint16) ;
      extern  void    slScrCycleSet(Uint32 , Uint32 , Uint32 , Uint32) ;
--- 907,953 ----
      extern void    set_vbar(Uint16) ;
      extern void    reset_vbar(Uint16) ;
      extern void    slExtendScroll(Uint8 * , void *) ;
+     extern void   *slLocateNbg(Uint16 , Uint16 , Uint16) ;
+ #define		slLocateNbg0(x,y)	slLocateNbg(x,y,scnNBG0)
+ #define		slLocateNbg1(x,y)	slLocateNbg(x,y,scnNBG1)
+ #define		slLocateNbg2(x,y)	slLocateNbg(x,y,scnNBG2)
+ #define		slLocateNbg3(x,y)	slLocateNbg(x,y,scnNBG3)
+     extern void   *slLocatePage(Uint16 , Uint16 , Uint16) ;
  
  /*  Sprite library	*/
  
!     extern  Bool   slPutPolygon(PDATA *) ;
!     extern  Bool   slPutPolygonS(PDATA *) ;
!     extern  Bool   slDispPolygon(PDATA * , Uint16) ;
!     extern  Bool   slPutSprite(FIXED * , SPR_ATTR *attr , ANGLE) ;
!     extern  Bool   slDispSprite(FIXED * , SPR_ATTR *attr , ANGLE) ;
!     extern  Bool   slDispSpriteHV(FIXED * , SPR_ATTR *attr , ANGLE) ;
!     extern  Bool   slDispSpriteSZ(FIXED * , SPR_ATTR *attr , ANGLE) ;
!     extern  Bool   slDispSprite4P(FIXED * , FIXED , SPR_ATTR *attr) ;
      extern  void   slPerspective(ANGLE) ;
!     extern  void   slSetScreenDist(FIXED) ;
!     extern  Bool   slWindow(Sint16 , Sint16 , Sint16 , Sint16 , Sint16 , Sint16 , Sint16) ;
      extern  void   slLight(VECTOR) ;
!     extern  Bool   slSetSprite(SPRITE * , FIXED) ;
      extern  void   slZdspLevel(Uint16) ;
+     extern  Bool   slPutObject(OBJECT *) ;
+     extern  void   slCurWindow(Uint8) ;
+     enum {
+ 	winFar ,		/* Far side Window */
+ 	winNear			/* Near side Window */
+     } ;
+     extern  Uint8  slSprWinNum() ;
+     extern  void   slFrameClipSize(Sint16 , Sint16 );
+     extern  void   slSetScreenDist(FIXED);
+     extern  void   slGetFrameData(void * , Uint16 , Uint16 );
  
  /*  Scroll library	*/
  
      extern  void    slTVOn(void) ;
      extern  void    slTVOff(void) ;
+     extern  Uint16  slGetHCount(void) ;
+     extern  Uint16  slGetVCount(void) ;
+     extern  void    slExtSignal(Uint16 , Uint16) ;
      extern  void    slColRAMMode(Uint16) ;
      extern  void    slVRAMMode(Uint16) ;
      extern  void    slScrCycleSet(Uint32 , Uint32 , Uint32 , Uint32) ;
***************
*** 774,780 ****
      extern  void    slColorCalc(Uint16) ;
      extern  void    slColorCalcMode(Uint16) ;
      extern  void    slColorCalcOn(Uint16) ;
!     extern  void    slColRate(Uint16 , Uint16) ;
  #define		slColRateNbg0(rate)	slColRate(scnNBG0 , rate)
  #define		slColRateNbg1(rate)	slColRate(scnNBG1 , rate)
  #define		slColRateNbg2(rate)	slColRate(scnNBG2 , rate)
--- 964,970 ----
      extern  void    slColorCalc(Uint16) ;
      extern  void    slColorCalcMode(Uint16) ;
      extern  void    slColorCalcOn(Uint16) ;
!     extern  void    slColRate(Sint16 , Uint16) ;
  #define		slColRateNbg0(rate)	slColRate(scnNBG0 , rate)
  #define		slColRateNbg1(rate)	slColRate(scnNBG1 , rate)
  #define		slColRateNbg2(rate)	slColRate(scnNBG2 , rate)
***************
*** 791,796 ****
--- 981,988 ----
  #define		slColRateSpr6(rate)	slColRate(scnSPR6 , rate)
  #define		slColRateSpr7(rate)	slColRate(scnSPR7 , rate)
      extern  void    slColOffsetOn(Uint16) ;
+     extern  void    slColOffsetOff(Uint16) ;
+     extern  void    slColOffsetAUse(Uint16) ;
      extern  void    slColOffsetBUse(Uint16) ;
      extern  void    slColOffsetScrn(Uint16 , Uint16) ;
      extern  void    slColOffsetA(Sint16 r,Sint16 g,Sint16 b) ;
***************
*** 854,859 ****
--- 1046,1054 ----
      extern  void    slZoomNbg0(FIXED x,FIXED y) ;
      extern  void    slZoomNbg1(FIXED x,FIXED y) ;
      extern  void    slZoomR(FIXED x,FIXED y) ;
+     extern  void    slScrScaleNbg0(FIXED x,FIXED y) ;
+     extern  void    slScrScaleNbg1(FIXED x,FIXED y) ;
+     extern  void    slScrScaleR(FIXED x,FIXED y) ;
      extern  void    slZoomMode(Uint16 , Uint16) ;
  #define		slZoomModeNbg0(mode)	slZoomMode(scnNBG0 , mode)
  #define		slZoomModeNbg1(mode)	slZoomMode(scnNBG1 , mode)
***************
*** 863,869 ****
      extern  void    slSpriteCCalcNum(Uint16) ;
      extern  void    slSpriteColMode(Uint16) ;
      extern  void    slSpriteWinMode(Uint16) ;
! 	extern  void    slSpriteType(Uint16) ;
      extern  void    slScrMosaicOn(Uint16) ;
      extern  void    slScrMosSize(Uint16 , Uint16) ;
      extern  void    slScrWindow0(Uint16 , Uint16 , Uint16 , Uint16) ;
--- 1058,1064 ----
      extern  void    slSpriteCCalcNum(Uint16) ;
      extern  void    slSpriteColMode(Uint16) ;
      extern  void    slSpriteWinMode(Uint16) ;
!     extern  void    slSpriteType(Uint16) ;
      extern  void    slScrMosaicOn(Uint16) ;
      extern  void    slScrMosSize(Uint16 , Uint16) ;
      extern  void    slScrWindow0(Uint16 , Uint16 , Uint16 , Uint16) ;
***************
*** 939,988 ****
  #define		slSpecialCCalcBitBMN0(flag)	slSpecialCCalcBitN01(scnNBG0 , flag)
  #define		slSpecialCCalcBitBMN1(flag)	slSpecialCCalcBitN01(scnNBG1 , flag)
  #define		slSpecialCCalcBitBMR0(flag)	slSpecialCCalcBitRbg0(flag)
!     extern  void    setASC_1to8(Uint8 * , Uint16 * , Uint32 , Uint8) ;
!     extern  void    setASC_4to8(Uint8 * , Uint16 * , Uint32 , Uint8) ;
      extern  Uint8   SGL_ASCII_CG[] ;
  
  /*  Peripheral control */
  
! #define	SMPC_MASK_STE		0x80	/* ＳＥＴＴＩＭＥ実行済マスク		*/
! #define	SMPC_MASK_RESD		0x40	/* リセットイネーブルマスク		*/
! #define	SMPC_MASK_WEEK		0xf0	/* ＲＴＣ曜日マスク			*/
! #define	SMPC_MASK_MONTH		0x0f	/* ＲＴＣ月マスク			*/
! #define	SMPC_MASK_CTG1		0x02	/* カートリッジコード１			*/
! #define	SMPC_MASK_CTG0		0x01	/* カートリッジコード０			*/
! #define	SMPC_MASK_DOTSEL	0x4000	/* ＤＯＴＳＥＬ信号			*/
! #define	SMPC_MASK_MSHNMI	0x0800	/* ＭＳＨＮＭＩ信号			*/
! #define	SMPC_MASK_SYSRES	0x0200	/* ＳＹＳＲＥＳ信号			*/
! #define	SMPC_MASK_SNDRES	0x0100	/* ＳＮＤＲＥＳ信号			*/
! #define	SMPC_MASK_CDRES		0x0040	/* ＣＤＲＥＳ信号			*/
! 
! #define	SMPC_SUN	(0 << 4)	/* ＲＴＣ曜日番号（日曜日）		*/
! #define	SMPC_MON	(1 << 4)	/* ＲＴＣ曜日番号（月曜日）		*/
! #define	SMPC_TUE	(2 << 4)	/* ＲＴＣ曜日番号（火曜日）		*/
! #define	SMPC_WED	(3 << 4)	/* ＲＴＣ曜日番号（水曜日）		*/
! #define	SMPC_THU	(4 << 4)	/* ＲＴＣ曜日番号（木曜日）		*/
! #define	SMPC_FRI	(5 << 4)	/* ＲＴＣ曜日番号（金曜日）		*/
! #define	SMPC_SAT	(6 << 4)	/* ＲＴＣ曜日番号（土曜日）		*/
! 
! #define	PER_RESULT_MAX		30	/* 最大ペリフェラル数			*/
! 
! #define	PER_ID_StnPad		0x02	/* サターン標準パッド			*/
! #define	PER_ID_StnLacing	0x13	/* サターンレーシングコントローラー	*/
! #define	PER_ID_StnAnalog	0x15	/* サターンアナログジョイスティック	*/
! #define	PER_ID_StnMouse		0x23	/* サターンマウス			*/
! #define	PER_ID_StnKeyBoard	0x34	/* サターンキーボード			*/
! #define	PER_ID_MD3BtnPad	0xe1	/* メガドライブ３ボタンパッド		*/
! #define	PER_ID_MD6BtnPad	0xe2	/* メガドライブ６ボタンパッド		*/
! #define	PER_ID_ShuttleMouse	0xe3	/* シャトルマウス			*/
! #define	PER_ID_ExtDigital	0x00	/* 拡張サイズデジタルデバイス		*/
! #define	PER_ID_ExtAnalog	0x10	/* 拡張サイズアナログデバイス		*/
! #define	PER_ID_ExtPointing	0x20	/* 拡張サイズポインティングデバイス	*/
! #define	PER_ID_ExtKeyBoard	0x30	/* 拡張サイズキーボードデバイス		*/
! #define	PER_ID_ExtMegaDrive	0xe0	/* 拡張サイズメガドライブデバイス	*/
! #define	PER_ID_NotConnect	0xff	/* 未接続				*/
  
! 					/* デジタルデバイス			*/
  #define	PER_DGT_KR	(1 << 15)	/* Right Key				*/
  #define	PER_DGT_KL	(1 << 14)	/*  Left Key				*/
  #define	PER_DGT_KD	(1 << 13)	/*  Down Key				*/
--- 1134,1264 ----
  #define		slSpecialCCalcBitBMN0(flag)	slSpecialCCalcBitN01(scnNBG0 , flag)
  #define		slSpecialCCalcBitBMN1(flag)	slSpecialCCalcBitN01(scnNBG1 , flag)
  #define		slSpecialCCalcBitBMR0(flag)	slSpecialCCalcBitRbg0(flag)
!     extern  void    setASC_1to8(Uint8 * , void * , Uint32 , Uint8) ;
!     extern  void    setASC_4to8(Uint8 * , void * , Uint32 , Uint8) ;
!     extern  void    setASC_1to4(Uint8 * , void * , Uint32 , Uint8 , Sint32) ;
      extern  Uint8   SGL_ASCII_CG[] ;
  
+ /*  BitMap graphics library */
+ 
+     extern  Bool    slInitBitMap(Uint16 , Uint16 , void*) ;
+ #define         slInitBitMapNbg0(sz,adr)        slInitBitMap(bmNBG0,sz,adr)
+ #define         slInitBitMapNbg1(sz,adr)        slInitBitMap(bmNBG1,sz,adr)
+ #define         slInitBitMapRbg0(sz,adr)        slInitBitMap(bmRBG0,sz,adr)
+     extern  void    slBitMapBase(Sint16 , Sint16) ;
+     extern  Sint8  *slLocateBitMap(Sint16 , Sint16) ;
+     extern  void    slClearBitMap(Sint8) ;
+     extern  Bool    slBMPset(Sint16 , Sint16 , Sint8) ;
+     extern  Sint8   slBMPoint(Sint16 , Sint16) ;
+     extern  void    slBMCircle(Sint16 , Sint16 , Sint16 , Sint8) ;
+     extern  Bool    slBMLine(Sint16 , Sint16 , Sint16 , Sint16 , Sint8) ;
+     extern  Bool    slBMBox(Sint16 , Sint16 , Sint16 , Sint16 , Sint8) ;
+     extern  Bool    slBMBoxFill(Sint16 , Sint16 , Sint16 , Sint16 , Sint8) ;
+     extern  Bool    slBMGet(Sint16 , Sint16 , Sint16 , Sint16 , Sint8*) ;
+     extern  Bool    slBMPut(Sint16 , Sint16 , Sint16 , Sint16 , Sint8*) ;
+     extern  Bool    slBMSprPut(Sint16 , Sint16 , Sint16 , Sint16 , Sint8*) ;
+ 
+ #ifdef ST_VE
+ /*  Graphics enhancer control */
+ 
+     extern  Bool gxInitEnhancer(Uint16 , Uint16 , Uint16) ;
+ #define	    EGX_IMMPAL		0	/* ｿｽpｿｽｿｽｿｽbｿｽgｿｽｿｽｿｽｿｽ */
+ #define	    EGX_PAL15		1	/* ｿｽpｿｽｿｽｿｽbｿｽgｿｽﾔ撰ｿｽ ｿｽPｿｽTｿｽrｿｽbｿｽgｿｽJｿｽｿｽｿｽ[ */
+ #define	    EGX_PAL24		2	/* ｿｽpｿｽｿｽｿｽbｿｽgｿｽﾔ撰ｿｽ ｿｽQｿｽSｿｽrｿｽbｿｽgｿｽJｿｽｿｽｿｽ[ */
+ #define	    EGX_PAL_RGB15	3	/* ｿｽpｿｽｿｽｿｽbｿｽgｿｽAｿｽqｿｽfｿｽaｿｽｿｽｿｽｿｽ ｿｽPｿｽTｿｽrｿｽbｿｽgｿｽJｿｽｿｽｿｽ[ */
+ #define	    EGX_PAL_RGB24	4	/* ｿｽpｿｽｿｽｿｽbｿｽgｿｽAｿｽqｿｽfｿｽaｿｽｿｽｿｽｿｽ ｿｽQｿｽSｿｽrｿｽbｿｽgｿｽJｿｽｿｽｿｽ[ */
+ 
+ #define	    USE_EXVDP1		0
+ #define	    USE_DSPDMA		1
+ 
+     extern  void gxFocus(FIXED , FIXED) ;
+     extern  void gxCalcMode(Uint16) ;
+ #define	    CALCNVECTOR		1	/* ｿｽ@ｿｽｿｽｿｽﾄ計ｿｽZ */
+ #define	    USENVECTOR		0	/* ｿｽ@ｿｽｿｽｿｽgｿｽp */
+ 
+ #define	    NOSHADE		2	/* ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽﾈゑｿｽ */
+ #define	    FLAT		4	/* ｿｽtｿｽｿｽｿｽbｿｽgｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽO */
+ #define	    GOURAUD		8	/* ｿｽOｿｽ[ｿｽｿｽｿｽ[ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽO */
+ 
+     extern  void gxSetMaterial(Uint16 , Uint16 , Uint16 , Uint16 , Uint16) ;
+ 
+ #define	    EFUNC_LoadTrans	0x0c0c0c0c
+ #define	    EFUNC_FlashMatrix	0x10101010
+ #define	    EFUNC_BaseMatrix	0x11111111
+ #define	    EFUNC_PushMatrix	0x12121212
+ #define	    EFUNC_PopMatrix	0x13131313
+ #define	    EFUNE_Translate	0x14141414
+ #define	    EFUNE_Scale		0x15151515
+ #define	    EFUNE_RotX		0x16161616
+ #define	    EFUNE_RotY		0x17171717
+ #define	    EFUNE_RotZ		0x18181818
+ #define	    EFUNE_MultiMatrix	0x19191919
+ #define	    EFUNC_RotLight	0x1a1a1a1a
+ 
+     extern  void gxFuncOut(Uint32) ;
+     extern  void gxFuncOut2(Uint32 , Uint32) ;
+     extern  void gxFuncOut3(Uint32 , Uint32 , Uint32 , Uint32) ;
+ #define	    gxFlashMatrix()	gxFuncOut(EFUNC_FlashMatrix)
+ #define	    gxBaseMatrix()	gxFuncOut(EFUNC_BaseMatrix)
+ #define	    gxPushMatrix()	gxFuncOut(EFUNC_PushMatrix)
+ #define	    gxPopMatrix()	gxFuncOut(EFUNC_PopMatrix)
+ #define	    gxRotLight()	gxFuncOut(EFUNC_RotLight)
+ 
+ #define	    gxLoadTrans(x,y,z)	gxFuncOut3(EFUNC_LoadTrans , x , y , z)
+ #define	    gxTranslate(x,y,z)	gxFuncOut3(EFUNC_Translate , x , y , z)
+ #define	    gxScale(x,y,z)	gxFuncOut3(EFUNC_Scale , x , y , z)
+ #define	    gxRotX(ax)		gxFuncOut2(EFUNC_RotX , ax)
+ #define	    gxRotY(ay)		gxFuncOut2(EFUNC_RotY , ay)
+ #define	    gxRotZ(az)		gxFuncOut2(EFUNC_RotZ , az)
+ 
+     extern  void gxMatrixOut(Uint32 , MATRIX) ;
+ #define	    gxLoadMatrix(mtrx)	gxMatrixOut(EFUNC_LoadMatrix , mtrx)
+ #define	    gxMultiMatrix(mtrx)	gxMatrixOut(EFUNC_MultiMatrix , mtrx)
+ 
+     extern  void gxPutPolygon(gxPDATA*) ;
+ #endif
+ 
  /*  Peripheral control */
  
! #define	SMPC_MASK_STE		0x80	/* ｿｽrｿｽdｿｽsｿｽsｿｽhｿｽlｿｽdｿｽｿｽｿｽsｿｽﾏマｿｽXｿｽN		*/
! #define	SMPC_MASK_RESD		0x40	/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽｿｽ}ｿｽXｿｽN		*/
! #define	SMPC_MASK_WEEK		0xf0	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽ}ｿｽXｿｽN			*/
! #define	SMPC_MASK_MONTH		0x0f	/* ｿｽqｿｽsｿｽbｿｽｿｽｿｽ}ｿｽXｿｽN			*/
! #define	SMPC_MASK_CTG1		0x02	/* ｿｽJｿｽ[ｿｽgｿｽｿｽｿｽbｿｽWｿｽRｿｽ[ｿｽhｿｽP			*/
! #define	SMPC_MASK_CTG0		0x01	/* ｿｽJｿｽ[ｿｽgｿｽｿｽｿｽbｿｽWｿｽRｿｽ[ｿｽhｿｽO			*/
! #define	SMPC_MASK_DOTSEL	0x4000	/* ｿｽcｿｽnｿｽsｿｽrｿｽdｿｽkｿｽMｿｽｿｽ			*/
! #define	SMPC_MASK_MSHNMI	0x0800	/* ｿｽlｿｽrｿｽgｿｽmｿｽlｿｽhｿｽMｿｽｿｽ			*/
! #define	SMPC_MASK_SYSRES	0x0200	/* ｿｽrｿｽxｿｽrｿｽqｿｽdｿｽrｿｽMｿｽｿｽ			*/
! #define	SMPC_MASK_SNDRES	0x0100	/* ｿｽrｿｽmｿｽcｿｽqｿｽdｿｽrｿｽMｿｽｿｽ			*/
! #define	SMPC_MASK_CDRES		0x0040	/* ｿｽbｿｽcｿｽqｿｽdｿｽrｿｽMｿｽｿｽ			*/
! 
! #define	SMPC_SUN	(0 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽｿｽｿｽjｿｽｿｽｿｽj		*/
! #define	SMPC_MON	(1 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽｿｽｿｽjｿｽｿｽｿｽj		*/
! #define	SMPC_TUE	(2 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽﾎ曜ｿｽｿｽｿｽj		*/
! #define	SMPC_WED	(3 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽｿｽｿｽjｿｽｿｽｿｽj		*/
! #define	SMPC_THU	(4 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽﾘ曜ｿｽｿｽｿｽj		*/
! #define	SMPC_FRI	(5 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽｿｽｿｽjｿｽｿｽｿｽj		*/
! #define	SMPC_SAT	(6 << 4)	/* ｿｽqｿｽsｿｽbｿｽjｿｽｿｽｿｽﾔ搾ｿｽｿｽiｿｽyｿｽjｿｽｿｽｿｽj		*/
! 
! #define	PER_RESULT_MAX		30	/* ｿｽﾅ托ｿｽｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽｿｽ			*/
! 
! #define	PER_ID_StnPad		0x02	/* ｿｽTｿｽ^ｿｽ[ｿｽｿｽｿｽWｿｽｿｽｿｽpｿｽbｿｽh			*/
! #define	PER_ID_StnLacing	0x13	/* ｿｽTｿｽ^ｿｽ[ｿｽｿｽｿｽｿｽｿｽ[ｿｽVｿｽｿｽｿｽOｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽ[	*/
! #define	PER_ID_StnAnalog	0x15	/* ｿｽTｿｽ^ｿｽ[ｿｽｿｽｿｽAｿｽiｿｽｿｽｿｽOｿｽWｿｽｿｽｿｽCｿｽXｿｽeｿｽBｿｽbｿｽN	*/
! #define	PER_ID_StnMouse		0x23	/* ｿｽTｿｽ^ｿｽ[ｿｽｿｽｿｽ}ｿｽEｿｽX			*/
! #define	PER_ID_StnShooting	0x25	/* ｿｽTｿｽ^ｿｽ[ｿｽｿｽｿｽVｿｽｿｽｿｽ[ｿｽeｿｽBｿｽｿｽｿｽOｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽ[ */
! #define	PER_ID_StnKeyBoard	0x34	/* ｿｽTｿｽ^ｿｽ[ｿｽｿｽｿｽLｿｽ[ｿｽ{ｿｽ[ｿｽh			*/
! #define	PER_ID_MD3BtnPad	0xe1	/* ｿｽｿｽｿｽKｿｽhｿｽｿｽｿｽCｿｽuｿｽRｿｽ{ｿｽ^ｿｽｿｽｿｽpｿｽbｿｽh		*/
! #define	PER_ID_MD6BtnPad	0xe2	/* ｿｽｿｽｿｽKｿｽhｿｽｿｽｿｽCｿｽuｿｽUｿｽ{ｿｽ^ｿｽｿｽｿｽpｿｽbｿｽh		*/
! #define	PER_ID_ShuttleMouse	0xe3	/* ｿｽVｿｽｿｽｿｽgｿｽｿｽｿｽ}ｿｽEｿｽX			*/
! #define	PER_ID_ExtDigital	0x00	/* ｿｽgｿｽｿｽｿｽTｿｽCｿｽYｿｽfｿｽWｿｽ^ｿｽｿｽｿｽfｿｽoｿｽCｿｽX		*/
! #define	PER_ID_ExtAnalog	0x10	/* ｿｽgｿｽｿｽｿｽTｿｽCｿｽYｿｽAｿｽiｿｽｿｽｿｽOｿｽfｿｽoｿｽCｿｽX		*/
! #define	PER_ID_ExtPointing	0x20	/* ｿｽgｿｽｿｽｿｽTｿｽCｿｽYｿｽ|ｿｽCｿｽｿｽｿｽeｿｽBｿｽｿｽｿｽOｿｽfｿｽoｿｽCｿｽX	*/
! #define	PER_ID_ExtKeyBoard	0x30	/* ｿｽgｿｽｿｽｿｽTｿｽCｿｽYｿｽLｿｽ[ｿｽ{ｿｽ[ｿｽhｿｽfｿｽoｿｽCｿｽX		*/
! #define	PER_ID_ExtMegaDrive	0xe0	/* ｿｽgｿｽｿｽｿｽTｿｽCｿｽYｿｽｿｽｿｽKｿｽhｿｽｿｽｿｽCｿｽuｿｽfｿｽoｿｽCｿｽX	*/
! #define	PER_ID_NotConnect	0xff	/* ｿｽｿｽｿｽﾚ托ｿｽ				*/
  
! 					/* ｿｽfｿｽWｿｽ^ｿｽｿｽｿｽfｿｽoｿｽCｿｽX			*/
  #define	PER_DGT_KR	(1 << 15)	/* Right Key				*/
  #define	PER_DGT_KL	(1 << 14)	/*  Left Key				*/
  #define	PER_DGT_KD	(1 << 13)	/*  Down Key				*/
***************
*** 997,1185 ****
  #define	PER_DGT_TZ	(1 <<  4)	/* Z Trigger				*/
  #define	PER_DGT_TL	(1 <<  3)	/* L Trigger				*/
  
! 					/* キーボードデバイス			*/
  #define	PER_KBD_CL	(1 << 6)	/* Caps Lock				*/
  #define	PER_KBD_NL	(1 << 5)	/* Num Lock				*/
  #define	PER_KBD_SL	(1 << 4)	/* Scroll Lock				*/
  #define	PER_KBD_MK	(1 << 3)	/* Make					*/
  #define	PER_KBD_BR	(1 << 0)	/* Break				*/
  
! enum SmpcSelect {			/* ＳＭＰＣ入出力セレクトモード		*/
! 	SMPC_SH2_DIRECT,		/* (00) ＳＨ２ダイレクト		*/
! 	SMPC_CONTROL			/* (01) ＳＭＰＣコントロール		*/
  };
  
! enum SmpcExtLatch {			/* ＳＭＰＣ外部ラッチ入力モード		*/
! 	SMPC_EXL_ENA,			/* (00) 外部ラッチ入力許可		*/
! 	SMPC_EXL_DIS			/* (01) 外部ラッチ入力禁止		*/
  };
  
! enum SmpcResetButton {			/* ＳＭＰＣリセットボタン状態		*/
! 	SMPC_RES_ON,			/* (00) リセットボタンＯＮ		*/
! 	SMPC_RES_OFF			/* (01) リセットボタンＯＦＦ		*/
  };
  
! enum SmpcAreaCode {			/* エリアコード				*/
! 	SMPC_AREA_RSV_0,		/* (00) 使用禁止			*/
! 	SMPC_AREA_JP,			/* (01) 日本地域			*/
! 	SMPC_AREA_AJ_NTSC,		/* (02) アジアＮＴＳＣ地域		*/
! 	SMPC_AREA_RSV_3,		/* (03) 使用禁止			*/
! 	SMPC_AREA_NA,			/* (04) 北米地域			*/
! 	SMPC_AREA_SA_NTSC,		/* (05) 中南米ＮＴＳＣ地域		*/
! 	SMPC_AREA_KO,			/* (06) 韓国地域			*/
! 	SMPC_AREA_RSV_7,		/* (07) 使用禁止			*/
! 	SMPC_AREA_RSV_8,		/* (08) 使用禁止			*/
! 	SMPC_AREA_RSV_9,		/* (09) 使用禁止			*/
! 	SMPC_AREA_AJ_PAL,		/* (0a) アジアＰＡＬ地域		*/
! 	SMPC_AREA_RSV_B,		/* (0b) 使用禁止			*/
! 	SMPC_AREA_EU_PAL,		/* (0c) ヨーロッパＰＡＬ地域		*/
! 	SMPC_AREA_SA_PAL,		/* (0d) 中南米ＰＡＬ地域		*/
! 	SMPC_AREA_RSV_E,		/* (0e) 使用禁止			*/
! 	SMPC_AREA_RSV_F			/* (0f) 使用禁止			*/
  };
  
! enum SmpcOptimize {			/* 取得時間最適化モード			*/
! 	SMPC_OPT_DIS,			/* (00) 取得時間最適化禁止		*/
! 	SMPC_OPT_ENA			/* (01) 取得時間最適化許可		*/
  };
  
! enum SmpcPortMode {			/* ＳＭＰＣポートモード			*/
! 	SMPC_PORT_15,			/* (00) １５バイトモード		*/
! 	SMPC_PORT_255,			/* (01) ２５５バイトモード		*/
! 	SMPC_PORT_RSV,			/* (02) 設定禁止			*/
! 	SMPC_PORT_ZERO			/* (03) ０バイトモード			*/
  };
  
! enum SmpcLanguage {			/* ＳＭＰＣメモリ言語番号		*/
! 	SMPC_ENGLISH,			/* (00) 英語				*/
! 	SMPC_DEUTSCH,			/* (01) ドイツ語			*/
! 	SMPC_FRANCAIS,			/* (02) フランス語			*/
! 	SMPC_ESPANOL,			/* (03) スペイン語			*/
! 	SMPC_ITALIANO,			/* (04) イタリア語			*/
! 	SMPC_JAPAN			/* (05) 日本語				*/
  };
  
! enum SmpcSoundEffect {			/* ＳＭＰＣメモリ効果音モード		*/
! 	SMPC_EFFECT_OFF,		/* (00) 効果音ＯＦＦ			*/
! 	SMPC_EFFECT_ON			/* (01) 効果音ＯＮ			*/
  };
  
! enum SmpcSoundOutput {			/* ＳＭＰＣメモリ音声出力モード		*/
! 	SMPC_SOUND_MONO,		/* (00) モノラル			*/
! 	SMPC_SOUND_STEREO		/* (01) ステレオ			*/
  };
  
! enum SmpcHelpWindow {			/* ＳＭＰＣメモリヘルプウィンドウモード	*/
! 	SMPC_HELP_DIS,			/* (00) 表示しない			*/
! 	SMPC_HELP_ENA			/* (01) 表示する			*/
  };
  
! enum SmpcMonth {			/* ＲＴＣ月番号				*/
! 	SMPC_DMY,			/* (00) ダミー				*/
! 	SMPC_JAN,			/* (01) 　１月				*/
! 	SMPC_FEB,			/* (02) 　２月				*/
! 	SMPC_MAR,			/* (03) 　３月				*/
! 	SMPC_APR,			/* (04) 　４月				*/
! 	SMPC_MAY,			/* (05) 　５月				*/
! 	SMPC_JUN,			/* (06) 　６月				*/
! 	SMPC_JUL,			/* (07) 　７月				*/
! 	SMPC_AUG,			/* (08) 　８月				*/
! 	SMPC_SEP,			/* (09) 　９月				*/
! 	SMPC_OCT,			/* (0a) １０月				*/
! 	SMPC_NOV,			/* (0b) １１月				*/
! 	SMPC_DEC			/* (0c) １２月				*/
  };
  
! enum SmpcCommand {			/* ＳＭＰＣコマンド番号			*/
! 	SMPC_MSHON,			/* (00) マスタ　ＳＨ２　ＯＮ		*/
! 	SMPC_SSHON,			/* (01) スレーブ　ＳＨ２　ＯＮ		*/
! 	SMPC_SSHOFF,			/* (02) スレーブ　ＳＨ２　ＯＦＦ	*/
! 	SMPC_SNDON,			/* (03) サウンド　ＯＮ			*/
! 	SMPC_SNDOFF,			/* (04) サウンド　ＯＦＦ		*/
! 	SMPC_CDON,			/* (05) ＣＤ　ＯＮ			*/
! 	SMPC_CDOFF,			/* (06) ＣＤ　ＯＦＦ			*/
! 	SMPC_SYSRES,			/* (07) システム全体リセット		*/
! 	SMPC_CKC352,			/* (08) クロックチェンジ３５２モード	*/
! 	SMPC_CKC320,			/* (09) クロックチェンジ３２０モード	*/
! 	SMPC_NMIREQ,			/* (0a) ＮＭＩリクエスト		*/
! 	SMPC_RESENA,			/* (0b) リセットイネーブル		*/
! 	SMPC_RESDIS,			/* (0c) リセットディスエーブル		*/
! 	SMPC_GETSTS,			/* (0d) ステータス取得			*/
! 	SMPC_GETPER,			/* (0e) ペリフェラル取得		*/
! 	SMPC_SETMEM,			/* (0f) ＳＭＰＣメモリ設定		*/
! 	SMPC_SETTIM,			/* (10) 時刻設定			*/
! 	SMPC_CMDMAX			/* (11) コマンド番号最大値		*/
  };
  
! enum SmpcWaitMode {			/* ＳＭＰＣコマンド実行モード		*/
! 	SMPC_NO_WAIT,			/* (00) コマンド実行終了待ち無し	*/
! 	SMPC_WAIT			/* (01) コマンド実行終了待ち有り	*/
  };
  
! typedef struct {			/* ＲＴＣ時刻				*/
! 	Uint16	year;			/* 西暦年号				*/
! 	Uint8	month;			/* 曜日・月				*/
! 	Uint8	date;			/* 日					*/
! 	Uint8	hour;			/* 時					*/
! 	Uint8	minute;			/* 分					*/
! 	Uint8	second;			/* 秒					*/
! 	Uint8	dummy;			/* ダミー				*/
  } SmpcDateTime;
  
! typedef struct {			/* ＳＭＰＣステータス			*/
! 	Uint8	cond;			/* 状態ステータス			*/
! 	Uint8	dummy1;			/* ダミー１				*/
! 	Uint16	dummy2;			/* ダミー２				*/
! 	SmpcDateTime	rtc;		/* ＲＴＣ時刻				*/
! 	Uint8	ctg;			/* カートリッジコード			*/
! 	Uint8	area;			/* エリアコード				*/
! 	Uint16	system;			/* システムステータス			*/
! 	Uint32	smem;			/* ＳＭＰＣメモリ保持データ		*/
  } SmpcStatus;
  
! typedef struct {			/* デジタルデバイス			*/
! 	Uint8	id;			/* ペリフェラルＩＤ			*/
! 	Uint8	ext;			/* 拡張データサイズ			*/
! 	Uint16	data;			/* ボタン現在データ			*/
! 	Uint16	push;			/* ボタン押下データ			*/
! 	Uint16	pull;			/* ボタン引上データ			*/
! 	Uint32	dummy2[4];		/* ダミー２				*/
  } PerDigital;
  
! typedef struct {			/* アナログデバイス			*/
! 	Uint8	id;			/* ペリフェラルＩＤ			*/
! 	Uint8	ext;			/* 拡張データサイズ			*/
! 	Uint16	data;			/* ボタン現在データ			*/
! 	Uint16	push;			/* ボタン押下データ			*/
! 	Uint16	pull;			/* ボタン引上データ			*/
! 	Uint8	x;			/* Ｘ軸データ絶対値			*/
! 	Uint8	y;			/* Ｙ軸データ絶対値			*/
! 	Uint8	z;			/* Ｚ軸データ絶対値			*/
! 	Uint8	dummy1;			/* ダミー１				*/
! 	Uint32	dummy2[3];		/* ダミー２				*/
  } PerAnalog;
  
! typedef struct {			/* ポインティングデバイス		*/
! 	Uint8	id;			/* ペリフェラルＩＤ			*/
! 	Uint8	ext;			/* 拡張データサイズ			*/
! 	Uint16	data;			/* ボタン現在データ			*/
! 	Uint16	push;			/* ボタン押下データ			*/
! 	Uint16	pull;			/* ボタン引上データ			*/
! 	Uint16	x;			/* Ｘ座標				*/
! 	Uint16	y;			/* Ｙ座標				*/
! 	Uint32	dummy2[3];		/* ダミー２				*/
  } PerPoint;
  
! typedef struct {			/* キーボードデバイス			*/
! 	Uint8	id;			/* ペリフェラルＩＤ			*/
! 	Uint8	ext;			/* 拡張データサイズ			*/
! 	Uint16	data;			/* ボタン現在データ			*/
! 	Uint16	push;			/* ボタン押下データ			*/
! 	Uint16	pull;			/* ボタン引上データ			*/
! 	Uint8	cond;			/* 状態データ				*/
! 	Uint8	code;			/* キーコード				*/
! 	Uint16	dummy1;			/* ダミー１				*/
! 	Uint32	dummy2[3];		/* ダミー２				*/
  } PerKeyBoard;
  
  extern	Uint8	slGetPortDir1(void);
--- 1273,1461 ----
  #define	PER_DGT_TZ	(1 <<  4)	/* Z Trigger				*/
  #define	PER_DGT_TL	(1 <<  3)	/* L Trigger				*/
  
! 					/* ｿｽLｿｽ[ｿｽ{ｿｽ[ｿｽhｿｽfｿｽoｿｽCｿｽX			*/
  #define	PER_KBD_CL	(1 << 6)	/* Caps Lock				*/
  #define	PER_KBD_NL	(1 << 5)	/* Num Lock				*/
  #define	PER_KBD_SL	(1 << 4)	/* Scroll Lock				*/
  #define	PER_KBD_MK	(1 << 3)	/* Make					*/
  #define	PER_KBD_BR	(1 << 0)	/* Break				*/
  
! enum SmpcSelect {			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽoｿｽﾍセｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽ[ｿｽh		*/
! 	SMPC_SH2_DIRECT,		/* (00) ｿｽrｿｽgｿｽQｿｽ_ｿｽCｿｽｿｽｿｽNｿｽg		*/
! 	SMPC_CONTROL			/* (01) ｿｽrｿｽlｿｽoｿｽbｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽ		*/
  };
  
! enum SmpcExtLatch {			/* ｿｽrｿｽlｿｽoｿｽbｿｽOｿｽｿｽｿｽｿｽｿｽbｿｽ`ｿｽｿｽｿｽﾍｿｽｿｽ[ｿｽh		*/
! 	SMPC_EXL_ENA,			/* (00) ｿｽOｿｽｿｽｿｽｿｽｿｽbｿｽ`ｿｽｿｽｿｽﾍ具ｿｽｿｽｿｽ		*/
! 	SMPC_EXL_DIS			/* (01) ｿｽOｿｽｿｽｿｽｿｽｿｽbｿｽ`ｿｽｿｽｿｽﾍ禁止		*/
  };
  
! enum SmpcResetButton {			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽ		*/
! 	SMPC_RES_ON,			/* (00) ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽnｿｽm		*/
! 	SMPC_RES_OFF			/* (01) ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽnｿｽeｿｽe		*/
  };
  
! enum SmpcAreaCode {			/* ｿｽGｿｽｿｽｿｽAｿｽRｿｽ[ｿｽh				*/
! 	SMPC_AREA_RSV_0,		/* (00) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_JP,			/* (01) ｿｽｿｽｿｽ{ｿｽnｿｽｿｽ			*/
! 	SMPC_AREA_AJ_NTSC,		/* (02) ｿｽAｿｽWｿｽAｿｽmｿｽsｿｽrｿｽbｿｽnｿｽｿｽ		*/
! 	SMPC_AREA_RSV_3,		/* (03) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_NA,			/* (04) ｿｽkｿｽﾄ地ｿｽｿｽ			*/
! 	SMPC_AREA_SA_NTSC,		/* (05) ｿｽｿｽｿｽｿｽｿｽﾄＮｿｽsｿｽrｿｽbｿｽnｿｽｿｽ		*/
! 	SMPC_AREA_KO,			/* (06) ｿｽﾘ搾ｿｽｿｽnｿｽｿｽ			*/
! 	SMPC_AREA_RSV_7,		/* (07) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_RSV_8,		/* (08) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_RSV_9,		/* (09) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_AJ_PAL,		/* (0a) ｿｽAｿｽWｿｽAｿｽoｿｽ`ｿｽkｿｽnｿｽｿｽ		*/
! 	SMPC_AREA_RSV_B,		/* (0b) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_EU_PAL,		/* (0c) ｿｽｿｽｿｽ[ｿｽｿｽｿｽbｿｽpｿｽoｿｽ`ｿｽkｿｽnｿｽｿｽ		*/
! 	SMPC_AREA_SA_PAL,		/* (0d) ｿｽｿｽｿｽｿｽｿｽﾄＰｿｽ`ｿｽkｿｽnｿｽｿｽ		*/
! 	SMPC_AREA_RSV_E,		/* (0e) ｿｽgｿｽpｿｽﾖ止			*/
! 	SMPC_AREA_RSV_F			/* (0f) ｿｽgｿｽpｿｽﾖ止			*/
  };
  
! enum SmpcOptimize {			/* ｿｽ謫ｾｿｽｿｽｿｽﾔ最適ｿｽｿｽｿｽｿｽｿｽ[ｿｽh			*/
! 	SMPC_OPT_DIS,			/* (00) ｿｽ謫ｾｿｽｿｽｿｽﾔ最適ｿｽｿｽｿｽﾖ止		*/
! 	SMPC_OPT_ENA			/* (01) ｿｽ謫ｾｿｽｿｽｿｽﾔ最適ｿｽｿｽｿｽｿｽｿｽｿｽ		*/
  };
  
! enum SmpcPortMode {			/* ｿｽrｿｽlｿｽoｿｽbｿｽ|ｿｽ[ｿｽgｿｽｿｽｿｽ[ｿｽh			*/
! 	SMPC_PORT_15,			/* (00) ｿｽPｿｽTｿｽoｿｽCｿｽgｿｽｿｽｿｽ[ｿｽh		*/
! 	SMPC_PORT_255,			/* (01) ｿｽQｿｽTｿｽTｿｽoｿｽCｿｽgｿｽｿｽｿｽ[ｿｽh		*/
! 	SMPC_PORT_RSV,			/* (02) ｿｽﾝ抵ｿｽｿｽﾖ止			*/
! 	SMPC_PORT_ZERO			/* (03) ｿｽOｿｽoｿｽCｿｽgｿｽｿｽｿｽ[ｿｽh			*/
  };
  
! enum SmpcLanguage {			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾔ搾ｿｽ		*/
! 	SMPC_ENGLISH,			/* (00) ｿｽpｿｽｿｽ				*/
! 	SMPC_DEUTSCH,			/* (01) ｿｽhｿｽCｿｽcｿｽｿｽ			*/
! 	SMPC_FRANCAIS,			/* (02) ｿｽtｿｽｿｽｿｽｿｽｿｽXｿｽｿｽ			*/
! 	SMPC_ESPANOL,			/* (03) ｿｽXｿｽyｿｽCｿｽｿｽｿｽｿｽ			*/
! 	SMPC_ITALIANO,			/* (04) ｿｽCｿｽ^ｿｽｿｽｿｽAｿｽｿｽ			*/
! 	SMPC_JAPAN			/* (05) ｿｽｿｽｿｽ{ｿｽｿｽ				*/
  };
  
! enum SmpcSoundEffect {			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾊ会ｿｽｿｽｿｽｿｽ[ｿｽh		*/
! 	SMPC_EFFECT_OFF,		/* (00) ｿｽｿｽｿｽﾊ会ｿｽｿｽnｿｽeｿｽe			*/
! 	SMPC_EFFECT_ON			/* (01) ｿｽｿｽｿｽﾊ会ｿｽｿｽnｿｽm			*/
  };
  
! enum SmpcSoundOutput {			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽoｿｽﾍｿｽｿｽ[ｿｽh		*/
! 	SMPC_SOUND_MONO,		/* (00) ｿｽｿｽｿｽmｿｽｿｽｿｽｿｽ			*/
! 	SMPC_SOUND_STEREO		/* (01) ｿｽXｿｽeｿｽｿｽｿｽI			*/
  };
  
! enum SmpcHelpWindow {			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽｿｽｿｽｿｽｿｽwｿｽｿｽｿｽvｿｽEｿｽBｿｽｿｽｿｽhｿｽEｿｽｿｽｿｽ[ｿｽh	*/
! 	SMPC_HELP_DIS,			/* (00) ｿｽ\ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ			*/
! 	SMPC_HELP_ENA			/* (01) ｿｽ\ｿｽｿｽｿｽｿｽｿｽｿｽ			*/
  };
  
! enum SmpcMonth {			/* ｿｽqｿｽsｿｽbｿｽｿｽｿｽﾔ搾ｿｽ				*/
! 	SMPC_DMY,			/* (00) ｿｽ_ｿｽ~ｿｽ[				*/
! 	SMPC_JAN,			/* (01) ｿｽ@ｿｽPｿｽｿｽ				*/
! 	SMPC_FEB,			/* (02) ｿｽ@ｿｽQｿｽｿｽ				*/
! 	SMPC_MAR,			/* (03) ｿｽ@ｿｽRｿｽｿｽ				*/
! 	SMPC_APR,			/* (04) ｿｽ@ｿｽSｿｽｿｽ				*/
! 	SMPC_MAY,			/* (05) ｿｽ@ｿｽTｿｽｿｽ				*/
! 	SMPC_JUN,			/* (06) ｿｽ@ｿｽUｿｽｿｽ				*/
! 	SMPC_JUL,			/* (07) ｿｽ@ｿｽVｿｽｿｽ				*/
! 	SMPC_AUG,			/* (08) ｿｽ@ｿｽWｿｽｿｽ				*/
! 	SMPC_SEP,			/* (09) ｿｽ@ｿｽXｿｽｿｽ				*/
! 	SMPC_OCT,			/* (0a) ｿｽPｿｽOｿｽｿｽ				*/
! 	SMPC_NOV,			/* (0b) ｿｽPｿｽPｿｽｿｽ				*/
! 	SMPC_DEC			/* (0c) ｿｽPｿｽQｿｽｿｽ				*/
  };
  
! enum SmpcCommand {			/* ｿｽrｿｽlｿｽoｿｽbｿｽRｿｽ}ｿｽｿｽｿｽhｿｽﾔ搾ｿｽ			*/
! 	SMPC_MSHON,			/* (00) ｿｽ}ｿｽXｿｽ^ｿｽ@ｿｽrｿｽgｿｽQｿｽ@ｿｽnｿｽm		*/
! 	SMPC_SSHON,			/* (01) ｿｽXｿｽｿｽｿｽ[ｿｽuｿｽ@ｿｽrｿｽgｿｽQｿｽ@ｿｽnｿｽm		*/
! 	SMPC_SSHOFF,			/* (02) ｿｽXｿｽｿｽｿｽ[ｿｽuｿｽ@ｿｽrｿｽgｿｽQｿｽ@ｿｽnｿｽeｿｽe	*/
! 	SMPC_SNDON,			/* (03) ｿｽTｿｽEｿｽｿｽｿｽhｿｽ@ｿｽnｿｽm			*/
! 	SMPC_SNDOFF,			/* (04) ｿｽTｿｽEｿｽｿｽｿｽhｿｽ@ｿｽnｿｽeｿｽe		*/
! 	SMPC_CDON,			/* (05) ｿｽbｿｽcｿｽ@ｿｽnｿｽm			*/
! 	SMPC_CDOFF,			/* (06) ｿｽbｿｽcｿｽ@ｿｽnｿｽeｿｽe			*/
! 	SMPC_SYSRES,			/* (07) ｿｽVｿｽXｿｽeｿｽｿｽｿｽSｿｽﾌｿｽｿｽZｿｽbｿｽg		*/
! 	SMPC_CKC352,			/* (08) ｿｽNｿｽｿｽｿｽbｿｽNｿｽ`ｿｽFｿｽｿｽｿｽWｿｽRｿｽTｿｽQｿｽｿｽｿｽ[ｿｽh	*/
! 	SMPC_CKC320,			/* (09) ｿｽNｿｽｿｽｿｽbｿｽNｿｽ`ｿｽFｿｽｿｽｿｽWｿｽRｿｽQｿｽOｿｽｿｽｿｽ[ｿｽh	*/
! 	SMPC_NMIREQ,			/* (0a) ｿｽmｿｽlｿｽhｿｽｿｽｿｽNｿｽGｿｽXｿｽg		*/
! 	SMPC_RESENA,			/* (0b) ｿｽｿｽｿｽZｿｽbｿｽgｿｽCｿｽlｿｽ[ｿｽuｿｽｿｽ		*/
! 	SMPC_RESDIS,			/* (0c) ｿｽｿｽｿｽZｿｽbｿｽgｿｽfｿｽBｿｽXｿｽGｿｽ[ｿｽuｿｽｿｽ		*/
! 	SMPC_GETSTS,			/* (0d) ｿｽXｿｽeｿｽ[ｿｽ^ｿｽXｿｽ謫ｾ			*/
! 	SMPC_GETPER,			/* (0e) ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽ謫ｾ		*/
! 	SMPC_SETMEM,			/* (0f) ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾝ抵ｿｽ		*/
! 	SMPC_SETTIM,			/* (10) ｿｽｿｽｿｽｿｽｿｽﾝ抵ｿｽ			*/
! 	SMPC_CMDMAX			/* (11) ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽﾔ搾ｿｽｿｽﾅ托ｿｽｿｽl		*/
  };
  
! enum SmpcWaitMode {			/* ｿｽrｿｽlｿｽoｿｽbｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽ[ｿｽh		*/
! 	SMPC_NO_WAIT,			/* (00) ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽIｿｽｿｽｿｽﾒゑｿｽｿｽｿｽｿｽｿｽ	*/
! 	SMPC_WAIT			/* (01) ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽIｿｽｿｽｿｽﾒゑｿｽｿｽLｿｽｿｽ	*/
  };
  
! typedef struct {			/* ｿｽqｿｽsｿｽbｿｽｿｽｿｽｿｽ				*/
! 	Uint16	year;			/* ｿｽｿｽｿｽｿｽｿｽNｿｽｿｽ				*/
! 	Uint8	month;			/* ｿｽjｿｽｿｽｿｽEｿｽｿｽ				*/
! 	Uint8	date;			/* ｿｽｿｽ					*/
! 	Uint8	hour;			/* ｿｽｿｽ					*/
! 	Uint8	minute;			/* ｿｽｿｽ					*/
! 	Uint8	second;			/* ｿｽb					*/
! 	Uint8	dummy;			/* ｿｽ_ｿｽ~ｿｽ[				*/
  } SmpcDateTime;
  
! typedef struct {			/* ｿｽrｿｽlｿｽoｿｽbｿｽXｿｽeｿｽ[ｿｽ^ｿｽX			*/
! 	Uint8	cond;			/* ｿｽｿｽｿｽﾔスｿｽeｿｽ[ｿｽ^ｿｽX			*/
! 	Uint8	dummy1;			/* ｿｽ_ｿｽ~ｿｽ[ｿｽP				*/
! 	Uint16	dummy2;			/* ｿｽ_ｿｽ~ｿｽ[ｿｽQ				*/
! 	SmpcDateTime	rtc;		/* ｿｽqｿｽsｿｽbｿｽｿｽｿｽｿｽ				*/
! 	Uint8	ctg;			/* ｿｽJｿｽ[ｿｽgｿｽｿｽｿｽbｿｽWｿｽRｿｽ[ｿｽh			*/
! 	Uint8	area;			/* ｿｽGｿｽｿｽｿｽAｿｽRｿｽ[ｿｽh				*/
! 	Uint16	system;			/* ｿｽVｿｽXｿｽeｿｽｿｽｿｽXｿｽeｿｽ[ｿｽ^ｿｽX			*/
! 	Uint32	smem;			/* ｿｽrｿｽlｿｽoｿｽbｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾛ趣ｿｽｿｽfｿｽ[ｿｽ^		*/
  } SmpcStatus;
  
! typedef struct {			/* ｿｽfｿｽWｿｽ^ｿｽｿｽｿｽfｿｽoｿｽCｿｽX			*/
! 	Uint8	id;			/* ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽhｿｽc			*/
! 	Uint8	ext;			/* ｿｽgｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽTｿｽCｿｽY			*/
! 	Uint16	data;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝデｿｽ[ｿｽ^			*/
! 	Uint16	push;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint16	pull;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint32	dummy2[4];		/* ｿｽ_ｿｽ~ｿｽ[ｿｽQ				*/
  } PerDigital;
  
! typedef struct {			/* ｿｽAｿｽiｿｽｿｽｿｽOｿｽfｿｽoｿｽCｿｽX			*/
! 	Uint8	id;			/* ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽhｿｽc			*/
! 	Uint8	ext;			/* ｿｽgｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽTｿｽCｿｽY			*/
! 	Uint16	data;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝデｿｽ[ｿｽ^			*/
! 	Uint16	push;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint16	pull;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint8	x;			/* ｿｽwｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽﾎ値			*/
! 	Uint8	y;			/* ｿｽxｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽﾎ値			*/
! 	Uint8	z;			/* ｿｽyｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽﾎ値			*/
! 	Uint8	dummy1;			/* ｿｽ_ｿｽ~ｿｽ[ｿｽP				*/
! 	Uint32	dummy2[3];		/* ｿｽ_ｿｽ~ｿｽ[ｿｽQ				*/
  } PerAnalog;
  
! typedef struct {			/* ｿｽ|ｿｽCｿｽｿｽｿｽeｿｽBｿｽｿｽｿｽOｿｽfｿｽoｿｽCｿｽX		*/
! 	Uint8	id;			/* ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽhｿｽc			*/
! 	Uint8	ext;			/* ｿｽgｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽTｿｽCｿｽY			*/
! 	Uint16	data;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝデｿｽ[ｿｽ^			*/
! 	Uint16	push;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint16	pull;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint16	x;			/* ｿｽwｿｽｿｽｿｽW				*/
! 	Uint16	y;			/* ｿｽxｿｽｿｽｿｽW				*/
! 	Uint32	dummy2[3];		/* ｿｽ_ｿｽ~ｿｽ[ｿｽQ				*/
  } PerPoint;
  
! typedef struct {			/* ｿｽLｿｽ[ｿｽ{ｿｽ[ｿｽhｿｽfｿｽoｿｽCｿｽX			*/
! 	Uint8	id;			/* ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽhｿｽc			*/
! 	Uint8	ext;			/* ｿｽgｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽTｿｽCｿｽY			*/
! 	Uint16	data;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝデｿｽ[ｿｽ^			*/
! 	Uint16	push;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint16	pull;			/* ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽfｿｽ[ｿｽ^			*/
! 	Uint8	cond;			/* ｿｽｿｽｿｽﾔデｿｽ[ｿｽ^				*/
! 	Uint8	code;			/* ｿｽLｿｽ[ｿｽRｿｽ[ｿｽh				*/
! 	Uint16	dummy1;			/* ｿｽ_ｿｽ~ｿｽ[ｿｽP				*/
! 	Uint32	dummy2[3];		/* ｿｽ_ｿｽ~ｿｽ[ｿｽQ				*/
  } PerKeyBoard;
  
  extern	Uint8	slGetPortDir1(void);
***************
*** 1231,1245 ****
  
  extern	Bool	slRequestCommand(Uint8, Uint8);
  
  extern	SmpcStatus*	Smpc_Status;
  extern	PerDigital*	Smpc_Peripheral;
  extern	Uint8		Per_Connect1, Per_Connect2;
  
  #define	slMasterOn()			slRequestCommand(SMPC_MSHON , SMPC_NO_WAIT)
  #define	slSlaveOn()			slRequestCommand(SMPC_SSHON , SMPC_NO_WAIT)
  #define	slSlaveOff()			slRequestCommand(SMPC_SSHOFF, SMPC_NO_WAIT)
! #define	slSoundOn()			slRequestCommand(SMPC_SNDON , SMPC_NO_WAIT)
! #define	slSoundOff()			slRequestCommand(SMPC_SNDOFF, SMPC_NO_WAIT)
  #define	slCDOn()			slRequestCommand(SMPC_CDON  , SMPC_NO_WAIT)
  #define	slCDOff()			slRequestCommand(SMPC_CDOFF , SMPC_NO_WAIT)
  #define	slSystemReset()			slRequestCommand(SMPC_SYSRES, SMPC_NO_WAIT)
--- 1507,1558 ----
  
  extern	Bool	slRequestCommand(Uint8, Uint8);
  
+ extern  Bool slCheckIntBackSet(void);
+ 
  extern	SmpcStatus*	Smpc_Status;
  extern	PerDigital*	Smpc_Peripheral;
  extern	Uint8		Per_Connect1, Per_Connect2;
  
+ #ifdef  TITAN
+ typedef struct {                        /* System Switch */
+         Uint8   dummy ;
+         Uint8   data ;
+         Uint8   push ;
+         Uint8   pull ;
+ } SysSwitch ;
+ 
+     extern  PerDigital  PerDigitalBuf[4] ;
+     extern  SysSwitch   SystemSwitchBuf ;
+ 
+ #define     _ServiceSw          0x80    /* ｿｽｿｽｿｽﾕ擾ｿｽｿｽﾌスｿｽCｿｽbｿｽ`ｿｽﾆＪｿｽ`ｿｽlｿｽlｿｽ`ｿｽｿｽｿｽﾍゑｿｽ ｿｽnｿｽqｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
+ #define     _TestSw             0x40
+ #define     _ServiceSwBD        0x20    /* ｿｽｿｽｿｽﾕ擾ｿｽｿｽﾌタｿｽNｿｽgｿｽXｿｽCｿｽbｿｽ` */
+ #define     _TestSwBD           0x10
+ #define     _ServiceSwJM        0x08    /* ｿｽiｿｽ`ｿｽlｿｽlｿｽ`ｿｽRｿｽlｿｽNｿｽ^ｿｽｿｽｿｽｿｽｿｽﾌスｿｽCｿｽbｿｽ`ｿｽｿｽｿｽｿｽ */
+ #define     _TestSwJM           0x04
+ #define     _Coin2              0x02
+ #define     _Coin1              0x01
+ #endif
+ 
+ #ifdef  ST_V
+     extern  PerDigital	PerDigitalBuf[4] ;
+ #endif
+ #ifdef  ST_VE
+     extern  PerDigital	PerDigitalBuf[4] ;
+ #endif
+ 
  #define	slMasterOn()			slRequestCommand(SMPC_MSHON , SMPC_NO_WAIT)
  #define	slSlaveOn()			slRequestCommand(SMPC_SSHON , SMPC_NO_WAIT)
  #define	slSlaveOff()			slRequestCommand(SMPC_SSHOFF, SMPC_NO_WAIT)
! 
! #ifdef TITAN
!     extern void slSoundOn() ;
!     extern void slSoundOff() ;
! #else
! #define	slSoundOn()		slRequestCommand(SMPC_SNDON , SMPC_NO_WAIT)
! #define	slSoundOff()		slRequestCommand(SMPC_SNDOFF, SMPC_NO_WAIT)
! #endif
! 
  #define	slCDOn()			slRequestCommand(SMPC_CDON  , SMPC_NO_WAIT)
  #define	slCDOff()			slRequestCommand(SMPC_CDOFF , SMPC_NO_WAIT)
  #define	slSystemReset()			slRequestCommand(SMPC_SYSRES, SMPC_NO_WAIT)
***************
*** 1289,1299 ****
      extern void    slSlaveFunc(void (*func)() , void *) ;
  
  /*  System library */
!     extern  void   slInitSystem(Uint16 , TEXTURE * , Uint16) ;
      extern  void   slSynch(void) ;
      extern  void   slInitSynch(void) ;
      extern  Bool   slTransferEntry(void * , void * , Uint16) ;
      extern  void   slIntFunction(void (*func)()) ;
      extern  void   SetCDFunc(void (*func)()) ;
      extern  void   slSetTrayCheck(Uint8) ;
      extern  void   slCashPurge() ;
--- 1602,1617 ----
      extern void    slSlaveFunc(void (*func)() , void *) ;
  
  /*  System library */
!     extern  void   slInitSystem(Uint16 , TEXTURE * , Sint8) ;
!     extern  void   slSetTVMode(Uint16) ;
!     extern  void   slSetScrTVMode(Uint16) ;
!     extern  void   slSetSprTVMode(Uint16) ;
!     extern  Bool   slDynamicFrame(Uint16) ;
      extern  void   slSynch(void) ;
      extern  void   slInitSynch(void) ;
      extern  Bool   slTransferEntry(void * , void * , Uint16) ;
      extern  void   slIntFunction(void (*func)()) ;
+     extern  void   slSynchFunction(void (*func)()) ;
      extern  void   SetCDFunc(void (*func)()) ;
      extern  void   slSetTrayCheck(Uint8) ;
      extern  void   slCashPurge() ;
***************
*** 1306,1312 ****
      extern  Bool   slBGMOff() ;
      extern  Bool   slBGMFade(Uint8 , Uint8) ;
      extern  Bool   slBGMTempo(Sint16) ;
! #define	    slBGMStat()		slSequenceStat(0)
      extern  Bool   slSoundAllOff() ;
      extern  Bool   slSoundAllPause() ;
      extern  Bool   slSoundAllCont() ;
--- 1624,1630 ----
      extern  Bool   slBGMOff() ;
      extern  Bool   slBGMFade(Uint8 , Uint8) ;
      extern  Bool   slBGMTempo(Sint16) ;
! #define     slBGMStat()    slSequenceStat(0)
      extern  Bool   slSoundAllOff() ;
      extern  Bool   slSoundAllPause() ;
      extern  Bool   slSoundAllCont() ;
***************
*** 1325,1345 ****
      extern  void   slWaitSound(void *) ;
      extern  Bool   slCDDAOn(Uint8 , Uint8 , Sint8 , Sint8) ;
      extern  Bool   slCDDAOff() ;
!     extern  Uint8  slPCMOn(PCM * , void * , Uint32) ;
      extern  Bool   slPCMOff(PCM *) ;
      extern  Bool   slPCMParmChange(PCM *) ;
      extern  Bool   slPCMStat(PCM *) ;
!     extern  Uint8  slSndPCMNum() ;
      extern  Uint8  slSndSeqNum() ;
      extern  Bool   slSndEffect(Uint8) ;
      extern  Bool   slSndMixChange(Uint8 , Uint8) ;
      extern  Bool   slSndMixParmChange(Uint8 , Uint8 , Sint8) ;
      extern  Sint8  slSoundRequest(const char*,...) ;
  
!     extern  Uint8  sddrv_129i[] ;
!     extern  Uint32 sizeof_129i ;
  
  /*------------------------------------------------------------------------*/
  
! #endif  /* SL_DEF_H */
! 
\ No newline at end of file
--- 1643,1680 ----
      extern  void   slWaitSound(void *) ;
      extern  Bool   slCDDAOn(Uint8 , Uint8 , Sint8 , Sint8) ;
      extern  Bool   slCDDAOff() ;
!     extern  Sint8  slPCMOn(PCM * , void * , Uint32) ;
      extern  Bool   slPCMOff(PCM *) ;
      extern  Bool   slPCMParmChange(PCM *) ;
      extern  Bool   slPCMStat(PCM *) ;
!     extern  Sint8  slSndPCMNum() ;
      extern  Uint8  slSndSeqNum() ;
      extern  Bool   slSndEffect(Uint8) ;
      extern  Bool   slSndMixChange(Uint8 , Uint8) ;
      extern  Bool   slSndMixParmChange(Uint8 , Uint8 , Sint8) ;
      extern  Sint8  slSoundRequest(const char*,...) ;
+     extern  void   slSndFlush() ;
+ 
+ /*  Gouraud library */
+ 
+     typedef Uint16 GOURAUDTBL[4];
+ 
+     extern  void slInitGouraud( GOURAUDTBL *, Uint32, Uint32, Uint8 *);
+     extern  void slPutPolygonX( XPDATA *, FIXED *);
+     extern  void slGouraudTblCopy(void);
+     extern  void slSetGouraudTbl( Uint16 *);
+     extern  void slSetGouraudColor( Uint16 );
+     extern  void slSetAmbient( Uint16);
+ 
+     extern  void slSetFlatColor( Uint16);
+ 
+     extern  void slSetDepthLimit( Uint32, Uint16, Uint16 );
+     extern  void slSetDepthTbl( Uint16 *, Uint16, Uint16 );
  
!     extern  void slNearClipFlag( Uint32 );
!     extern  void slDispPlaneLevel( Sint32 );
!     extern  void slWindowClipLevel( Sint32 );
  
  /*------------------------------------------------------------------------*/
  
! #endif
diff -crBN --binary sbl6/segalib/int/int.c sbl6_patch/segalib/int/int.c
*** sbl6/segalib/int/int.c	1996-02-08 05:23:54.000000000 -0500
--- sbl6_patch/segalib/int/int.c	2021-12-28 19:46:12.000000000 -0500
***************
*** 537,540 ****
  interrupt_t	INT_GetScuFunc( int	n ){
  	return	__interrupt_vector[n];
  }
! 
\ No newline at end of file
--- 537,540 ----
  interrupt_t	INT_GetScuFunc( int	n ){
  	return	__interrupt_vector[n];
  }
! 
diff -crBN --binary sbl6/segalib/mpg/mpg_mve2.c sbl6_patch/segalib/mpg/mpg_mve2.c
*** sbl6/segalib/mpg/mpg_mve2.c	1996-02-08 05:24:56.000000000 -0500
--- sbl6_patch/segalib/mpg/mpg_mve2.c	2023-01-08 11:47:56.000000000 -0500
***************
*** 503,509 ****
  {
      Sint32      ret;
      Sint32      fpic;
-     Sint32      bn;
      
      /* 最初の絵ならタイムコードを取得する */
      get1stTc(mpgmv, &fpic);
--- 503,508 ----
diff -crBN --binary sbl6/segalib/mpg/mpg_sys.c sbl6_patch/segalib/mpg/mpg_sys.c
*** sbl6/segalib/mpg/mpg_sys.c	1996-02-08 05:24:56.000000000 -0500
--- sbl6_patch/segalib/mpg/mpg_sys.c	2023-01-08 11:51:18.000000000 -0500
***************
*** 608,619 ****
  /* MPEGシステムの状態の取り込み実行 */
  static Sint32   doCaptStat(void)
  {
!     Sint32      ret;
  
      /* MPG関数を実行中ならすぐに戻る */
      if (mp_in_cnt > 0) {
          mp_capt_flag = TRUE;
!         return;
      }
  
      /* MPEGシステムの状態取得 */
--- 608,619 ----
  /* MPEGシステムの状態の取り込み実行 */
  static Sint32   doCaptStat(void)
  {
!     Sint32      ret = MPG_ERR_OK;
  
      /* MPG関数を実行中ならすぐに戻る */
      if (mp_in_cnt > 0) {
          mp_capt_flag = TRUE;
!         return ret;	// TBD
      }
  
      /* MPEGシステムの状態取得 */
diff -crBN --binary sbl6/segalib/mpg/mpg_win.c sbl6_patch/segalib/mpg/mpg_win.c
*** sbl6/segalib/mpg/mpg_win.c	1996-02-08 05:24:56.000000000 -0500
--- sbl6_patch/segalib/mpg/mpg_win.c	2023-01-08 16:16:58.000000000 -0500
***************
*** 461,469 ****
  /* MPEGウィンドウの消去 */
  void    MPG_WnDestroy(MpgWn mpgwn)
  {
-     Sint32      dswsw, fbn;
-     MpgWn       parep, chldp;
-     
      MPSYS_SemaIn(FALSE);
      
      /* 表示スイッチがONなら非表示にする */
--- 461,466 ----
***************
*** 542,548 ****
  static Sint32   setWn(MpgWn mpgwn)
  {
      Sint32      ret;
-     CdcMpVef    mpvef, *vfptr;
      
      /* フレームバッファウィンドゥ位置の設定 */
      if (CDC_MpSetWinFpos(TRUE, MPG_WN_FP_X(mpgwn), MPG_WN_FP_Y(mpgwn)) !=
--- 539,544 ----
diff -crBN --binary sbl6/segalib/mth/mth_dsp.c sbl6_patch/segalib/mth/mth_dsp.c
*** sbl6/segalib/mth/mth_dsp.c	1996-02-08 05:25:02.000000000 -0500
--- sbl6_patch/segalib/mth/mth_dsp.c	2023-01-08 11:53:48.000000000 -0500
***************
*** 15,20 ****
--- 15,24 ----
   */
  
  /*
+  * C STANDARD LIBRARY FUNCTIONS/MACROS DEFINES
+  */
+ #include <string.h>
+ /*
   * USER SUPPLIED INCLUDE FILES
   */
  #include "sega_mth.h"
***************
*** 28,34 ****
  #include "mth_dspp.cod"
  };
  
! static MthPolyTransParm iPolyTransParm;
  
  
  /*************************************************************************
--- 32,38 ----
  #include "mth_dspp.cod"
  };
  
! //static MthPolyTransParm iPolyTransParm;
  
  
  /*************************************************************************
***************
*** 160,163 ****
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 164,167 ----
  }
  
  /*  end of file */
! 
diff -crBN --binary sbl6/segalib/mth/mth_fixd.s sbl6_patch/segalib/mth/mth_fixd.s
*** sbl6/segalib/mth/mth_fixd.s	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/mth/mth_fixd.s	2021-04-21 19:17:26.000000000 -0400
***************
*** 0 ****
--- 1,188 ----
+ !-----------------------------------------------------------------------------
+ !   mth_fixd.src -- MTH ライブラリ FIXD モジュール
+ !   Copyright(c) 1994 SEGA
+ !   Written by T.S on 1994-01-24 Ver.0.80
+ !   Updated by H.E on 1994-02-15 Ver.0.80
+ !
+ !   このライブラリはＳＨにおける３２ビット固定小数点の演算と、Ｃ言語の割り算
+ !   ルーチンの高速版を含む。
+ !
+ !   _MTH_Mul               -  固定小数点の乗算
+ !   _MTH_Div               -  固定小数点の除算
+ !   _MTH_IntToFixed        -  整数を固定小数点に変換
+ !   _MTH_FixedToInt        -  固定小数点を整数に変換
+ !   _MTH_Product           -  ３項積和演算
+ !
+ !   このライブラリを使用するには次のインクルードファイルを定義する必要がある。
+ !
+ !   #include "sega_xpt.h"
+ !   #include "sega_spr.h"
+ !
+ !-----------------------------------------------------------------------------
+ !
+ 	.global _MTH_Mul
+ 	.global _MTH_Div
+ 	.global	_MTH_IntToFixed
+ 	.global	_MTH_FixedToInt
+ 	.global	_MTH_Product
+ !	.global	__divls
+ 
+ 	.section .text
+ 
+ 
+ !
+ !---------------------------------------------------------------------
+ !  SH2 fixed point multiplication routine                   '94.01.24
+ !---------------------------------------------------------------------
+ !	C Langage Interface:
+ !
+ !	Fixed32 MTH_Mul( Fixed32 a, Fixed32 b )!
+ !
+ !	  Fixed point multiplication:
+ !	  H16.L16 x H16.L16 -> e16 H16.L16 o16
+ !	                           ~~~~~~~
+ !	    R4    x   R5    ->       R0
+ !
+ !       REGs USED:
+ !	       R0, R3..R5
+ !
+ 
+ 	.align 2
+ 
+ _MTH_Mul:
+  	STS	mach,r1
+  	STS	macl,r2
+ 	DMULS.L r4,r5
+  	STS	mach,r3
+  	STS	macl,r0
+  	LDS	r1,mach
+  	LDS	r2,macl
+ 	RTS		! return
+  	XTRCT	r3,r0	! xtract for Fixed32
+ !
+ !---------------------------------------------------------------------
+ !  SH2 fixed point division routine                         '94.01.24
+ !---------------------------------------------------------------------
+ !	C Langage Interface:
+ !
+ !	Fixed32 MTH_Div( Fixed32 a, Fixed32 b )!
+ !
+ !	   Fixed point division:
+ !	   e16 H16.L16 o16/ H16.L16 -> H16.L16
+ !	       ~~~~~~~
+ !	          R4      /   R5    ->   R0
+ !
+ !       REGs USED:
+ !	       R0, R4, R5
+ !
+ 	.align 2
+ 
+ _MTH_Div:
+ 	MOV.L	A_DIV,r0
+ 	SWAP.W	r4,r2	! make R2:R4 64bit pair
+ 	MOV.L	r5,@r0
+ 	EXTS.W	r2,r2	!  0  R4H   R4L  0
+ 	MOV.L	r2,@(0x10,r0)
+ 	SHLL16	r4
+ 	MOV.L	r4,@(0x14,r0)
+ 	RTS
+  	MOV.L	@(0x14,r0),r0
+ !
+ !---------------------------------------------------------------------
+ !  SH2 int to fixed point convert routine                   '94.01.24
+ !---------------------------------------------------------------------
+ !	C Langage Interface:
+ !
+ !	Fixed32 MTH_IntToFixed( int a )!
+ !
+ !	R4  << 16    ->   R0
+ !
+ !       REGs USED:
+ !	       nothing
+ !
+ 	.align 2
+ 
+ _MTH_IntToFixed:
+ 	MOV  	r4,r0
+ 	RTS
+ 	SHLL16	r0
+ !
+ !---------------------------------------------------------------------
+ !  SH2 fixed to int point convert routine                   '94.01.24
+ !---------------------------------------------------------------------
+ !	C Langage Interface:
+ !
+ !	Fixed32 MTH_FixedToInt( Fixed32 a )!
+ !
+ !	R4  >> 16    ->   R0
+ !
+ !       REGs USED:
+ !	       nothing
+ !
+ 	.align 2
+ 
+ _MTH_FixedToInt:
+ 	MOV  	r4,r0
+ 	SHLR16	r0
+ 	RTS
+ 	EXTS.W	r0,r0
+ !
+ !---------------------------------------------------------------------
+ !  SH2   3 item multiple and add process                     '94.01.24
+ !---------------------------------------------------------------------
+ !	C Langage Interface:
+ !
+ !	Fixed32 MTH_Product( Fixed32 a[3], Fixed32 b[3] )!
+ !
+ !	a[0]*b[0] + a[1]*b[1] + a[2]*b[2] -> R0
+ !
+ !       REGs USED:
+ !	       R0-R7
+ !
+ 	.align 2
+ 
+ _MTH_Product:                    ! function: MTH_Product
+  	STS	mach,r1
+  	STS	macl,r2
+ 	MOV	#0,r0
+ 	LDS	r0,mach
+ 	LDS	r0,macl
+ 	MAC.L   @r4+,@r5+
+ 	MAC.L   @r4+,@r5+
+ 	MAC.L   @r4+,@r5+
+  	STS	mach,r3
+  	STS	macl,r0
+  	LDS	r1,mach
+  	LDS	r2,macl
+ 	RTS		! return
+  	XTRCT	r3,r0	! xtract for Fixed32
+ !
+ 
+ 	.align 2
+ 
+ __divls:
+ 	MOV.L	r3,@-r15
+ 	MOV	#0xF0,r3
+ 	STC.L	sr,@-r15
+ 	EXTU.B	r3,r3
+ 	LDC	r3,sr
+ 	MOV.L	A_DIV,r3
+ 	MOV.L	r0,@r3		! SH2 DIV Unit
+ 	NOP
+ 	MOV.L	r1,@(0x4,r3)
+ 	NOP
+  	MOV.L	@(0x14,r3),r0	! get DIV result
+ 	NOP
+ 	LDC.L	@r15+,sr
+ 	MOV.L	@r15+,r3
+ 	RTS
+ 	MOV	r0,r1
+ 
+ 	.ALIGN 2
+ 
+ A_DIV:	.long	0xFFFFFF00
+ !
+ !---------------------------------------------------------------------
+ 	.END
+ !---------------------------------------------------------------------
+ !   end of file
diff -crBN --binary sbl6/segalib/mth/mth_mtrx.s sbl6_patch/segalib/mth/mth_mtrx.s
*** sbl6/segalib/mth/mth_mtrx.s	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/mth/mth_mtrx.s	2021-04-21 19:17:26.000000000 -0400
***************
*** 0 ****
--- 1,1124 ----
+ !----------------------------------------------------------------------------
+ !  mth_mtrx.c -- MTH ライブラリ マトリックス演算処理 モジュール
+ !  Copyright(c) 1994 SEGA
+ !  Written by H.E on 1994-03-28 Ver.0.80
+ !  Updated by H.E on 1994-03-28 Ver.0.80
+ !
+ !  このライブラリはマトリックス演算処理モジュールで、
+ !  以下のルーチンを含む。
+ !
+ !  MTH_InitialMatrix       -  マトリックススタックの初期化
+ !  MTH_ClearMatrix         -  カレントマトリックスのクリア
+ !  MTH_PushMatrix          -  マトリックスのプッシュ
+ !  MTH_PopMatrix           -  マトリックスのポップ
+ !  MTH_MoveMatrix          -  マトリックス合成・平行移動
+ !  MTH_RotateMatrixX       -  マトリックス合成・Ｘ軸回転
+ !  MTH_RotateMatrixY       -  マトリックス合成・Ｙ軸回転
+ !  MTH_RotateMatrixZ       -  マトリックス合成・Ｚ軸回転
+ !  MTH_ReverseZ            -  マトリックス合成・Ｚ軸符号反転
+ !  MTH_MulMatrix           -  マトリックス乗算
+ !  MTH_CoordTrans          -  マトリックス演算・頂点の座標変換
+ !  MTH_NormalTrans         -  マトリックス演算・法線ベクトルの座標変換
+ !
+ !----------------------------------------------------------------------------
+ !
+           .extern     _MTH_Sin
+           .extern     _MTH_Cos
+           .extern     _MTH_Mul
+           .global     _MTH_InitialMatrix
+           .global     _MTH_ClearMatrix
+           .global     _MTH_PushMatrix
+           .global     _MTH_PopMatrix
+           .global     _MTH_MoveMatrix
+           .global     _MTH_RotateMatrixX
+           .global     _MTH_RotateMatrixY
+           .global     _MTH_RotateMatrixZ
+           .global     _MTH_ReverseZ
+           .global     _MTH_MulMatrix
+           .global     _MTH_CoordTrans
+           .global     _MTH_NormalTrans
+ 
+           .section .text
+ !
+ !
+ !*****************************************************************************
+ !*
+ !* NAME:  MTH_InitialMatrix()  - Initial Matrix Stack
+ !*
+ !*     void MTH_InitialMatrix(MthMatrixTbl *matrixTbl, Uint16 stackSize,
+ !*						     MthMtrix *matrix)
+ !*
+ !* PARAMETERS :
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <o> マトリックステーブル
+ !* 　　(2) Uint16       stackSize  - <i> マトリックススタックの最大エントリ数
+ !* 　　(3) MthMatrix    *matrix    - <i> マトリックススタックエリア
+ !*
+ !* DESCRIPTION:
+ !*
+ !*     マトリックススタックテーブルの初期化
+ !*
+ !* POSTCONDITIONS:
+ !*
+ !*     No exist.
+ !*
+ !* CAVEATS:
+ !*
+ !*****************************************************************************
+ !
+ 
+ 	.align 2
+ 
+ _MTH_InitialMatrix:             ! function: MTH_InitialMatrix
+           STS.L       pr,@-r15
+           MOV.W       r5,@r4
+           MOV.L       r6,@(8,r4)
+           MOV.L       r6,@(4,r4)
+           BRA         _MTH_ClearMatrix
+           LDS.L       @r15+,pr
+ !
+ !
+ !*****************************************************************************
+ !*
+ !* NAME:  MTH_ClearMatrix()  - clear current matrix to unit matrix
+ !*
+ !*     void MTH_ClearMatrix(MthMatrixTbl *matrixTbl)
+ !*
+ !* PARAMETERS :
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !*
+ !* DESCRIPTION:
+ !*
+ !*     マトリックススタック内のカレントマトリックスを単位行列にクリアする。
+ !*
+ !* POSTCONDITIONS:
+ !*
+ !*     No exist.
+ !*
+ !* CAVEATS:
+ !*
+ !*****************************************************************************
+ !
+ _MTH_ClearMatrix:               ! function: MTH_ClearMatrix
+           MOV.L       cm_unitMatrix,r6
+           MOV.L       @(4,r4),r5
+           MOV         #12,r0
+ cm_0:
+ 	  MOV.L       @r6+,r1
+           MOV.L       r1,@r5
+           DT          r0
+           BF.S        cm_0
+           ADD         #4,r5
+           RTS
+           NOP
+ !
+ 	  .ALIGN 2
+ 
+ cm_unitMatrix:
+           .long     unitMatrix
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_PushMatrix    - push current matrix to matrix stack
+ !*
+ !*     void MTH_PushMatrix(MthMatrixTbl *matrixTbl)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !*
+ !* DESCRIPTION
+ !*
+ !*	カレントマトリックスのプッシュ処理
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_PushMatrix:                ! function: MTH_PushMatrix
+           MOV.L       @(4,r4),r6
+           MOV.L       @(4,r4),r5
+           ADD         #48,r5
+           MOV         r5,r2
+           MOV         #12,r0
+ pm_0:
+ 	  MOV.L       @r6+,r1
+           MOV.L       r1,@r5
+           DT          r0
+           BF.S        pm_0
+           ADD         #4,r5
+           RTS
+           MOV.L       r2,@(4,r4)
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_PopMatrix    - pop current matrix from matrix stack
+ !*
+ !*     void MTH_PopMatrix(MthMatrixTbl *matrixTbl)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !*
+ !* DESCRIPTION
+ !*
+ !*	カレントマトリックスのポップ処理
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_PopMatrix:                 ! function: MTH_PopMatrix
+           MOV.L       @(4,r4),r3
+           ADD         #-48,r3
+           RTS
+           MOV.L       r3,@(4,r4)
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_MoveMatrix   - Move Matrix
+ !*
+ !*     void MTH_MoveMatrix(MthMatrixTbl *matrixTbl,
+ !*                                       Fixed32 x, Fixed32 y, Fixed32 z)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !* 　　(2) Fixed32      x          - <i> Ｘ方向の移動量
+ !* 　　(3) Fixed32      y          - <i> Ｙ方向の移動量
+ !* 　　(4) Fixed32      z          - <i> Ｚ方向の移動量
+ !*
+ !* DESCRIPTION
+ !*
+ !* カレントマトリックスに対しＸＹＺ平行移動のマトリックス合成を行う
+ !*
+ !* | M00 M01 M02 M03 | | 1 0 0 x |   | M00 M01 M02 M00*x+M01*y+M02*z+M03 |
+ !* | M10 M11 M12 M13 |.| 0 1 0 y | = | M10 M11 M12 M10*x+M11*y+M12*z+M13 |
+ !* | M20 M21 M22 M23 | | 0 0 1 z |   | M20 M21 M22 M20*x+M21*y+M22*z+M23 |
+ !* |   0   0   0   1 | | 0 0 0 1 |   |   0   0   0                     1 |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_MoveMatrix:                ! function: MTH_MoveMatrix
+           MOV.L       @(4,r4),r3 ! r3 = currentMatrix
+           MOV.L       r7,@-r15   ! z
+           MOV.L       r6,@-r15   ! y
+           MOV.L       r5,@-r15   ! x
+           STS         mach,r6
+           STS         macl,r7
+ !
+           MOV         r15,r4     ! r4 = (x, y, z)
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M00*x+M01*y+M02*z
+           MOV         r3,r2
+           MOV.L       @r3+,r1
+           ADD         r0,r1      ! r1 = r0 + M03
+           MOV.L       r1,@r2     ! currentMatrix[0][3] = r1
+ !
+           MOV         r15,r4     ! @r4 = (x, y, z)
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M10*x+M11*y+M12*z
+           MOV         r3,r2
+           MOV.L       @r3+,r1
+           ADD         r0,r1      ! r1 = r0 + M03
+           MOV.L       r1,@r2     ! currentMatrix[1][3] = r1
+ !
+           MOV         r15,r4     ! r4 = (x, y, z)
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M20*x+M21*y+M22*z
+           MOV.L       @r3,r1
+           ADD         r0,r1      ! r1 = r0 + M03
+ 	  ADD         #12,r15
+           LDS         r6,mach
+           LDS         r7,macl
+           RTS
+           MOV.L       r1,@r3     ! currentMatrix[2][3] = r1
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_RotateMatrixX  - Rotate Matrix X
+ !*
+ !*     void    MTH_RotateMatrixX(MthMatrixTbl *matrixTbl, Fixed32 xDegree)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !* 　　(2) Fixed32      xDegree    - <i> Ｘ軸の回転角度（-180から180の範囲）
+ !*
+ !* DESCRIPTION
+ !*
+ !* カレントマトリックスに対しＸ軸回転のマトリックス合成を行う
+ !*
+ !* | M00 M01 M02 M03 | | 1    0    0 0 |
+ !* | M10 M11 M12 M13 |.| 0  cos -sin 0 |
+ !* | M20 M21 M22 M23 | | 0  sin  cos 0 |
+ !* |   0   0   0   1 | | 0    0    0 1 |
+ !*
+ !*		         | M00 M01*cos+M02*sin -M01*sin+M02*cos M03 |
+ !*		       = | M10 M11*cos+M12*sin -M11*sin+M12*cos M13 |
+ !*		         | M20 M21*cos+M22*sin -M21*sin+M22*cos M23 |
+ !*		         |   0               0                0   1 |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_RotateMatrixX:             ! function: MTH_RotateMatrixX
+           MOV.L       r8,@-r15
+           MOV.L       r9,@-r15
+           MOV.L       r10,@-r15
+           STS.L       pr,@-r15
+           STS.L       macl,@-r15
+           STS.L       mach,@-r15
+           MOV         r4,r8
+           MOV         r5,r9
+ !
+           MOV.L       rmx_MTH_Sin,r3
+           JSR         @r3
+           MOV         r9,r4
+           MOV         r0,r10     ! r10 = sin
+ !
+           MOV.L       rmx_MTH_Cos,r3
+           JSR         @r3
+           MOV         r9,r4      ! r0  = cos
+ !
+           MOV.L       @(4,r8),r6 ! r6 = currentMatrix
+           MOV.L       r0,@-r15   ! Push   cos
+           NEG         r10,r1
+           MOV.L       r1,@-r15   ! Push  -sin
+           MOV         r15,r8     ! @r8 = (-sin,cos)
+           MOV.L       r10,@-r15  ! Push   sin
+           MOV.L       r0,@-r15   ! Push   cos
+           MOV         r15,r7     ! @r7 = (cos,sin)
+ !
+           MOV.L       @(8,r6),r0
+           MOV.L       r0,@-r15   ! Push  M02
+           MOV.L       @(4,r6),r0
+           MOV.L       r0,@-r15   ! Push  M01
+           MOV         r15,r9     ! @r9 = (M01,M02)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M01*cos+M02*sin
+           MOV.L       r0,@(4,r6) ! M01 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = -M01*sin+M02*cos
+           MOV.L       r0,@(8,r6) ! M02 = r0
+ 	  ADD         #8,r15
+ !
+           MOV.L       @(24,r6),r0
+           MOV.L       r0,@-r15   ! Push  M12
+           MOV.L       @(20,r6),r0
+           MOV.L       r0,@-r15   ! Push  M11
+           MOV         r15,r9     ! @r9 = (M11,M12)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M11*cos+M12*sin
+           MOV.L       r0,@(20,r6) ! M11 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = -M11*sin+M12*cos
+           MOV.L       r0,@(24,r6) ! M12 = r0
+ 	  ADD         #8,r15
+ !
+           MOV.L       @(40,r6),r0
+           MOV.L       r0,@-r15   ! Push  M22
+           MOV.L       @(36,r6),r0
+           MOV.L       r0,@-r15   ! Push  M21
+           MOV         r15,r9     ! @r9 = (M21,M22)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M21*cos+M22*sin
+           MOV.L       r0,@(36,r6) ! M21 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = -M21*sin+M22*cos
+           MOV.L       r0,@(40,r6) ! M22 = r0
+ 	  ADD         #24,r15
+ !
+           LDS.L       @r15+,mach
+           LDS.L       @r15+,macl
+           LDS.L       @r15+,pr
+           MOV.L       @r15+,r10
+           MOV.L       @r15+,r9
+           RTS
+           MOV.L       @r15+,r8
+ !
+ 	  .align 2
+ 
+ rmx_MTH_Sin:
+           .long     _MTH_Sin
+ rmx_MTH_Cos:
+           .long     _MTH_Cos
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_RotateMatrixY  - Rotate Matrix Y
+ !*
+ !*     void    MTH_RotateMatrixY(MthMatrixTbl *matrixTbl, Fixed32 yDegree)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !* 　　(2) Fixed32      yDegree    - <i> Ｙ軸の回転角度（-180から180の範囲）
+ !*
+ !* DESCRIPTION
+ !*
+ !* カレントマトリックスに対しＹ軸回転のマトリックス合成を行う
+ !*
+ !* | M00 M01 M02 M03 | |  cos 0  sin 0 |
+ !* | M10 M11 M12 M13 |.|    0 1    0 0 |
+ !* | M20 M21 M22 M23 | | -sin 0  cos 0 |
+ !* |   0   0   0   1 | |    0 0    0 1 |
+ !*
+ !*			|  M00*cos-M02*sin  M01 M00*sin+M02*cos M03 |
+ !*		    =	|  M10*cos-M12*sin  M11 M10*sin+M12*cos M13 |
+ !*			|  M20*cos-M22*sin  M21 M20*sin+M22*cos M23 |
+ !*			|                0    0               0   1 |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_RotateMatrixY:             ! function: MTH_RotateMatrixY
+           MOV.L       r8,@-r15
+           MOV.L       r9,@-r15
+           MOV.L       r10,@-r15
+           STS.L       pr,@-r15
+           STS.L       macl,@-r15
+           STS.L       mach,@-r15
+           MOV         r4,r8
+           MOV         r5,r9
+ !
+           MOV.L       rmy_MTH_Sin,r3
+           JSR         @r3
+           MOV         r9,r4
+           MOV         r0,r10     ! r10 = sin
+ !
+           MOV.L       rmy_MTH_Cos,r3
+           JSR         @r3
+           MOV         r9,r4      ! r0  = cos
+ !
+           MOV.L       @(4,r8),r6 ! r6 = currentMatrix
+           MOV.L       r0,@-r15   ! Push   cos
+           MOV.L       r10,@-r15  ! Push   sin
+           MOV         r15,r8     ! @r8 = (sin,cos)
+           NEG         r10,r1
+           MOV.L       r1,@-r15   ! Push  -sin
+           MOV.L       r0,@-r15   ! Push   cos
+           MOV         r15,r7     ! @r7 = (cos,-sin)
+ !
+           MOV.L       @(8,r6),r0
+           MOV.L       r0,@-r15   ! Push  M02
+           MOV.L       @(0,r6),r0
+           MOV.L       r0,@-r15   ! Push  M00
+           MOV         r15,r9     ! @r9 = (M00,M02)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M00*cos-M02*sin
+           MOV.L       r0,@(0,r6) ! M00 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M00*sin+M02*cos
+           MOV.L       r0,@(8,r6) ! M02 = r0
+ 	  ADD         #8,r15
+ !
+           MOV.L       @(24,r6),r0
+           MOV.L       r0,@-r15   ! Push  M12
+           MOV.L       @(16,r6),r0
+           MOV.L       r0,@-r15   ! Push  M10
+           MOV         r15,r9     ! @r9 = (M10,M12)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M10*cos-M12*sin
+           MOV.L       r0,@(16,r6) ! M10 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M10*sin+M12*cos
+           MOV.L       r0,@(24,r6) ! M12 = r0
+ 	  ADD         #8,r15
+ !
+           MOV.L       @(40,r6),r0
+           MOV.L       r0,@-r15   ! Push  M22
+           MOV.L       @(32,r6),r0
+           MOV.L       r0,@-r15   ! Push  M20
+           MOV         r15,r9     ! @r9 = (M20,M22)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M20*cos-M22*sin
+           MOV.L       r0,@(32,r6) ! M20 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M20*sin+M22*cos
+           MOV.L       r0,@(40,r6) ! M22 = r0
+ 	  ADD         #24,r15
+ !
+           LDS.L       @r15+,mach
+           LDS.L       @r15+,macl
+           LDS.L       @r15+,pr
+           MOV.L       @r15+,r10
+           MOV.L       @r15+,r9
+           RTS
+           MOV.L       @r15+,r8
+ !
+ 	  .align 2
+ 
+ rmy_MTH_Sin:
+           .long     _MTH_Sin
+ rmy_MTH_Cos:
+           .long     _MTH_Cos
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_RotateMatrixZ  - Rotate Matrix Z
+ !*
+ !*     void MTH_RotateMatrixZ(MthMatrixTbl *matrixTbl, Fixed32 zDegree)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !* 　　(2) Fixed32      zDegree    - <i> Ｚ軸の回転角度（-180から180の範囲）
+ !*
+ !* DESCRIPTION
+ !*
+ !* | M00 M01 M02 M03 | | cos -sin  0 0 |
+ !* | M10 M11 M12 M13 |.| sin  cos  0 0 |
+ !* | M20 M21 M22 M23 | |   0    0  1 0 |
+ !* |   0   0   0   1 | |   0    0  0 1 |
+ !*
+ !*				| M00*cos+M01*sin -M00*sin+M01*cos M02 M03 |
+ !*			      =	| M10*cos+M11*sin -M10*sin+M11*cos M12 M13 |
+ !*				| M20*cos+M21*sin -M20*sin+M21*cos M22 M23 |
+ !*				|               0                0   0   1 |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_RotateMatrixZ:             ! function: MTH_RotateMatrixZ
+                                 ! frame size=76
+           MOV.L       r8,@-r15
+           MOV.L       r9,@-r15
+           MOV.L       r10,@-r15
+           STS.L       pr,@-r15
+           STS.L       macl,@-r15
+           STS.L       mach,@-r15
+           MOV         r4,r8
+           MOV         r5,r9
+ !
+           MOV.L       rmz_MTH_Sin,r3
+           JSR         @r3
+           MOV         r9,r4
+           MOV         r0,r10     ! r10 = sin
+ !
+           MOV.L       rmz_MTH_Cos,r3
+           JSR         @r3
+           MOV         r9,r4      ! r0  = cos
+ !
+           MOV.L       @(4,r8),r6 ! r6 = currentMatrix
+           MOV.L       r0,@-r15   ! Push   cos
+           NEG         r10,r1
+           MOV.L       r1,@-r15   ! Push  -sin
+           MOV         r15,r8     ! @r8 = (-sin,cos)
+           MOV.L       r10,@-r15  ! Push   sin
+           MOV.L       r0,@-r15   ! Push   cos
+           MOV         r15,r7     ! @r7 = (cos,sin)
+ !
+           MOV.L       @(4,r6),r0
+           MOV.L       r0,@-r15   ! Push  M01
+           MOV.L       @(0,r6),r0
+           MOV.L       r0,@-r15   ! Push  M00
+           MOV         r15,r9     ! @r9 = (M00,M01)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M00*cos+M01*sin
+           MOV.L       r0,@(0,r6) ! M00 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = -M00*sin+M01*cos
+           MOV.L       r0,@(4,r6) ! M01 = r0
+ 	  ADD         #8,r15
+ !
+           MOV.L       @(20,r6),r0
+           MOV.L       r0,@-r15   ! Push  M11
+           MOV.L       @(16,r6),r0
+           MOV.L       r0,@-r15   ! Push  M10
+           MOV         r15,r9     ! @r9 = (M10,M11)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M10*cos+M11*sin
+           MOV.L       r0,@(16,r6) ! M10 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = -M10*sin+M11*cos
+           MOV.L       r0,@(20,r6) ! M11 = r0
+ 	  ADD         #8,r15
+ !
+           MOV.L       @(36,r6),r0
+           MOV.L       r0,@-r15   ! Push  M21
+           MOV.L       @(32,r6),r0
+           MOV.L       r0,@-r15   ! Push  M20
+           MOV         r15,r9     ! @r9 = (M20,M21)
+           MOV         r7,r4
+           MOV         r9,r3
+           CLRMAC
+           MAC.L       @r3+,@r4+
+           MAC.L       @r3+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = M20*cos+M21*sin
+           MOV.L       r0,@(32,r6) ! M20 = r0
+           MOV         r8,r4
+           CLRMAC
+           MAC.L       @r9+,@r4+
+           MAC.L       @r9+,@r4+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0       ! r0 = -M20*sin+M21*cos
+           MOV.L       r0,@(36,r6) ! M21 = r0
+ 	  ADD         #24,r15
+ !
+           LDS.L       @r15+,mach
+           LDS.L       @r15+,macl
+           LDS.L       @r15+,pr
+           MOV.L       @r15+,r10
+           MOV.L       @r15+,r9
+           RTS
+           MOV.L       @r15+,r8
+ !
+ 	  .align 2
+ 
+ rmz_MTH_Sin:
+           .long     _MTH_Sin
+ rmz_MTH_Cos:
+           .long     _MTH_Cos
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_ReverseZ  - Revers Signe Z
+ !*
+ !*     void    MTH_ReverseZ(MthMatrixTbl *matrixTbl)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrixTbl *matrixTbl - <i> マトリックステーブル
+ !*
+ !* DESCRIPTION
+ !*
+ !* カレントマトリックスに対しＺ軸符号反転のマトリックス合成を行う
+ !*
+ !* | M00 M01 M02 M03 | | 1 0  0 0 |
+ !* | M10 M11 M12 M13 |.| 0 1  0 0 |
+ !* | M20 M21 M22 M23 | | 0 0 -1 0 |
+ !* |   0   0   0   1 | | 0 0  0 1 |
+ !*
+ !*				| M00 M01 -M02 M03 |
+ !*			      =	| M10 M11 -M12 M13 |
+ !*				| M20 M21 -M22 M23 |
+ !*				|   0   0    0   1 |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_ReverseZ:                  ! function: MTH_ReverseZ
+           MOV.L       @(4,r4),r6  ! r6 = currentMatrix
+           MOV.L       @(8,r6),r0
+           NEG         r0,r0
+           MOV.L       r0,@(8,r6)  ! M02 = -M02
+ !
+           MOV.L       @(24,r6),r0
+           NEG         r0,r0
+           MOV.L       r0,@(24,r6) ! M12 = -M12
+ !
+           MOV.L       @(40,r6),r0
+           NEG         r0,r0
+           RTS
+           MOV.L       r0,@(40,r6) ! M22 = -M22
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_MulMatrix  -  Multiple Matrix
+ !*
+ !*     void   MTH_MulMatrix(MthMatrix *a, MthMatrix *b, MthMatrix *c)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrix  *a - <i> 被乗算マトリックス
+ !* 　　(2) MthMatrix  *b - <i> 乗算マトリックス
+ !* 　　(3) MthMatrix  *c - <o> 乗算結果マトリックス
+ !*
+ !* DESCRIPTION
+ !*
+ !* マトリックス乗算処理
+ !*
+ !* | a00 a01 a02 a03 | | b00 b01 b02 b03 |	| c00 c01 c02 c03 |
+ !* | a10 a11 a12 a13 |.| b10 b11 b12 b13 |  =	| c10 c11 c12 c13 |
+ !* | a20 a21 a22 a23 | | b20 b21 b22 b23 |	| c20 c21 c22 c23 |
+ !* |   0   0   0   1 | |   0   0   0   1 |	|   0   0   0   1 |
+ !*
+ !*    c00 = a00*b00+a01*b10+a02*b20
+ !*    c10 = a10*b00+a11*b10+a12*b20
+ !*    c20 = a20*b00+a21*b10+a22*b20
+ !*
+ !*    c01 = a00*b01+a01*b11+a02*b21
+ !*    c11 = a10*b01+a11*b11+a12*b21
+ !*    c21 = a20*b01+a21*b11+a22*b21
+ !*
+ !*    c02 = a00*b02+a01*b12+a02*b22
+ !*    c12 = a10*b02+a11*b12+a12*b22
+ !*    c22 = a20*b02+a21*b12+a22*b22
+ !*
+ !*    c03 = a00*b03+a01*b13+a02*b23+a03
+ !*    c13 = a10*b03+a11*b13+a12*b23+a13
+ !*    c23 = a20*b03+a21*b13+a22*b23+a23
+ !*
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_MulMatrix:                 ! function: MTH_MulMatrix
+     	    STS.L       mach,@-r15
+           STS.L       macl,@-r15
+ !---------
+           MOV.L       @(32,r5),r0
+           MOV.L       r0,@-r15      ! Push b20
+           MOV.L       @(16,r5),r0
+           MOV.L       r0,@-r15      ! Push b10
+           MOV.L       @(0,r5),r0
+           MOV.L       r0,@-r15      ! Push b00
+ !
+           MOV         r4,r2         ! r2 = a00
+           MOV         r15,r3        ! r3 = (b00, b10, b20)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a00*b00+a01*b10+a02*b20
+           MOV.L       r0,@(0,r6)    ! c00 = r0
+ !
+           ADD         #4,r2         ! r2  = a10
+           MOV         r15,r3        ! r3 = (b00, b10, b20)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a10*b00+a11*b10+a12*b20
+           MOV.L       r0,@(16,r6)   ! c10 = r0
+ !
+           ADD         #4,r2         ! r2  = a20
+           MOV         r15,r3        ! r3 = (b00, b10, b20)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a20*b00+a21*b10+a22*b20
+           MOV.L       r0,@(32,r6)   ! c20 = r0
+ !---------
+ 	  ADD         #12,r15
+           MOV.L       @(36,r5),r0
+           MOV.L       r0,@-r15      ! Push b21
+           MOV.L       @(20,r5),r0
+           MOV.L       r0,@-r15      ! Push b11
+           MOV.L       @(4,r5),r0
+           MOV.L       r0,@-r15      ! Push b01
+ !
+           MOV         r4,r2         ! r2 = a00
+           MOV         r15,r3        ! r3 = (b01, b11, b21)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a00*b01+a01*b11+a02*b21
+           MOV.L       r0,@(4,r6)    ! c01 = r0
+ !
+           ADD         #4,r2         ! r2  = a10
+           MOV         r15,r3        ! r3 = (b01, b11, b21)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a10*b01+a11*b11+a12*b21
+           MOV.L       r0,@(20,r6)   ! c11 = r0
+ !
+           ADD         #4,r2         ! r2  = a20
+           MOV         r15,r3        ! r3 = (b01, b11, b21)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a20*b01+a21*b11+a22*b21
+           MOV.L       r0,@(36,r6)   ! c21 = r0
+ !---------
+ 	  ADD         #12,r15
+           MOV.L       @(40,r5),r0
+           MOV.L       r0,@-r15      ! Push b22
+           MOV.L       @(24,r5),r0
+           MOV.L       r0,@-r15      ! Push b12
+           MOV.L       @(8,r5),r0
+           MOV.L       r0,@-r15      ! Push b02
+ !
+           MOV         r4,r2         ! r2 = a00
+           MOV         r15,r3        ! r3 = (b02, b12, b22)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a00*b02+a01*b12+a02*b22
+           MOV.L       r0,@(8,r6)    ! c02 = r0
+ !
+           ADD         #4,r2         ! r2  = a10
+           MOV         r15,r3        ! r3 = (b02, b12, b22)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a10*b02+a11*b12+a12*b22
+           MOV.L       r0,@(24,r6)   ! c12 = r0
+ !
+           ADD         #4,r2         ! r2  = a20
+           MOV         r15,r3        ! r3 = (b02, b12, b22)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a20*b02+a21*b12+a22*b22
+           MOV.L       r0,@(40,r6)   ! c22 = r0
+ !---------
+ 	  ADD         #12,r15
+ 	  MOV         #1,r0
+ 	  SHLL16      r0
+           MOV.L       r0,@-r15      ! Push 1.0
+           MOV.L       @(44,r5),r0
+           MOV.L       r0,@-r15      ! Push b23
+           MOV.L       @(28,r5),r0
+           MOV.L       r0,@-r15      ! Push b13
+           MOV.L       @(12,r5),r0
+           MOV.L       r0,@-r15      ! Push b03
+ !
+           MOV         r4,r2         ! r2 = a00
+           MOV         r15,r3        ! r3 = (b03, b13, b23, 1.0)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a00*b03+a01*b13+a02*b23+a03
+           MOV.L       r0,@(12,r6)   ! c03 = r0
+ !
+           MOV         r15,r3        ! r3 = (b03, b13, b23, 1.0)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a10*b03+a11*b13+a12*b23+a13
+           MOV.L       r0,@(28,r6)   ! c13 = r0
+ !
+           MOV         r15,r3        ! r3 = (b03, b13, b23, 1.0)
+           CLRMAC
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+           MAC.L       @r2+,@r3+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0         ! r0  = a20*b03+a21*b13+a22*b23+a23
+ !
+ 	  ADD         #16,r15
+           LDS.L       @r15+,macl
+           LDS.L       @r15+,mach
+           RTS
+           MOV.L       r0,@(44,r6)   ! c23 = r0
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_CoordTrans  -  Coord Transfer of Vertices
+ !*
+ !*     void    MTH_CoordTrans(MthMatrix *matrix, MthXyz *src, MthXyz *ans)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrix *matrix - <i> 座標変換マトリックス
+ !* 　　(2) MthXyz    *src    - <i> 変換前頂点座標
+ !* 　　(3) MthXyz    *ans    - <o> 変換後頂点座標
+ !*
+ !* DESCRIPTION
+ !*
+ !* マトリックス演算・頂点の座標変換
+ !*
+ !*	| Xn |	 | M00, M01, M02, M03 | | Xa |   | M00Xa+M01Ya+M02Za+M03 |
+ !*	| Yn | = | M10, M11, M12, M13 |.| Ya | = | M10Xa+M11Ya+M12Za+M13 |
+ !*	| Zn |	 | M20, M21, M22, M23 | | Za |   | M20Xa+M21Ya+M22Za+m23 |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_CoordTrans:                ! function: MTH_CoordTrans
+           STS         mach,r2
+           STS         macl,r3
+ !
+           MOV         r5,r7     ! r7 = (Xa, Ya, Za)
+           CLRMAC
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M00Xa+M01Ya+M02Za
+           MOV.L       @r4+,r1
+           ADD         r0,r1      ! r1 = r0 + M03
+           MOV.L       r1,@(0,r6) ! Xn = r1
+ !
+           MOV         r5,r7     ! r7 = (Xa, Ya, Za)
+           CLRMAC
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M10Xa+M11Ya+M12Za
+           MOV.L       @r4+,r1
+           ADD         r0,r1      ! r1 = r0 + M13
+           MOV.L       r1,@(4,r6) ! Yn = r1
+ !
+           MOV         r5,r7     ! r7 = (Xa, Ya, Za)
+           CLRMAC
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M20Xa+M21Ya+M22Za
+           MOV.L       @r4+,r1
+           ADD         r0,r1      ! r1 = r0 + M23
+ !
+           LDS         r2,mach
+           LDS         r3,macl
+           RTS
+           MOV.L       r1,@(8,r6) ! Zn = r1
+ !
+ !
+ !*************************************************************************
+ !*
+ !* NAME : MTH_NormalTrans  -  Coord Transfer of Normal
+ !*
+ !*     void    MTH_NormalTrans(MthMatrix *matrix, MthXyz *src, MthXyz *ans)
+ !*
+ !* PARAMETERS
+ !*
+ !* 　　(1) MthMatrix  *matrix - <i> 座標変換マトリックス
+ !* 　　(2) MthXyz     *src    - <i> 変換前法線ベクトル
+ !* 　　(2) MthXyz     *ans    - <o> 変換後法線ベクトル
+ !*
+ !* DESCRIPTION
+ !*
+ !*	| Xn |	 | M00, M01, M02 | | Xa |   | M00Xa+M01Ya+M02Za |
+ !*	| Yn | = | M10, M11, M12 |.| Ya | = | M10Xa+M11Ya+M12Za |
+ !*	| Zn |	 | M20, M21, M22 | | Za |   | M20Xa+M21Ya+M22Za |
+ !*
+ !* POSTCONDITIONS
+ !*
+ !* CAVEATS
+ !*
+ !*************************************************************************
+ !
+ _MTH_NormalTrans:               ! function: MTH_NormalTrans
+                                 ! frame size=32
+           STS         mach,r2
+           STS         macl,r3
+ !
+           MOV         r5,r7     ! r7 = (Xa, Ya, Za)
+           CLRMAC
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M00Xa+M01Ya+M02Za
+           ADD         #4,r4
+           MOV.L       r0,@(0,r6) ! Xn = r0
+ !
+           MOV         r5,r7     ! r7 = (Xa, Ya, Za)
+           CLRMAC
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M10Xa+M11Ya+M12Za
+           ADD         #4,r4
+           MOV.L       r0,@(4,r6) ! Yn = r0
+ !
+           MOV         r5,r7     ! r7 = (Xa, Ya, Za)
+           CLRMAC
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+           MAC.L       @r4+,@r7+
+   	  STS	      mach,r1
+ 	  STS	      macl,r0
+ 	  XTRCT	      r1,r0      ! r0 = M20Xa+M21Ya+M22Za
+ !
+           LDS         r2,mach
+           LDS         r3,macl
+           RTS
+           MOV.L       r0,@(8,r6) ! Zn = r0
+ !
+ !
+ !*************************************************************************
+ !*
+ !*  Data Define
+ !*
+ !*************************************************************************
+ !
+           .section .data
+ 
+ 	  .align 2
+ 
+ unitMatrix:
+           .long     0x00010000,0x00000000,0x00000000,0x00000000
+ 	  .long     0x00000000,0x00010000,0x00000000,0x00000000
+ 	  .long     0x00000000,0x00000000,0x00010000,0x00000000
+ 
+ 	  .END
diff -crBN --binary sbl6/segalib/mth/mth_norm.s sbl6_patch/segalib/mth/mth_norm.s
*** sbl6/segalib/mth/mth_norm.s	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/mth/mth_norm.s	2021-04-21 19:17:26.000000000 -0400
***************
*** 0 ****
--- 1,322 ----
+ !----------------------------------------------------------------------------
+ !  mth_norm.src -- MTH ライブラリ 法線ベクタ計算 モジュール
+ !  Copyright(c) 1994 SEGA
+ !  Written by H.E on 1994-06-22 Ver.1.00
+ !  Updated by H.E on 1994-06-22 Ver.1.00
+ !
+ !  このライブラリは法線ベクタ計算モジュールで、
+ !  以下のルーチンを含む。
+ !
+ !  _MTH_ComputeNormalVect       -  法線ベクタ計算関数
+ !
+ !----------------------------------------------------------------------------
+           .global     _MTH_ComputeNormVect
+ !
+ .if 1
+ .equ SAVE_r14,0
+ .equ NORMAL_P,4
+ 
+ .equ X,0
+ .equ Y,4
+ .equ Z,8
+ .endif
+ 
+ .if 0
+           .SECTION    CALL_STACK,DUMMY
+ SAVE_r14:  .long	    0
+ NORMAL_P:  .long      0
+ !
+           .SECTION    MthXyz,DUMMY
+ X:         .long      0
+ Y:         .long      0
+ Z:         .long      0
+ .endif
+ 
+ 
+           .section .text
+ 
+ !
+ !-----------------------------------------------------------------------------
+ !
+ ! NAME:  MTH_ComputeNormVect()  - Compute Normal Vector
+ !
+ !  void MTH_ComputeNormVect(Fixed32 surfNormK,
+ !			 MthXyz *p0, MthXyz *p1, MthXyz *p2, MthXyz *normal)
+ !
+ ! PARAMETERS :
+ !
+ ! 　　(1) Fixed32  surfNormK   - <i>  法線ベクトルの計算補正値
+ ! 　　(2) MthXyz   *p0         - <i>  頂点０
+ ! 　　(3) MthXyz   *p1         - <i>  頂点１
+ ! 　　(4) MthXyz   *p2         - <i>  頂点２
+ ! 　　(5) MthXyz   *normal     - <o>  法線
+ !
+ ! DESCRIPTION:
+ !
+ !     指定３頂点座標より法線ベクトル（単位ベクトル）を計算する
+ !
+ !
+ ! POSTCONDITIONS:
+ !
+ !
+ ! CAVEATS:
+ !
+ !-----------------------------------------------------------------------------
+ !
+ 	  .align 2
+ 
+ _MTH_ComputeNormVect:
+           MOV.L       r14,@-r15         ! save register
+           MOV         r15,r14
+           MOV.L       r11,@-r15
+           MOV.L       r10,@-r15
+           MOV.L       r9,@-r15
+           MOV.L       r8,@-r15
+           STS.L       pr,@-r15
+           STS.L       macl,@-r15
+           STS.L       mach,@-r15
+ !
+           CMP/pz      r4                ! r4 : surfNormK
+           BT.S        cnv_00            ! if(surfNormK >= 0) goto cnv00
+           MOV         #1,r8             ! r8 : sign = 1
+           MOV         #-1,r8            !      sign = -1
+           NEG         r4,r4             ! surfNormK *= -1
+ cnv_00:                                 ! r5 : p0, r6 : p1, r7 : p2
+ !
+           MOV.L       @(Z,r6),r0        ! b0z = (p1->z - p0->z) * surfNormK
+           MOV.L       @(Z,r5),r1
+           SUB         r1,r0
+ 	  DMULS.L     r0,r4
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@-r15          ! push b0z
+ !
+           MOV.L       @(Y,r6),r0        ! b0y = (p1->y - p0->y) * surfNormK
+           MOV.L       @(Y,r5),r1
+           SUB         r1,r0
+ 	  DMULS.L     r0,r4
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@-r15          ! push b0y
+ !
+           MOV.L       @(X,r6),r0        ! b0x = (p1->x - p0->x) * surfNormK
+           MOV.L       @(X,r5),r1
+           SUB         r1,r0
+ 	  DMULS.L     r0,r4
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@-r15          ! push b0x
+           MOV         r15,r2            ! @r2 = (b0x, b0y, b0z)
+ !
+           MOV.L       @(Z,r7),r0        ! b1z = (p2->z - p1->z) * surfNormK
+           MOV.L       @(Z,r6),r1
+           SUB         r1,r0
+ 	  DMULS.L     r0,r4
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@-r15          ! push b1z
+ !
+           MOV.L       @(Y,r7),r0        ! b1y = (p2->y - p1->y) * surfNormK
+           MOV.L       @(Y,r6),r1
+           SUB         r1,r0
+ 	  DMULS.L     r0,r4
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@-r15          ! push b1y
+ !
+           MOV.L       @(X,r7),r0        ! b1x = (p2->x - p1->x) * surfNormK
+           MOV.L       @(X,r6),r1
+           SUB         r1,r0
+ 	  DMULS.L     r0,r4
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@-r15          ! push b1x
+           MOV         r15,r3            ! @r3 = (b1x, b1y, b1z)
+ !
+           MOV.L       @(Z,r2),r0        ! nx = b0z*b1y - b0y*b1z
+           MOV.L       @(Y,r3),r1        ! r9     r9        r4
+ 	  DMULS.L     r0,r1
+  	  STS         mach,r1
+  	  STS	      macl,r9
+  	  XTRCT	      r1,r9
+           MOV.L       @(Y,r2),r0
+           MOV.L       @(Z,r3),r1
+ 	  DMULS.L     r0,r1
+  	  STS         mach,r1
+  	  STS	      macl,r4
+  	  XTRCT	      r1,r4
+           SUB         r4,r9
+ !
+           MOV.L       @(X,r2),r0        ! ny = b0x*b1z - b0z*b1x
+           MOV.L       @(Z,r3),r1        ! r10    r10       r4
+ 	  DMULS.L     r0,r1
+  	  STS         mach,r1
+  	  STS	      macl,r10
+  	  XTRCT	      r1,r10
+           MOV.L       @(Z,r2),r0
+           MOV.L       @(X,r3),r1
+ 	  DMULS.L     r0,r1
+  	  STS         mach,r1
+  	  STS	      macl,r4
+  	  XTRCT	      r1,r4
+           SUB         r4,r10
+ !
+           MOV.L       @(Y,r2),r0        ! nz = b0y*b1x - b0x*b1y
+           MOV.L       @(X,r3),r1        ! r11    r11       r4
+ 	  DMULS.L     r0,r1
+  	  STS         mach,r1
+  	  STS	      macl,r11
+  	  XTRCT	      r1,r11
+           MOV.L       @(X,r2),r0
+           MOV.L       @(Y,r3),r1
+ 	  DMULS.L     r0,r1
+  	  STS         mach,r1
+  	  STS	      macl,r4
+  	  XTRCT	      r1,r4
+           SUB         r4,r11
+ !
+ 	  DMULS.L     r9,r9             ! r4 : w = nx*nx + ny*ny + nz*nz
+  	  STS         mach,r1           !            r9     r10     r11
+  	  STS	      macl,r4
+  	  XTRCT	      r1,r4
+ 	  DMULS.L     r10,r10
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           ADD         r0,r4
+ 	  DMULS.L     r11,r11
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           ADD         r0,r4
+ !
+           MOV         #65,r2           ! r2 = 0.001
+           CMP/ge      r2,r4            ! if(w >= 0.001)
+           BT          cnv_01           !    goto cnv_01
+           MOV         #65,r4           ! w = 0.001
+ cnv_01:
+           MOV.L       FISQRT,r3
+           JSR         @r3
+           NOP
+           MUL.L       r8,r0
+           STS         macl,r4          ! w = FISQRT(w) * sign
+ !
+           MOV.L       @(NORMAL_P,r14),r7     ! @r7 : normal
+ !
+ 	  DMULS.L     r9,r4            ! normal->x = nx * w
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@(X,r7)
+ !
+ 	  DMULS.L     r10,r4           ! normal->y = ny * w
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@(Y,r7)
+ !
+ 	  DMULS.L     r11,r4            ! normal->z = nz * w
+  	  STS         mach,r1
+  	  STS	      macl,r0
+  	  XTRCT	      r1,r0
+           MOV.L       r0,@(Z,r7)
+ !
+           ADD         #24,r15           ! restore register
+           LDS.L       @r15+,mach
+           LDS.L       @r15+,macl
+           LDS.L       @r15+,pr
+           MOV.L       @r15+,r8
+           MOV.L       @r15+,r9
+           MOV.L       @r15+,r10
+           MOV.L       @r15+,r11
+           RTS
+           MOV.L       @r15+,r14
+ !
+ 	  .align 2
+ 
+ FISQRT:	  .long    _FISQRT
+ !
+ !
+ ! C interface:
+ !	  Fixed32 FISQRT(Fixed32 a)!
+ !
+ ! return:
+ !	  1/sqrt(a)
+ !
+ ! method:
+ !	  Newton-Raphson
+ !         xn+1 = xn*(3-a*xn*xn)/2
+ !
+ ! note:   macl, mach not saved
+ !
+ ! pgm:	  1994.05.14 by T. Suzuki (SEGA C/S Hard dpt.)
+ !
+ !
+ _FISQRT:
+ 	XOR	r0,r0
+ 	CMP/pl	r4		! if (a<=0) return 0!
+ 	BF	RETURN
+ 	MOV.L	C_1,r0
+ 	XOR	r6,r6
+ 	MOV.L	C_4,r7
+ NORMLZ:				! normalize 1/4 <= a < 1
+ 	CMP/ge	r0,r4
+ 	BF	NORMLZ2
+ 	ADD	#1,r6
+ 	BRA	NORMLZ
+ 	SHLr2	r4
+ NORMLZ2:
+ 	CMP/ge	r4,r7
+ 	BF	NEWTON
+ 	ADD	#-1,r6
+ 	BRA	NORMLZ2
+ 	SHLL2	r4
+ NEWTON:
+ 	MOV	#3,r5		! only 3 times do Newton
+ REPEAT:
+ 	DMULS.L	r0,r0
+ 	MOV.L	C_3,r1
+ 	STS	macl,r2
+ 	STS	mach,r3
+ 	XTRCT	r3,r2
+ 	DMULS.L	r4,r2
+ 	STS	macl,r2
+ 	STS	mach,r3
+ 	XTRCT	r3,r2
+ 	SUB	r2,r1
+ 	DMULS.L	r0,r1
+ 	STS	macl,r0
+ 	STS	mach,r3
+ 	XTRCT	r3,r0
+ 	SHAR	r0
+ 	DT	r5
+ 	BF	REPEAT
+ DENORMLZ:
+ 	TST	r6,r6
+ 	BT	RETURN
+ 	CMP/pl	r6
+ 	BF	DENORML2
+ 	ADD	#-1,r6
+ 	BRA	DENORMLZ
+ 	SHLR	r0
+ DENORML2:
+ 	ADD	#1,r6
+ 	BRA	DENORMLZ
+ 	SHLL	r0
+ RETURN:
+ 	RTS
+ 	NOP
+ !
+ 	.align 2
+ 
+ C_1:	.long	0x00010000	! const 1
+ C_3:	.long	0x00030000	! const 3
+ C_4:	.long	0x00004000	! const 1/4
+ !
+         .END
diff -crBN --binary sbl6/segalib/mth/mth_ps2d.s sbl6_patch/segalib/mth/mth_ps2d.s
*** sbl6/segalib/mth/mth_ps2d.s	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/mth/mth_ps2d.s	2021-04-21 19:17:26.000000000 -0400
***************
*** 0 ****
--- 1,163 ----
+ !-----------------------------------------------------------------------------
+ !   spr_fmat.src -- SPR ライブラリ FMAT モジュール
+ !   Copyright(c) 1994 SEGA
+ !   Written by T.S on 1994-01-24 Ver.0.80
+ !   Updated by H.E on 1994-02-15 Ver.0.80
+ !
+ !   このライブラリは透視変換処理モジュールで、
+ !   以下のルーチンを含む。
+ !
+ !   MTH_Pers2D              -  透視変換処理
+ !   MTH_ComputeBright       -  ポリゴンの隠面判定と輝度計算
+ !
+ !-----------------------------------------------------------------------------
+ !
+ 	.global _MTH_Pers2D
+ 	.global _MTH_ComputeBright
+ 	.section .text
+ 
+ !
+ !-----------------------------------------------------------------------------
+ !
+ !  NAME : MTH_Pers2D  -  Persepect 3D to 2D
+ !
+ !        void  MTH_Pers2D(MthXyz *p3d, MthXy *unitPixel, XyInt *p2d)!
+ !
+ !  PARAMETERS
+ !
+ !  　　(1) MthXyz   *p3d        - <i> r4 視点座標系３Ｄ頂点座標
+ !  　　(2) MthXy    *unitPixel  - <i> r5 スクリーンＸＹの単位ピクセル数
+ !  　　(3) XyInt    *p2d        - <o> r6 透視変換後スクリーン２Ｄ座標
+ !
+ !  DESCRIPTION
+ !
+ ! 	視点座標系の原点を視点として -1.0 のところにスクリーンを設定して３Ｄ
+ !       から２Ｄへの透視変換を行う。スクリーン上で 1.0 の大きさがスクリーン
+ !       ＸＹの単位ピクセル数に対応する。
+ !
+ !  POSTCONDITIONS
+ !
+ !  CAVEATS
+ !
+ !-----------------------------------------------------------------------------
+ !
+ 	.align 2
+ 
+ _MTH_Pers2D:
+  	STS.L	mach,@-r15
+  	STS.L	macl,@-r15
+ !
+ ! hz = MTH_Div(MTH_FIXED(1),p3d->z)!
+ !
+ 	MOV.L	A_DIV,r0           !* FIXED(1) / p3d->z *
+         MOV.L   @(8,r4),r1
+ 	MOV.L	r1,@r0             ! <- p3d->z
+ 	MOV	#1,r1
+ 	MOV.L	r1,@(0x10,r0)      ! <- 0x00000001 (upper)
+ 	MOV  	#0,r1
+ 	MOV.L	r1,@(0x14,r0)      ! <- 0x00000000 (lower)
+ !
+ ! wx = MTH_Mul(p3d->x,unitPixel->x)!
+ !
+         MOV.L   @r4+,r1            ! r1 = p3d->x
+         MOV.L   @r5+,r2            ! r2 = unitPixel->x
+ 	DMULS.L r1,r2              ! mach,L = r1 * r2
+  	STS 	mach,r1
+  	STS 	macl,r2            ! r1,r2 = mach,macl
+  	XTRCT	r1,r2	           ! -> r2
+ !
+ ! wy = MTH_Mul(p3d->y,unitPixel->y)!
+ !
+         MOV.L   @r4+,r3            ! r3 = p3d->x
+         MOV.L   @r5+,r4            ! r4 = unitPixel->x
+ 	DMULS.L r3,r4              ! mach,L = r3 * r4
+  	STS	mach,r3
+  	STS	macl,r4            ! r3,r4 = mach,macl
+  	XTRCT	r3,r4	           ! -> r4
+ !
+  	MOV.L	@(0x14,r0),r1      ! -> r1 (= 1/z)
+ !
+ ! p2d->x = MTH_FixedToInt(MTH_Mul(wx,hz))!
+ !
+ 	DMULS.L r1,r2              ! mach,L = x * (1/z)
+  	STS	mach,r2
+  	STS	macl,r3            ! r1,r2 = mach,macl
+  	XTRCT	r2,r0	           ! -> r3
+ 	SHLR16	r0
+ 	MOV.W	r0,@r6             ! r3 -> pers X
+ !
+ ! p2d->y = MTH_FixedToInt(MTH_Mul(wy,hz))!
+ !
+ 	DMULS.L r1,r4              ! mach,L = x * (1/z)
+  	STS	mach,r2
+  	STS	macl,r3            ! r1,r2 = mach,macl
+  	XTRCT	r2,r0	           ! -> r3
+  	LDS.L	@r15+,macl
+  	LDS.L	@r15+,mach
+ 	SHLR16	r0
+ 	RTS
+ 	MOV.W	r0,@(2,r6)         ! r3 -> pers Y
+ !
+ 	.align 2
+ 
+ A_DIV:	.long	0xFFFFFF00
+ !
+ !
+ !--------------------------------------------------------------------------
+ !
+ ! NAME : MTH_ComputeBright  -  Compute Brightness
+ !
+ ! PARAMETERS
+ !
+ ! 　　(1) MthXyz   *lightVector   - <i> 光源ベクトル
+ ! 　　(2) MthXyz   *normalVector  - <i> ポリゴンの法線ベクトル
+ !
+ ! DESCRIPTION
+ !
+ !      光源ベクトルからポリゴン面の輝度を返す。
+ !
+ ! POSTCONDITIONS
+ !
+ !      Sint32   bright  :  0（暗） から 31（明）
+ !
+ ! CAVEATS
+ !
+ !-------------------------------------------------------------------------
+ !
+ 	.align 2
+ 
+ _MTH_ComputeBright:
+  	STS	mach,r1
+  	STS	macl,r2
+ !
+ ! product = MTH_Product((Fixed32*)normVector, (Fixed32*)lightVector)!
+ !
+ 	CLRMAC
+ 	MAC.L   @r4+,@r5+
+ 	MAC.L   @r4+,@r5+
+ 	MAC.L   @r4+,@r5+
+  	STS	mach,r3
+  	STS	macl,r0
+ !
+ ! color = MTH_FixedToInt((product + MTH_FIXED(1.0)) * (32/2))!
+ !
+ 	ADD	#1,r3
+  	XTRCT	r3,r0	! xtract for Fixed32
+ 	MOV	#16,r3
+ 	DMULS.L r3,r0
+  	STS	mach,r3
+  	STS	macl,r0
+ 	SHLR16	r0
+ !
+ ! return  color & 0x1f!
+ !
+  	LDS	r1,mach
+  	LDS	r2,macl
+ 	RTS
+ 	AND	#0x1f,r0
+ 	NOP
+ !
+ !---------------------------------------------------------------------
+ 	.end
+ !---------------------------------------------------------------------
+ !   end of file
diff -crBN --binary sbl6/segalib/mth/mth_tri.s sbl6_patch/segalib/mth/mth_tri.s
*** sbl6/segalib/mth/mth_tri.s	1969-12-31 19:00:00.000000000 -0500
--- sbl6_patch/segalib/mth/mth_tri.s	2021-04-21 19:17:26.000000000 -0400
***************
*** 0 ****
--- 1,551 ----
+ !*----------------------------------------------------------------------------
+ !*  mth_trif.c -- MTH ライブラリ 三角関数 モジュール
+ !*  Copyright(c) 1994 SEGA
+ !*  Written by H.E on 1994-04-28 Ver.0.80
+ !*  Updated by H.E on 1994-04-28 Ver.0.80
+ !*
+ !*  このライブラリは数学計算ライブラリの三角関数 モュールで、
+ !*  以下のルーチンを含む。
+ !*
+ !*  MTH_Sin                 -  ｓｉｎ関数
+ !*  MTH_Cin                 -  ｃｏｓ関数
+ !*  MTH_Atan                -  ａｔａｎ関数
+ !*
+ !*----------------------------------------------------------------------------
+ !
+           .global     _MTH_Sin
+           .global     _MTH_Cos
+           .global     _MTH_Atan
+           .global     _fsin
+           .global     _fcos
+ 
+ 	  .section .text
+ 
+ !
+ !
+ !*****************************************************************************
+ !*
+ !* NAME:  MTH_Sin()  - Return Sin Value
+ !*
+ !*     Fixed32 MTH_Sin(Fixed32 degree)!
+ !*
+ !* PARAMETERS :
+ !*
+ !* 　　(1) Fixed32   degree - <i> -180.0 から 180.0 までの角度
+ !*
+ !* DESCRIPTION:
+ !*
+ !*     指定角度の sin値を返す
+ !*
+ !*
+ !* POSTCONDITIONS:
+ !*
+ !*     Fixed32 sin値
+ !*
+ !* CAVEATS:
+ !*
+ !*****************************************************************************
+ !
+ 
+ 	.align 2
+ 
+ _MTH_Sin:                              ! function: MTH_Sin
+           MOV.L       r14,@-r15        ! r4  : degree
+           STS.L       pr,@-r15         ! r14 : sign
+ !
+           CMP/pz      r4               ! if(degree >= MTH_FIXED(0))
+           BT.S        sin_0            !    sign = 0
+           MOV         #0,r14           !    goto sin_0
+           MOV         #1,r14           ! sign = 1
+           NEG         r4,r4            ! degree  = -degree
+ sin_0:
+           MOV.L       sin_f180,r2      ! r2 = MTH_FIXED(180)
+           CMP/ge      r2,r4            ! if(degree < r2)
+           BF          sin_1            !    goto sin_1
+           BRA         sin_2            ! degree = MTH_FIXED(0)
+           MOV         #0,r4            ! goto sin_2
+ sin_1:
+           MOV.L       sin_f90,r3       ! r3 = MTH_FIXED(90)
+           CMP/gt      r3,r4            ! if(degree <= r3)
+           BF          sin_2            !    goto sin_2
+           SUB         r4,r2            !
+           MOV         r2,r4            ! degree = r2 - degree
+ sin_2:
+           MOV.L       fsin,r3
+           JSR         @r3              ! r0 = fsin(degree)
+           NOP
+           TST         r14,r14          ! if(sign == 0)
+           BT          sin_3            !    goto sin_3
+           NEG         r0,r0            ! r0 = -r0
+ sin_3:
+           LDS.L       @r15+,pr
+           RTS                          ! return r0
+           MOV.L       @r15+,r14
+ !
+ 	  .align 2
+ 
+ sin_f180: .long     0x00B40000       ! MTH_FIXED(180)
+ sin_f90:  .long     0x005A0000       ! MTH_FIXED(90)
+ fsin:     .long     _fsin
+ !
+ !
+ !*****************************************************************************
+ !*
+ !* NAME:  MTH_Cos()  - Return Cos Value
+ !*
+ !*     Fixed32 MTH_Cos(Fixed32 degree)!
+ !*
+ !* PARAMETERS :
+ !*
+ !* 　　(1) Fixed32   degree - <i> -180.0 から 180.0 までの角度
+ !*
+ !* DESCRIPTION:
+ !*
+ !*     指定角度の cos値を返す
+ !*
+ !*
+ !* POSTCONDITIONS:
+ !*
+ !*     Fixed32 cos値
+ !*
+ !* CAVEATS:
+ !*
+ !*****************************************************************************
+ !
+ _MTH_Cos:                              ! function: MTH_Cos
+           MOV.L       r14,@-r15        ! r4  : degree
+           STS.L       pr,@-r15         ! r14 : sign
+ !
+           CMP/pz      r4               ! if(degree >= MTH_FIXED(0))
+           BT          cos_0            !    goto cos_0
+           NEG         r4,r4            ! degree = -degree
+ cos_0:
+           MOV.L       cos_f180,r2      ! r2 = MTH_FIXED(180)
+           CMP/ge      r2,r4            ! sin = 1
+           BF.s        cos_1            ! if(degree < MTH_FIXED(180))
+           MOV         #1,r14           !    goto cos_1
+           BRA         cos_4            ! degree = MTH_FIXED(0)
+           MOV         #0,r4            ! goto cos_4
+ cos_1:
+           MOV.L       cos_f90,r2       ! r2 = MTH_FIXED(90)
+           CMP/gt      r2,r4            ! if(degree > MTH_FIXED(90))
+           BF          cos_2            !    goto cos_2
+           MOV.L       cos_f180,r2      ! r2 = MTH_FIXED(180)
+           SUB         r4,r2            ! r2 -= degree
+           BRA         cos_4            ! degree = r2
+           MOV         r2,r4            ! goto cos_4
+ cos_2:
+           MOV         #0,r14           ! sign = 0
+ cos_4:
+           MOV.L       fcos,r3
+           JSR         @r3              ! r0 = fcos(degree)
+           NOP
+           TST         r14,r14          ! if(sign == 0)
+           BT          cos_5            !    goto cos_5
+           NEG         r0,r0            ! r0 = -r0
+ cos_5:
+           LDS.L       @r15+,pr
+           RTS                          ! return r0
+           MOV.L       @r15+,r14
+ !
+ 	  .align 2
+ 
+ cos_f180: .long     0x00B40000       ! MTH_FIXED(180)
+ cos_f90:  .long     0x005A0000       ! MTH_FIXED(90)
+ fcos:     .long     _fcos
+ !
+ !
+ !*****************************************************************************
+ !*
+ !*      Cosine(a) Subroutine
+ !*      Cosine(a) = Sine(90-a)
+ !*      In :a		(r4)
+ !*      Out:Cosine(a)   (r0)
+ !*
+ !*****************************************************************************
+ _fcos:
+ 	MOV.L	NINTY,r2	!90-a ->r4
+ 	NEG	r4,r4
+ 	ADD	r2,r4
+ !
+ !
+ !*****************************************************************************
+ !*
+ !*      Sine (a) Subroutine
+ !*      In:a = angle (0 - 89)(r4)
+ !*      Out:Sine(a)          (r0)
+ !*
+ !*****************************************************************************
+ !
+ _fsin:
+ 	MOVA	SINTBL,r0	!sine table start address ->r1
+ 	STS	macl,r3
+ 
+ 	SWAP.W	r4,r1
+ 	EXTU.W	r1,r1
+ 	SHLL2	r1		!r0<-Entry of The Table
+ 	MOV.W	@(r0,r1),r2	!sin(a) GRAD->r2
+ 
+ 	ADD	#2,r0
+ 	MULU	r4,r2
+ 	MOV.W	@(r0,r1),r0	!sin(a) value->r0
+ 	STS	macl,r2
+ 	EXTU.W	r0,r0
+ 	LDS	r3,macl
+ 	SWAP.W	r2,r2
+ 	EXTU.W	r2,r2
+ 	RTS
+ 	ADD	r2,r0
+ !
+ !	Constant Data definiton
+ 
+ 	.align 2
+ 
+ NINTY:	.long	0x005A0000	!90
+ 
+ !Sine Table Data Area(AREA SIZE = 91 x 2 x 2 = 364BYTES
+ !	 ALIGN=4
+ SINTBL:
+ !	         delta, value
+ 	.word	0x0477,0x0000		!00deg
+ 	.word	0x0478,0x0477		!01deg
+ 	.word	0x0476,0x08EF		!02deg
+ 	.word	0x0476,0x0D65		!03deg
+ 	.word	0x0474,0x11DB		!04deg
+ 	.word	0x0473,0x164F		!05deg
+ 	.word	0x0470,0x1AC2		!06deg
+ 	.word	0x046E,0x1F32		!07deg
+ 	.word	0x046C,0x23A0		!08deg
+ 	.word	0x0468,0x280C		!09deg
+ 	.word	0x0464,0x2C74		!10deg
+ 	.word	0x0461,0x30D8		!11deg
+ 	.word	0x045D,0x3539		!12deg
+ 	.word	0x0458,0x3996		!13deg
+ 	.word	0x0453,0x3DEE		!14deg
+ 	.word	0x044F,0x4241		!15deg
+ 	.word	0x0448,0x4690		!16deg
+ 	.word	0x0443,0x4AD8		!17deg
+ 	.word	0x043D,0x4F1B		!18deg
+ 	.word	0x0436,0x5358		!19deg
+ 	.word	0x0430,0x578E		!20deg
+ 	.word	0x0428,0x5BBE		!21deg
+ 	.word	0x0420,0x5FE6		!22deg
+ 	.word	0x0419,0x6406		!23deg
+ 	.word	0x0411,0x681F		!24deg
+ 	.word	0x0409,0x6C30		!25deg
+ 	.word	0x03FF,0x7039		!26deg
+ 	.word	0x03F7,0x7438		!27deg
+ 	.word	0x03ED,0x782F		!28deg
+ 	.word	0x03E3,0x7C1C		!29deg
+ 	.word	0x03DA,0x7FFF		!30deg
+ 	.word	0x03CF,0x83D9		!31deg
+ 	.word	0x03C5,0x87A8		!32deg
+ 	.word	0x03BA,0x8B6D		!33deg
+ 	.word	0x03AE,0x8F27		!34deg
+ 	.word	0x03A4,0x92D5		!35deg
+ 	.word	0x0397,0x9679		!36deg
+ 	.word	0x038B,0x9A10		!37deg
+ 	.word	0x0380,0x9D9B		!38deg
+ 	.word	0x0372,0xA11B		!39deg
+ 	.word	0x0366,0xA48D		!40deg
+ 	.word	0x0359,0xA7F3		!41deg
+ 	.word	0x034B,0xAB4C		!42deg
+ 	.word	0x033E,0xAE97		!43deg
+ 	.word	0x032F,0xB1D5		!44deg
+ 	.word	0x0322,0xB504		!45deg
+ 	.word	0x0313,0xB826		!46deg
+ 	.word	0x0305,0xBB39		!47deg
+ 	.word	0x02F6,0xBE3E		!48deg
+ 	.word	0x02E7,0xC134		!49deg
+ 	.word	0x02D8,0xC41B		!50deg
+ 	.word	0x02C8,0xC6F3		!51deg
+ 	.word	0x02B8,0xC9BB		!52deg
+ 	.word	0x02A8,0xCC73		!53deg
+ 	.word	0x0298,0xCF1B		!54deg
+ 	.word	0x0288,0xD1B3		!55deg
+ 	.word	0x0278,0xD43B		!56deg
+ 	.word	0x0266,0xD6B3		!57deg
+ 	.word	0x0256,0xD919		!58deg
+ 	.word	0x0244,0xDB6F		!59deg
+ 	.word	0x0234,0xDDB3		!60deg
+ 	.word	0x0221,0xDFE7		!61deg
+ 	.word	0x0211,0xE208		!62deg
+ 	.word	0x01FE,0xE419		!63deg
+ 	.word	0x01EC,0xE617		!64deg
+ 	.word	0x01DB,0xE803		!65deg
+ 	.word	0x01C8,0xE9DE		!66deg
+ 	.word	0x01B5,0xEBA6		!67deg
+ 	.word	0x01A4,0xED5B		!68deg
+ 	.word	0x0190,0xEEFF		!69deg
+ 	.word	0x017E,0xF08F		!70deg
+ 	.word	0x016B,0xF20D		!71deg
+ 	.word	0x0158,0xF378		!72deg
+ 	.word	0x0145,0xF4D0		!73deg
+ 	.word	0x0131,0xF615		!74deg
+ 	.word	0x011F,0xF746		!75deg
+ 	.word	0x010B,0xF865		!76deg
+ 	.word	0x00F7,0xF970		!77deg
+ 	.word	0x00E4,0xFA67		!78deg
+ 	.word	0x00D1,0xFB4B		!79deg
+ 	.word	0x00BD,0xFC1C		!80deg
+ 	.word	0x00A9,0xFCD9		!81deg
+ 	.word	0x0095,0xFD82		!82deg
+ 	.word	0x0081,0xFE17		!83deg
+ 	.word	0x006E,0xFE98		!84deg
+ 	.word	0x005A,0xFF06		!85deg
+ 	.word	0x0046,0xFF60		!86deg
+ 	.word	0x0032,0xFFA6		!87deg
+ 	.word	0x001E,0xFFD8		!88deg
+ 	.word	0x000A,0xFFF6		!89deg
+ 	.word	0x0000,0xFFFF		!90deg
+ !
+ !
+ !*****************************************************************************
+ !*
+ !* NAME:  MTH_Atan()  - Return Atan Value
+ !*
+ !*     Fixed32 MTH_Atan(Fixed32 y, Fixed32 x)!
+ !*
+ !* PARAMETERS :
+ !*
+ !* 　　(1) Fixed32   y     - <i> -1.0 から 1.0 までの高さ
+ !* 　　(2) Fixed32   x     - <i> -1.0 から 1.0 までの底辺
+ !*
+ !* DESCRIPTION:
+ !*
+ !*     指定 x, y 値から角度を返す
+ !*
+ !*
+ !* POSTCONDITIONS:
+ !*
+ !*     Fixed32 -180.0 から 180.0 までの角度
+ !*
+ !* CAVEATS:
+ !*
+ !*****************************************************************************
+ !
+ _MTH_Atan:                       ! function: MTH_Atan
+           MOV.L       r14,@-r15
+           MOV.L       r13,@-r15
+           MOV.L       r12,@-r15
+           MOV.L       r11,@-r15
+           MOV.L       r10,@-r15
+           MOV.L       r9,@-r15
+  	  			STS.L	      mach,@-r15
+  	  			STS.L	      macl,@-r15
+           MOV         r5,r10           ! r10 = x
+           STS.L       pr,@-r15
+ !
+           MOV.L       rTanTbl,r11      ! r11 = tanTbl pointer
+ 
+           CMP/pz      r10              ! r12 = y
+           BT.s        atan_0           ! if(x >= 0)
+           MOV         r4,r12           !    goto atan_0
+           NEG         r10,r5           ! r5 : ax = -x
+ atan_0:
+           CMP/pz      r12              ! if(y >= 0)
+           BT          atan_2           !    goto atan_2
+           NEG         r12,r4           ! r4 : ay = -y
+ atan_2:
+           MOV         #65,r2           ! r2 = MTH_FIXED(0.001)
+           CMP/ge      r2,r5            ! if(ax >= r2)
+           BT          atan_4           !    goto atan_4
+           MOV.L       atan_fmax,r13    ! r13 : w =  0x7fff0000
+           BRA         atan_5           ! goto atan_5
+           NOP
+ atan_4:
+ 	  MOV.L	      A_DIV,r0
+ 	  SWAP.W      r4,r2	       ! make r2:r4 64bit pair
+ 	  MOV.L	      r5,@r0
+ 	  EXTS.W      r2,r2            !  0  r4H   r4L  0
+ 	  MOV.L	      r2,@(0x10,r0)
+ 	  SHLL16      r4
+ 	  MOV.L	      r4,@(0x14,r0)
+  	  MOV.L	      @(0x14,r0),r13   ! r13 : w = ay / ax
+ atan_5:
+           MOV         #0,r4            ! r4 : left  = 0
+           MOV         #90,r5           ! r5 : right = 90
+ atan_6:
+           MOV         r4,r14
+           ADD         r5,r14
+           SHAR        r14              ! r14 : mid = (left + right) >> 1
+           MOV         r14,r0
+           SHLL2       r0
+           SHLL        r0               ! r0 = mid * 8
+           MOV.L       @(r0,r11),r2     ! r2 = tanTbl[mid].val
+           CMP/gt      r13,r2           ! if(r2 > w)
+           BT          atan_7           !    goto atan_7
+           MOV         r14,r4
+           ADD         #1,r4            ! r4 : left = mid + 1
+           MOV         r4,r0
+           SHLL2       r0
+           SHLL        r0               ! r0 = left * 8
+           MOV.L       @(r0,r11),r3     ! r2 = tanTbl[left].val
+           CMP/ge      r3,r13           ! if(w >= r3)
+           BT          atan_8           !    goto atan_8
+           BRA         atan_9           ! goto atan_9 (break)
+           NOP
+ atan_7:
+           MOV         r14,r5           ! r5 : right = mid
+ atan_8:
+           CMP/ge      r5,r4            ! if(left < right)
+           BF          atan_6           !   goto atan_6
+ atan_9:
+           MOV         r14,r0           ! r0 : mid
+           MOV         r13,r4           ! r4 : w
+           SHLL2       r0
+           SHLL        r0               ! r0 = mid * 8
+           MOV.L       @(r0,r11),r3     ! r3 = tanTbl[mid].val
+           SUB         r3,r4            ! r4 : w - r3
+           ADD         #4,r0
+           MOV.L       @(r0,r11),r5     ! r5 : tanTbl[mid].k
+ 	  			DMULS.L     r4,r5
+  	  			STS	      mach,r3
+  	  			STS	      macl,r4
+  	  			XTRCT	      r3,r4	       ! r4 : degree = MTH_Mul(r4,r5)
+           MOV.L       atan_f1,r2       ! r2 = MTH_FIXED(1.0)
+           CMP/gt      r2,r4            ! if(degree <= MTH_FIXED(1.0))
+           BF          atan_10          !    goto atan_10
+           MOV.L       atan_f1,r4       ! r4 : degree = MTH_FIXED(1.0)
+ atan_10:
+ 	  			MOV  	      r14,r0
+ 	  			SHLL16      r0               ! r0 = MTH_IntToFixed(mid)
+ 
+           CMP/pz      r12              ! r4 : degree + = r0
+           BT.S        atan_11          ! if(y >= MTH_FIXED(0))
+           ADD         r0,r4            !    goto atan_11
+           NEG         r4,r4            ! r4 : degree = -degree
+ atan_11:
+           CMP/pz      r10              ! if(x >= MTH_FIXED(0))
+           BT          atan_14          !    goto atan_14
+           CMP/pz      r12              ! if(y < MTH_FIXED(0))
+           BF          atan_12          !    goto atan_12
+           MOV.L       atan_f180,r2     ! r2 = MTH_FIXED(180.0)
+           BRA         atan_13          ! goto atan_13
+           NOP
+ atan_12:
+           MOV.L       atan_fm180,r2    ! r2 = MTH_FIXED(-180.0)
+ atan_13:
+           SUB         r4,r2
+           MOV         r2,r4            ! r4 = r2 - degree
+ atan_14:
+           MOV         r4,r0            ! r0 = r4
+           LDS.L       @r15+,pr
+  	  			LDS.L      	@r15+,macl
+  	  			LDS.L      	@r15+,mach
+           MOV.L       @r15+,r9
+           MOV.L       @r15+,r10
+           MOV.L       @r15+,r11
+           MOV.L       @r15+,r12
+           MOV.L       @r15+,r13
+           RTS                          ! return r0
+           MOV.L       @r15+,r14
+ !
+ 	.align 2
+ 
+ A_DIV:
+ 	  			.long     0xFFFFFF00
+ rTanTbl:
+           .long     tanTbl
+ atan_fmax:
+           .long     0x7FFF0000
+ atan_f1:
+           .long     0x00010000
+ atan_f180:
+           .long     0x00B40000
+ atan_fm180:
+           .long     0xFF4C0000
+ tanTbl:                            ! static: tanTbl
+           .long      0x00000000,0x00394A3A    !/*   0 */
+           .long      0x00000477,0x0039414B    !/*   1 */
+           .long      0x000008F0,0x00392F70    !/*   2 */
+           .long      0x00000D6A,0x003914AD    !/*   3 */
+           .long      0x000011E6,0x0038F10C    !/*   4 */
+           .long      0x00001665,0x0038C498    !/*   5 */
+           .long      0x00001AE8,0x00388F5F    !/*   6 */
+           .long      0x00001F6E,0x00385170    !/*   7 */
+           .long      0x000023FA,0x00380AE0    !/*   8 */
+           .long      0x0000288B,0x0037BBC4    !/*   9 */
+           .long      0x00002D23,0x00376435    !/*  10 */
+           .long      0x000031C2,0x0037044F    !/*  11 */
+           .long      0x0000366A,0x00369C2F    !/*  12 */
+           .long      0x00003B1A,0x00362BF6    !/*  13 */
+           .long      0x00003FD3,0x0035B3C7    !/*  14 */
+           .long      0x00004498,0x003533C7    !/*  15 */
+           .long      0x00004968,0x0034AC1E    !/*  16 */
+           .long      0x00004E44,0x00341CF7    !/*  17 */
+           .long      0x0000532D,0x0033867E    !/*  18 */
+           .long      0x00005825,0x0032E8E2    !/*  19 */
+           .long      0x00005D2D,0x00324454    !/*  20 */
+           .long      0x00006244,0x00319908    !/*  21 */
+           .long      0x0000676E,0x0030E733    !/*  22 */
+           .long      0x00006CAA,0x00302F0C    !/*  23 */
+           .long      0x000071FA,0x002F70CD    !/*  24 */
+           .long      0x0000775F,0x002EACB2    !/*  25 */
+           .long      0x00007CDC,0x002DE2F7    !/*  26 */
+           .long      0x00008270,0x002D13DB    !/*  27 */
+           .long      0x0000881E,0x002C3F9F    !/*  28 */
+           .long      0x00008DE7,0x002B6686    !/*  29 */
+           .long      0x000093CD,0x002A88D2    !/*  30 */
+           .long      0x000099D2,0x0029A6C9    !/*  31 */
+           .long      0x00009FF7,0x0028C0B2    !/*  32 */
+           .long      0x0000A63F,0x0027D6D3    !/*  33 */
+           .long      0x0000ACAC,0x0026E978    !/*  34 */
+           .long      0x0000B340,0x0025F8E8    !/*  35 */
+           .long      0x0000B9FE,0x0025056F    !/*  36 */
+           .long      0x0000C0E8,0x00240F5A    !/*  37 */
+           .long      0x0000C802,0x002316F5    !/*  38 */
+           .long      0x0000CF4E,0x00221C8D    !/*  39 */
+           .long      0x0000D6CF,0x00212071    !/*  40 */
+           .long      0x0000DE89,0x002022EE    !/*  41 */
+           .long      0x0000E680,0x001F2455    !/*  42 */
+           .long      0x0000EEB9,0x001E24F5    !/*  43 */
+           .long      0x0000F737,0x001D251D    !/*  44 */
+           .long      0x00010000,0x001C251D    !/*  45 */
+           .long      0x00010918,0x001B2545    !/*  46 */
+           .long      0x00011286,0x001A25E5    !/*  47 */
+           .long      0x00011C51,0x0019274C    !/*  48 */
+           .long      0x0001267E,0x001829C9    !/*  49 */
+           .long      0x00013116,0x00172DAD    !/*  50 */
+           .long      0x00013C22,0x00163345    !/*  51 */
+           .long      0x000147AA,0x00153AE0    !/*  52 */
+           .long      0x000153B9,0x001444CB    !/*  53 */
+           .long      0x0001605A,0x00135152    !/*  54 */
+           .long      0x00016D9B,0x001260C2    !/*  55 */
+           .long      0x00017B89,0x00117366    !/*  56 */
+           .long      0x00018A34,0x00108988    !/*  57 */
+           .long      0x000199AF,0x000FA371    !/*  58 */
+           .long      0x0001AA0E,0x000EC168    !/*  59 */
+           .long      0x0001BB67,0x000DE3B4    !/*  60 */
+           .long      0x0001CDD6,0x000D0A9B    !/*  61 */
+           .long      0x0001E177,0x000C365F    !/*  62 */
+           .long      0x0001F66D,0x000B6743    !/*  63 */
+           .long      0x00020CE0,0x000A9D88    !/*  64 */
+           .long      0x000224FE,0x0009D96D    !/*  65 */
+           .long      0x00023EFC,0x00091B2E    !/*  66 */
+           .long      0x00025B19,0x00086307    !/*  67 */
+           .long      0x0002799F,0x0007B132    !/*  68 */
+           .long      0x00029AE7,0x000705E6    !/*  69 */
+           .long      0x0002BF5A,0x00066158    !/*  70 */
+           .long      0x0002E77A,0x0005C3BC    !/*  71 */
+           .long      0x000313E3,0x00052D43    !/*  72 */
+           .long      0x00034556,0x00049E1C    !/*  73 */
+           .long      0x00037CC7,0x00041673    !/*  74 */
+           .long      0x0003BB67,0x00039673    !/*  75 */
+           .long      0x000402C2,0x00031E44    !/*  76 */
+           .long      0x000454DB,0x0002AE0B    !/*  77 */
+           .long      0x0004B462,0x000245EB    !/*  78 */
+           .long      0x00052501,0x0001E605    !/*  79 */
+           .long      0x0005ABD9,0x00018E76    !/*  80 */
+           .long      0x00065052,0x00013F5A    !/*  81 */
+           .long      0x00071D88,0x0000F8CA    !/*  82 */
+           .long      0x000824F3,0x0000BADB    !/*  83 */
+           .long      0x000983AD,0x000085A2    !/*  84 */
+           .long      0x000B6E17,0x0000592D    !/*  85 */
+           .long      0x000E4CF8,0x0000358D    !/*  86 */
+           .long      0x001314C5,0x00001ACA    !/*  87 */
+           .long      0x001CA2E1,0x000008EF    !/*  88 */
+           .long      0x00394A3A,0x00000105    !/*  89 */
+           .long      0x7FFFFFFF,0x00000000    !/*  90 */
+ 
+ 					.END
diff -crBN --binary sbl6/segalib/pcm/pcm_lib.c sbl6_patch/segalib/pcm/pcm_lib.c
*** sbl6/segalib/pcm/pcm_lib.c	1996-02-08 05:25:12.000000000 -0500
--- sbl6_patch/segalib/pcm/pcm_lib.c	2024-05-19 20:23:24.000000000 -0400
***************
*** 281,286 ****
--- 281,289 ----
  	case PCM_STAT_PLAY_CREATE:
  	case PCM_STAT_PLAY_START:
  		return 0;
+ 	default:
+ 		// ERROR CASE TBD
+ 		return -1;
  	}
  	return PCM_INFO_SAMPLING_RATE(&st->info);
  }
***************
*** 793,796 ****
  		return FALSE;
  	}
  }
! 
\ No newline at end of file
--- 796,799 ----
  		return FALSE;
  	}
  }
! 
diff -crBN --binary sbl6/segalib/pcm/pcm_mp.c sbl6_patch/segalib/pcm/pcm_mp.c
*** sbl6/segalib/pcm/pcm_mp.c	1996-02-08 05:25:14.000000000 -0500
--- sbl6_patch/segalib/pcm/pcm_mp.c	2023-01-08 16:18:34.000000000 -0500
***************
*** 275,281 ****
  	pcm_InitClock();
  	pcm_InitPcm();
  	pcm_InitErr();
! 	strncpy(pcm_version, PCM_VERSION, PCM_VERSION_LEN);
  	for (i = 0; i < PCM_HN_MAX; i++) {
  		pcm_hn_tbl[i] = (PcmHn)((i << 24) | (i << 16) | (i << 8) | i);
  	}
--- 275,281 ----
  	pcm_InitClock();
  	pcm_InitPcm();
  	pcm_InitErr();
! 	strncpy((char *)pcm_version, PCM_VERSION, PCM_VERSION_LEN);
  	for (i = 0; i < PCM_HN_MAX; i++) {
  		pcm_hn_tbl[i] = (PcmHn)((i << 24) | (i << 16) | (i << 8) | i);
  	}
***************
*** 1331,1336 ****
--- 1331,1337 ----
  	work 	= *(PcmWork **)pcm_hn_next;
  	st 		= &work->status;
  	para 	= &work->para;
+ 	(void)para;
  
  	if ((st->ring_write_offset <= 0) ||
  		(st->ring_write_offset < PCM_HN_START_TRG_SIZE(pcm_hn_next))) {
***************
*** 1511,1514 ****
  	}
  	return;
  }
! 
\ No newline at end of file
--- 1512,1515 ----
  	}
  	return;
  }
! 
diff -crBN --binary sbl6/segalib/pcm/pcm_stm.c sbl6_patch/segalib/pcm/pcm_stm.c
*** sbl6/segalib/pcm/pcm_stm.c	1996-02-08 05:25:14.000000000 -0500
--- sbl6_patch/segalib/pcm/pcm_stm.c	2023-01-08 11:59:24.000000000 -0500
***************
*** 767,773 ****
  	Sint32		ret;
  #endif
  	para = PCM_MeGetPara(pcm);
! 
  	load_size = 0;
  
  	/* リングバッファの空きバイト数を得る */
--- 767,774 ----
  	Sint32		ret;
  #endif
  	para = PCM_MeGetPara(pcm);
! 	(void)para;
! 	
  	load_size = 0;
  
  	/* リングバッファの空きバイト数を得る */
***************
*** 827,830 ****
  	/* 転送関数の設定 */
  	STM_SetTrFunc(PCMSTM_HANDLE(pcm), PCMSTM_LOAD_FUNC(pcm), pcm);
  }
! 
\ No newline at end of file
--- 828,831 ----
  	/* 転送関数の設定 */
  	STM_SetTrFunc(PCMSTM_HANDLE(pcm), PCMSTM_LOAD_FUNC(pcm), pcm);
  }
! 
diff -crBN --binary sbl6/segalib/scl/scl_fu03.c sbl6_patch/segalib/scl/scl_fu03.c
*** sbl6/segalib/scl/scl_fu03.c	1995-09-29 10:38:48.000000000 -0400
--- sbl6_patch/segalib/scl/scl_fu03.c	2022-01-17 19:53:04.000000000 -0500
***************
*** 417,422 ****
--- 417,424 ----
  
  		    }
  		    break;
+ 		default:
+ 			exit(0);
  	}
  /*
   *	Set Map Address
***************
*** 475,478 ****
  	}
  	if(SclProcess == 0)	SclProcess = 1;
  }
! 
\ No newline at end of file
--- 477,480 ----
  	}
  	if(SclProcess == 0)	SclProcess = 1;
  }
! 
diff -crBN --binary sbl6/segalib/scl/scl_func.c sbl6_patch/segalib/scl/scl_func.c
*** sbl6/segalib/scl/scl_func.c	1996-04-01 07:31:58.000000000 -0500
--- sbl6_patch/segalib/scl/scl_func.c	2024-08-19 13:21:50.000000000 -0400
***************
*** 8,29 ****
   *
   *  AUTHOR(S):
   *	K.M
!  *		
   *  MOD HISTORY:
   *	Written by K.M on 1994-06-21 Ver.1.00
   *	Updated by K.M on 1994-06-22 Ver.1.00
   *	Updated by Chikahiro Yoshida on 1995-07-19 Ver.1.00a
!  *				詳細は SCL_CopyReg()のヘッダを参照
   *	Updated by N.K on 1996-03-19 Ver.1.00b
   *------------------------------------------------------------------------
   */
  
  #define SEGA_SCL_PROTO
  
! #include <sega_scl.h> 
! #include <sega_dma.h> 
! #include	<sgl_work.h>
! #include	<sgl.h>
  
  #define	DMAOFF
  
--- 8,29 ----
   *
   *  AUTHOR(S):
   *	K.M
!  *
   *  MOD HISTORY:
   *	Written by K.M on 1994-06-21 Ver.1.00
   *	Updated by K.M on 1994-06-22 Ver.1.00
   *	Updated by Chikahiro Yoshida on 1995-07-19 Ver.1.00a
!  *				ｿｽﾚ細ゑｿｽ SCL_CopyReg()ｿｽﾌヘｿｽbｿｽ_ｿｽｿｽｿｽQｿｽｿｽ
   *	Updated by N.K on 1996-03-19 Ver.1.00b
   *------------------------------------------------------------------------
   */
  
  #define SEGA_SCL_PROTO
  
! #include <sega_scl.h>
! #include <sega_dma.h>
! //#include	<sgl_work.h>
! //#include	<sgl.h>
  
  #define	DMAOFF
  
***************
*** 31,37 ****
  #define	SBL		0x00
  
  
! /* ラインスクロール、セルスクロール関連 */
  	Uint32	SclAddrLsTbl[2];
  	Uint32	SclAddrCsTbl[2];
  	Uint16	SclLengthLsTbl = 0;
--- 31,37 ----
  #define	SBL		0x00
  
  
! /* ｿｽｿｽｿｽCｿｽｿｽｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽAｿｽZｿｽｿｽｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾖ連 */
  	Uint32	SclAddrLsTbl[2];
  	Uint32	SclAddrCsTbl[2];
  	Uint16	SclLengthLsTbl = 0;
***************
*** 43,61 ****
  	Uint32	SclCurSclNum =0;
  	Uint16	SclProcess = 0;
  
! /* 画面サイズデフォルト */
  	Uint16	SclDisplayX = 320;
  	Uint16	SclDisplayY = 224;
  
! /* レジスタバッファ */
  	SclSysreg	Scl_s_reg;
  	SclDataset	Scl_d_reg;
  	SclNorscl	Scl_n_reg;
  	SclRotscl	Scl_r_reg;
  	SclWinscl	Scl_w_reg;
! 	SclSblSgl	Scl_flag;
  
! /* このファイルが参照する大域変数の宣言 */
  extern	SclPriBuffDirtyFlags	SclPriBuffDirty;
  extern	void	SCL_AutoExec(void);
  extern	Uint32	SCL_GetColRamMode(void);
--- 43,61 ----
  	Uint32	SclCurSclNum =0;
  	Uint16	SclProcess = 0;
  
! /* ｿｽｿｽｿｽﾊサｿｽCｿｽYｿｽfｿｽtｿｽHｿｽｿｽｿｽg */
  	Uint16	SclDisplayX = 320;
  	Uint16	SclDisplayY = 224;
  
! /* ｿｽｿｽｿｽWｿｽXｿｽ^ｿｽoｿｽbｿｽtｿｽ@ */
  	SclSysreg	Scl_s_reg;
  	SclDataset	Scl_d_reg;
  	SclNorscl	Scl_n_reg;
  	SclRotscl	Scl_r_reg;
  	SclWinscl	Scl_w_reg;
! 	//SclSblSgl	Scl_flag;
  
! /* ｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽQｿｽﾆゑｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾏ撰ｿｽｿｽﾌ宣言 */
  extern	SclPriBuffDirtyFlags	SclPriBuffDirty;
  extern	void	SCL_AutoExec(void);
  extern	Uint32	SCL_GetColRamMode(void);
***************
*** 64,77 ****
  extern	void	SCL_PriorityInit(void);	/*  add: C.yoshida  */
  
  /*******************************************************
!  *  回転マトリックスパラメータテーブルバッファ         *
   *******************************************************/
  
  SclRotreg	_SclRotregBuff[2];
  SclRotreg	*SclRotregBuff = _SclRotregBuff;
  
  /*******************************************************
!  *  回転マトリックスパラメータ係数テーブルバッファ     *
   *******************************************************/
  	Uint16	SclK_TableBuff[2][820];
  	Uint32	SclK_TableNum[2];
--- 64,77 ----
  extern	void	SCL_PriorityInit(void);	/*  add: C.yoshida  */
  
  /*******************************************************
!  *  ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽbｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽｿｽoｿｽbｿｽtｿｽ@         *
   *******************************************************/
  
  SclRotreg	_SclRotregBuff[2];
  SclRotreg	*SclRotregBuff = _SclRotregBuff;
  
  /*******************************************************
!  *  ｿｽｿｽｿｽ]ｿｽ}ｿｽgｿｽｿｽｿｽbｿｽNｿｽXｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽWｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽｿｽoｿｽbｿｽtｿｽ@     *
   *******************************************************/
  	Uint16	SclK_TableBuff[2][820];
  	Uint32	SclK_TableNum[2];
***************
*** 83,95 ****
  	Uint16	SclRotXySw[2];
  	Uint8	SclRa,SclRb;
  	Uint32	SclRotateTableAddress;
! /* 回転パラメータ用角度データ */
  	Fixed32	SclRotateXy[2];
  	Fixed32	SclRotateZ[2];
  	Fixed32	SclRotateDisp[2];
  	Fixed32	SclRotateMoveZ[2];
  
! 	Uint16	SclRPMD;	/* 回転パラメータモード */
  
  #if	0
  	Uint16	SclRotateTableMode=0xff;
--- 83,95 ----
  	Uint16	SclRotXySw[2];
  	Uint8	SclRa,SclRb;
  	Uint32	SclRotateTableAddress;
! /* ｿｽｿｽｿｽ]ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽpｿｽpｿｽxｿｽfｿｽ[ｿｽ^ */
  	Fixed32	SclRotateXy[2];
  	Fixed32	SclRotateZ[2];
  	Fixed32	SclRotateDisp[2];
  	Fixed32	SclRotateMoveZ[2];
  
! 	Uint16	SclRPMD;	/* ｿｽｿｽｿｽ]ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽｿｽｿｽ[ｿｽh */
  
  #if	0
  	Uint16	SclRotateTableMode=0xff;
***************
*** 97,103 ****
  	Uint16	SclRotateTableMode=2;
  #endif
  
! /* このファイルで定義する関数 */
  	void	SCL_ParametersInit(void);
  	void	SCL_ScrollShow(void);
  	void	SCL_PriIntProc(void);
--- 97,103 ----
  	Uint16	SclRotateTableMode=2;
  #endif
  
! /* ｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽﾅ抵ｿｽｿｽ`ｿｽｿｽｿｽｿｽｿｽﾖ撰ｿｽ */
  	void	SCL_ParametersInit(void);
  	void	SCL_ScrollShow(void);
  	void	SCL_PriIntProc(void);
***************
*** 119,127 ****
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  * 
   * CAVEATS
!  * 
   *------------------------------------------------------------------------
   */
  void SCL_Vdp2Init(void)
--- 119,127 ----
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  *
   * CAVEATS
!  *
   *------------------------------------------------------------------------
   */
  void SCL_Vdp2Init(void)
***************
*** 146,160 ****
  
      SclRbgKtbOffset[0] = 0;
      SclRbgKtbOffset[1] = 0;
! 	
  	/*
! 	**追加 1995.11.06 C.Yoshida
! 	**SclRotateTableAddressはポインタだがSCL_RotateInitが呼ばれない限り
! 	**初期化されることはない。SCL_RotateInitをコールする前にV_Syncにくると
! 	**えらいことになる。
  	*/
  	SclRotateTableAddress = 0;
! 	
      SCL_PriorityInit();
      SCL_ParametersInit();
  }
--- 146,160 ----
  
      SclRbgKtbOffset[0] = 0;
      SclRbgKtbOffset[1] = 0;
! 
  	/*
! 	**ｿｽﾇ会ｿｽ 1995.11.06 C.Yoshida
! 	**SclRotateTableAddressｿｽﾍポｿｽCｿｽｿｽｿｽ^ｿｽｿｽｿｽｿｽSCL_RotateInitｿｽｿｽｿｽﾄばゑｿｽｿｽﾈゑｿｽｿｽｿｽｿｽｿｽ
! 	**ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ驍ｱｿｽﾆはなゑｿｽｿｽBSCL_RotateInitｿｽｿｽｿｽRｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽOｿｽｿｽV_Syncｿｽﾉゑｿｽｿｽｿｽｿｽｿｽ
! 	**ｿｽｿｽｿｽ轤｢ｿｽｿｽｿｽﾆになゑｿｽｿｽB
  	*/
  	SclRotateTableAddress = 0;
! 
      SCL_PriorityInit();
      SCL_ParametersInit();
  }
***************
*** 171,179 ****
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  * 
   * CAVEATS
!  * 
   *------------------------------------------------------------------------
   */
  void SCL_ParametersInit(void)
--- 171,179 ----
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  *
   * CAVEATS
!  *
   *------------------------------------------------------------------------
   */
  void SCL_ParametersInit(void)
***************
*** 234,240 ****
  	Scl_n_reg.lineaddr[1] = 0;
  	Scl_n_reg.linecolmode = 0;
  	Scl_n_reg.backcolmode = 0;
! 	
  /*
   *	Rotate Scroll Extension Registers Area Initialization
   */
--- 234,240 ----
  	Scl_n_reg.lineaddr[1] = 0;
  	Scl_n_reg.linecolmode = 0;
  	Scl_n_reg.backcolmode = 0;
! 
  /*
   *	Rotate Scroll Extension Registers Area Initialization
   */
***************
*** 283,289 ****
   * POSTCONDITIONS
   * 			None
   * CAVEATS
!  * 		
   *---------------------------------------------------------------------
   */
  void SCL_Open(Uint32 sclnum)
--- 283,289 ----
   * POSTCONDITIONS
   * 			None
   * CAVEATS
!  *
   *---------------------------------------------------------------------
   */
  void SCL_Open(Uint32 sclnum)
***************
*** 306,312 ****
   * POSTCONDITIONS
   * 			None
   * CAVEATS
!  * 		should be used as the pair of SCL_Open		
   *---------------------------------------------------------------------
   */
  void SCL_Close(void)
--- 306,312 ----
   * POSTCONDITIONS
   * 			None
   * CAVEATS
!  * 		should be used as the pair of SCL_Open
   *---------------------------------------------------------------------
   */
  void SCL_Close(void)
***************
*** 329,337 ****
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  * 
   * CAVEATS
!  * 
   *------------------------------------------------------------------------
   */
  void SCL_MoveTo(Fixed32 x,Fixed32 y,Fixed32 z)
--- 329,337 ----
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  *
   * CAVEATS
!  *
   *------------------------------------------------------------------------
   */
  void SCL_MoveTo(Fixed32 x,Fixed32 y,Fixed32 z)
***************
*** 389,397 ****
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  * 
   * CAVEATS
!  * 
   *------------------------------------------------------------------------
   */
  void SCL_Move(Fixed32 x,Fixed32 y,Fixed32 z)
--- 389,397 ----
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  *
   * CAVEATS
!  *
   *------------------------------------------------------------------------
   */
  void SCL_Move(Fixed32 x,Fixed32 y,Fixed32 z)
***************
*** 448,456 ****
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  * 
   * CAVEATS
!  * 
   *------------------------------------------------------------------------
   */
  void SCL_Scale(Fixed32 Sx, Fixed32 Sy)
--- 448,456 ----
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  *
   * CAVEATS
!  *
   *------------------------------------------------------------------------
   */
  void SCL_Scale(Fixed32 Sx, Fixed32 Sy)
***************
*** 507,513 ****
   * NAME : SCL_CopyReg
   *
   * PARAMETERS
!  *	param1 - 
   *	param2 -
   *
   * DESCRIPTION
--- 507,513 ----
   * NAME : SCL_CopyReg
   *
   * PARAMETERS
!  *	param1 -
   *	param2 -
   *
   * DESCRIPTION
***************
*** 515,528 ****
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  * 
   * CAVEATS
   * 		used by interrupt routine only(V_BLANK)
   *		***DON'T CALL IT DIRECTLY!***
   *
   * Updated by Chikahiro Yoshida 1995-07-19
!  *	修正箇所	Read onlyのVDP2レジスタに対し、書き込みして
!  *				いる処理を修正した。
   *
   *------------------------------------------------------------------------
   */
--- 515,528 ----
   * PRECONDITIONS
   *
   * POSTCONDITIONS
!  *
   * CAVEATS
   * 		used by interrupt routine only(V_BLANK)
   *		***DON'T CALL IT DIRECTLY!***
   *
   * Updated by Chikahiro Yoshida 1995-07-19
!  *	ｿｽCｿｽｿｽｿｽﾓ擾ｿｽ	Read onlyｿｽｿｽVDP2ｿｽｿｽｿｽWｿｽXｿｽ^ｿｽﾉ対ゑｿｽｿｽAｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾝゑｿｽｿｽｿｽ
!  *				ｿｽｿｽｿｽ髀茨ｿｽｿｽｿｽｿｽｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽB
   *
   *------------------------------------------------------------------------
   */
***************
*** 530,536 ****
  {
  	Uint16	i;
  
! 			/* 回転パラメータ係数テーブルをＶＲＡＭに転送 */
  	if(SclK_TableFlag[0] && SclRbgKtbAddr[0])	{
  		SCL_Memcpyw((void *)SclRbgKtbAddr[0],SclK_TableBuff[0],SclK_TableNum[0]*2);
  		SclK_TableFlag[0] = 0;
--- 530,536 ----
  {
  	Uint16	i;
  
! 			/* ｿｽｿｽｿｽ]ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽWｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽｿｽｿｽｿｽuｿｽqｿｽ`ｿｽlｿｽﾉ転ｿｽｿｽ */
  	if(SclK_TableFlag[0] && SclRbgKtbAddr[0])	{
  		SCL_Memcpyw((void *)SclRbgKtbAddr[0],SclK_TableBuff[0],SclK_TableNum[0]*2);
  		SclK_TableFlag[0] = 0;
***************
*** 558,567 ****
  		const	Uint32	p=(Uint32)SclRotateTableAddress;
  		void	*const	pA=(void *)p;
  		void	*const	pB=(void *)(p+0x80);
! 		
  		/*
! 		**  追加 1996.03.19 N.K
! 		**  SclRotateTableAddress の値の検査を追加。
  		*/
  		if (pA != NULL) {
  		    SCL_Memcpyw(pA,&SclRotregBuff[0],size);
--- 558,567 ----
  		const	Uint32	p=(Uint32)SclRotateTableAddress;
  		void	*const	pA=(void *)p;
  		void	*const	pB=(void *)(p+0x80);
! 
  		/*
! 		**  ｿｽﾇ会ｿｽ 1996.03.19 N.K
! 		**  SclRotateTableAddress ｿｽﾌ値ｿｽﾌ鯉ｿｽｿｽｿｽｿｽｿｽｿｽﾇ会ｿｽｿｽB
  		*/
  		if (pA != NULL) {
  		    SCL_Memcpyw(pA,&SclRotregBuff[0],size);
***************
*** 674,680 ****
  }
  
  
! /* カラー RAM のモードを設定する */
  void  SCL_SetColRamMode(Uint32 ComRamMode)
  {
      switch(ComRamMode){
--- 674,680 ----
  }
  
  
! /* ｿｽJｿｽｿｽｿｽ[ RAM ｿｽﾌｿｽｿｽ[ｿｽhｿｽｿｽｿｽﾝ定すｿｽｿｽ */
  void  SCL_SetColRamMode(Uint32 ComRamMode)
  {
      switch(ComRamMode){
***************
*** 699,706 ****
  
  
  /***************************************************************
!  *	Priority Interrupt Routine 
!  *      この関数はVB interval の割り込み関数から呼ばれる 
   ***************************************************************/
  void  SCL_PriIntProc(void)
  {
--- 699,706 ----
  
  
  /***************************************************************
!  *	Priority Interrupt Routine
!  *      ｿｽｿｽｿｽﾌ関撰ｿｽｿｽｿｽVB interval ｿｽﾌ奇ｿｽｿｽ闕橸ｿｽﾝ関撰ｿｽｿｽｿｽｿｽｿｽｿｽﾄばゑｿｽｿｽｿｽ
   ***************************************************************/
  void  SCL_PriIntProc(void)
  {
***************
*** 709,715 ****
      SCL_AutoExec();
  
      if(SclPriBuffDirty.SclOtherPri){
! 	/* SclOtherPri のレジスタへのコピー */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealOtherPri, &SclOtherPri, sizeof(SclOtherPri));
  #else
--- 709,715 ----
      SCL_AutoExec();
  
      if(SclPriBuffDirty.SclOtherPri){
! 	/* SclOtherPri ｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾖのコｿｽsｿｽ[ */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealOtherPri, &SclOtherPri, sizeof(SclOtherPri));
  #else
***************
*** 718,724 ****
  	SclPriBuffDirty.SclOtherPri = 0;
      }
      if(SclPriBuffDirty.SclSpPriNum){
! 	/* SclSpPriNum のレジスタへのコピー */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealSpPriNum, &SclSpPriNum, sizeof(SclSpPriNum));
  #else
--- 718,724 ----
  	SclPriBuffDirty.SclOtherPri = 0;
      }
      if(SclPriBuffDirty.SclSpPriNum){
! 	/* SclSpPriNum ｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾖのコｿｽsｿｽ[ */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealSpPriNum, &SclSpPriNum, sizeof(SclSpPriNum));
  #else
***************
*** 727,733 ****
  	SclPriBuffDirty.SclSpPriNum = 0;
      }
      if(SclPriBuffDirty.SclBgPriNum){
! 	/* SclBgPriNum のレジスタへのコピー */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealBgPriNum, &SclBgPriNum, sizeof(SclBgPriNum));
  #else
--- 727,733 ----
  	SclPriBuffDirty.SclSpPriNum = 0;
      }
      if(SclPriBuffDirty.SclBgPriNum){
! 	/* SclBgPriNum ｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾖのコｿｽsｿｽ[ */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealBgPriNum, &SclBgPriNum, sizeof(SclBgPriNum));
  #else
***************
*** 736,742 ****
  	SclPriBuffDirty.SclBgPriNum = 0;
      }
      if(SclPriBuffDirty.SclSpColMix){
! 	/* SclSpColMix のレジスタへのコピー */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealSpColMix, &SclSpColMix, sizeof(SclSpColMix));
  #else
--- 736,742 ----
  	SclPriBuffDirty.SclBgPriNum = 0;
      }
      if(SclPriBuffDirty.SclSpColMix){
! 	/* SclSpColMix ｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾖのコｿｽsｿｽ[ */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealSpColMix, &SclSpColMix, sizeof(SclSpColMix));
  #else
***************
*** 745,751 ****
  	SclPriBuffDirty.SclSpColMix = 0;
      }
      if(SclPriBuffDirty.SclBgColMix){
! 	/* SclBgColMix のレジスタへのコピー */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealBgColMix, &SclBgColMix, sizeof(SclBgColMix));
  #else
--- 745,751 ----
  	SclPriBuffDirty.SclSpColMix = 0;
      }
      if(SclPriBuffDirty.SclBgColMix){
! 	/* SclBgColMix ｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾖのコｿｽsｿｽ[ */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealBgColMix, &SclBgColMix, sizeof(SclBgColMix));
  #else
***************
*** 754,760 ****
  	SclPriBuffDirty.SclBgColMix = 0;
      }
      if(SclPriBuffDirty.SclColOffset){
! 	/* ColOffsetのレジスタへのコピー */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealColOffset, &SclColOffset, sizeof(SclColOffset));
  #else
--- 754,760 ----
  	SclPriBuffDirty.SclBgColMix = 0;
      }
      if(SclPriBuffDirty.SclColOffset){
! 	/* ColOffsetｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾖのコｿｽsｿｽ[ */
  #ifdef	DMAOFF
  	SCL_Memcpyw(SclRealColOffset, &SclColOffset, sizeof(SclColOffset));
  #else
***************
*** 769,775 ****
  
  /*------------------------------------------------------------------------
   * NAME : SCL_Vdp2_SGLInit
!  * ＳＧＬモードのデフォルトにする
   *----------------------------------------------------------------------*/
  static Uint16  tvsize[16] = { 0x0000,   	/* SPR_TV_320X224  */
                                0x0010,       /* SPR_TV_320X240  */
--- 769,775 ----
  
  /*------------------------------------------------------------------------
   * NAME : SCL_Vdp2_SGLInit
!  * ｿｽrｿｽfｿｽkｿｽｿｽｿｽ[ｿｽhｿｽﾌデｿｽtｿｽHｿｽｿｽｿｽgｿｽﾉゑｿｽｿｽｿｽ
   *----------------------------------------------------------------------*/
  static Uint16  tvsize[16] = { 0x0000,   	/* SPR_TV_320X224  */
                                0x0010,       /* SPR_TV_320X240  */
***************
*** 791,803 ****
  
  void SCL_Vdp2_SGLInit(Uint16 tvmod)
  {
! 	/* slInitSystem のtvmode から Scl_s_reg.tvmode を再セット	*/
! 	tvmod &= 0x0f ;						/* TVmode = 0 〜 15 */
  	Scl_s_reg.tvmode |= tvsize[tvmod];
  	if(SclProcess == 0)	SclProcess = 1;
  
  
! 	/* スプライトカラー演算割合	*/
      SCL_SET_S0CCRT(8);
      SCL_SET_S1CCRT(8);
      SCL_SET_S2CCRT(8);
--- 791,803 ----
  
  void SCL_Vdp2_SGLInit(Uint16 tvmod)
  {
! 	/* slInitSystem ｿｽｿｽtvmode ｿｽｿｽｿｽｿｽ Scl_s_reg.tvmode ｿｽｿｽｿｽﾄセｿｽbｿｽg	*/
! 	tvmod &= 0x0f ;						/* TVmode = 0 ｿｽ` 15 */
  	Scl_s_reg.tvmode |= tvsize[tvmod];
  	if(SclProcess == 0)	SclProcess = 1;
  
  
! 	/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽZｿｽｿｽｿｽｿｽ	*/
      SCL_SET_S0CCRT(8);
      SCL_SET_S1CCRT(8);
      SCL_SET_S2CCRT(8);
***************
*** 808,825 ****
      SCL_SET_S5CCRT(8);
      SclPriBuffDirty.SclSpColMix = 1;
  
! 	/* スプライトプライオリティ	*/
!     SCL_SET_S0PRIN(7); 
!     SCL_SET_S1PRIN(7); 
!     SCL_SET_S2PRIN(7); 
!     SCL_SET_S3PRIN(7); 
!     SCL_SET_S4PRIN(7); 
!     SCL_SET_S5PRIN(7); 
!     SCL_SET_S6PRIN(7); 
!     SCL_SET_S7PRIN(7); 
      SclPriBuffDirty.SclSpPriNum = 1;
  
! 	/* スプライトコントロール	*/
  	SCL_SET_SPTYPE(3);
  	SCL_SET_SPCLMD(1);
  	SCL_SET_SPWINEN(0);
--- 808,825 ----
      SCL_SET_S5CCRT(8);
      SclPriBuffDirty.SclSpColMix = 1;
  
! 	/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽB	*/
!     SCL_SET_S0PRIN(7);
!     SCL_SET_S1PRIN(7);
!     SCL_SET_S2PRIN(7);
!     SCL_SET_S3PRIN(7);
!     SCL_SET_S4PRIN(7);
!     SCL_SET_S5PRIN(7);
!     SCL_SET_S6PRIN(7);
!     SCL_SET_S7PRIN(7);
      SclPriBuffDirty.SclSpPriNum = 1;
  
! 	/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽ	*/
  	SCL_SET_SPTYPE(3);
  	SCL_SET_SPCLMD(1);
  	SCL_SET_SPWINEN(0);
***************
*** 837,840 ****
  	Scl_flag.sgl_flag=0x0000;
  	SclRotregBuff = _SclRotregBuff;
  }
- 
--- 837,839 ----
diff -crBN --binary sbl6/segalib/scl/scl_pr03.c sbl6_patch/segalib/scl/scl_pr03.c
*** sbl6/segalib/scl/scl_pr03.c	1995-08-30 22:00:00.000000000 -0400
--- sbl6_patch/segalib/scl/scl_pr03.c	2022-01-17 19:59:22.000000000 -0500
***************
*** 83,92 ****
  		}
  	}else{
  		for(i=0;i<Max256;i++)
! 			if(SclColRamAlloc256[i] != 0) return((Uint32 )NULL);
  		SclColRamAlloc2048[0] = Surface;
  		SCL_SetColRamOffset(Surface,0,transparent);
  		return(SCL_COLRAM_ADDR);
  	}
  }
! 
\ No newline at end of file
--- 83,92 ----
  		}
  	}else{
  		for(i=0;i<Max256;i++)
! 			if(SclColRamAlloc256[i] != 0) return(0);
  		SclColRamAlloc2048[0] = Surface;
  		SCL_SetColRamOffset(Surface,0,transparent);
  		return(SCL_COLRAM_ADDR);
  	}
  }
! 
diff -crBN --binary sbl6/segalib/scl/scl_ro00.c sbl6_patch/segalib/scl/scl_ro00.c
*** sbl6/segalib/scl/scl_ro00.c	1995-09-29 18:42:18.000000000 -0400
--- sbl6_patch/segalib/scl/scl_ro00.c	2023-01-08 16:23:56.000000000 -0500
***************
*** 113,124 ****
  
  static	Fixed32	Fcos(Fixed32	a)
  {
- 	Uint16	sign;
  	Fixed32	val;
  
- 	sign = 0;
  	if(a & 0x80000000){
- 		sign = 0;
  		a = - a;
  	}
  	a = a % FIXED(360);		/* 0 <= a < 360  */
--- 113,121 ----
***************
*** 718,721 ****
  	SclRotregBuff[TbNum].delta.y     =  Fsin(SclRotateDisp[TbNum]);
  }
  
! 
\ No newline at end of file
--- 715,718 ----
  	SclRotregBuff[TbNum].delta.y     =  Fsin(SclRotateDisp[TbNum]);
  }
  
! 
diff -crBN --binary sbl6/segalib/snd/snd_main.c sbl6_patch/segalib/snd/snd_main.c
*** sbl6/segalib/snd/snd_main.c	1996-07-09 21:08:00.000000000 -0400
--- sbl6_patch/segalib/snd/snd_main.c	2022-01-17 19:57:36.000000000 -0500
***************
*** 355,361 ****
  
  void SND_MoveData(Uint16 *source, Uint32 size,Uint16 data_kind, Uint16 data_no)
  {
!     void *adr;                                  /* 転送先アドレス            */
      Uint32 *load_mark_adr;                      /* 転送済みビット設定ｱﾄﾞﾚｽ  */
  
      GetSndMapInfo(&adr, &load_mark_adr, data_kind, data_no);
--- 355,361 ----
  
  void SND_MoveData(Uint16 *source, Uint32 size,Uint16 data_kind, Uint16 data_no)
  {
!     void *adr = NULL;                           /* 転送先アドレス            */
      Uint32 *load_mark_adr;                      /* 転送済みビット設定ｱﾄﾞﾚｽ  */
  
      GetSndMapInfo(&adr, &load_mark_adr, data_kind, data_no);
***************
*** 1686,1689 ****
  	HOST_SET_RETURN(SND_RET_SET);
  }
  
! 
\ No newline at end of file
--- 1686,1689 ----
  	HOST_SET_RETURN(SND_RET_SET);
  }
  
! 
diff -crBN --binary sbl6/segalib/stm/sega_stm.h sbl6_patch/segalib/stm/sega_stm.h
*** sbl6/segalib/stm/sega_stm.h	1996-02-08 05:25:44.000000000 -0500
--- sbl6_patch/segalib/stm/sega_stm.h	1969-12-31 19:00:00.000000000 -0500
***************
*** 1,476 ****
- /*****************************************************************************
-  *      ソフトウェアライブラリ
-  *
-  *      Copyright (c) 1994,1995,1996 SEGA
-  *
-  * Library: ストリームシステム
-  * Module : 公開用ヘッダファイル
-  * File   : sega_stm.h
-  * Date   : 1995-02-01
-  * Version: 2.10
-  * Auther : H.T
-  *
-  *****************************************************************************/
- #if !defined(SEGA_STM_H)
- #define     SEGA_STM_H
- 
- /*****************************************************************************
-  *      インクルードファイル
-  *****************************************************************************/
- #include        "sega_gfs.h"
- 
- /* バージョン   */
-                             /*             1         2         3         4  */
-                             /*    1234567890123456789012345678901234567890  */
-                             /*    ++++++++++++++++++++++++++++++++          */
- #if defined(USE_SGL)
-     #define STM_VERSION_STR     ("STM_SGL Version 2.10 1996-02-01")
- #else
-     #define STM_VERSION_STR     ("STM_SBL Version 2.10 1996-02-01")
- #endif
- #define STM_VERSION_LEN 32
- 
- /*****************************************************************************
-  *      定数マクロ
-  *****************************************************************************/
- 
- #define STM_LONG_MAX    0x7fffffff
- 
- /* ループ再生時の読み込み指定           */
- enum StmLoopRead {
-     STM_LOOP_READ       = TRUE,         /* ループ再生時読み込みをする   */
-     STM_LOOP_NOREAD     = FALSE,        /* ループ再生時読み込みをしない */
-     STM_LOOP_END
- };
- 
- /* ループストリームを先頭ストリームに設定する   */
- #define STM_LOOP_DFL    ((StmHn)(0xffffffff))
- 
- /* 無限回ループの指定                   */
- #define STM_LOOP_ENDLESS        STM_LONG_MAX
- 
- /* ストリームアクセス状態(acstat)       */
- enum StmAcStat {
-     STM_EXEC_COMPLETED  = 0x100,        /* アクセス終了                 */
-     STM_EXEC_PAUSE      = 0x101,        /* アクセス一時停止中           */
-     STM_EXEC_DOING      = 0x102,        /* アクセス中                   */
-     STM_EXEC_WAIT       = 0x103,        /* 転送ゲートの開き待ち状態     */
-     STM_EXEC_TSKEND     = 0x104,        /* 即時復帰処理完了             */
-     STM_EXEC_END
- };
- 
- 
- /* 転送ユニットサイズ           */
- enum StmUnitSize {
-     STM_UNIT_FORM1      = 2048,         /* MODE1,MODE2Form1セクタサイズ */
-     STM_UNIT_FORM2      = 2324,         /* MODE2Form2セクタサイズ       */
-     STM_UNIT_WORD       = 2,            /* ワード                       */
-     STM_UNIT_BYTE       = 1,            /* バイト                       */
-     STM_UNIT_END
- };
- 
- 
- /* ストリーム情報                       */
- #define STM_KEY_NONE    (-1)            /* 各ストリームキー選択を無視   */
- 
- /* 読み込みセクタ範囲                   */
- enum StmFad {
-     STM_FAD_CDTOP       = 150,          /* ディスク先頭FAD              */
-     STM_FAD_CDEND       = STM_LONG_MAX  /* ディスク終了迄読む場合のセクタ数*/
- };
- 
- 
- /* CDバッファセクタ位置                 */
- enum StmSctPos {
-     STM_CDBUF_TOP       = 0,            /* バッファ区画先頭             */
-     STM_CDBUF_END       = 0xffff        /* 全セクタ数                   */
- };
- 
- /* オープン時読み込みザブモード設定用   */
- enum StmSctType {
-     STM_SM_EOR          = CDC_SM_EOR,           /* レコード最後のセクタ */
-     STM_SM_VIDEO        = CDC_SM_VIDEO,         /* ビデオセクタ         */
-     STM_SM_AUDIO        = CDC_SM_AUDIO,         /* オーディオセクタ     */
-     STM_SM_DATA         = CDC_SM_DATA,          /* データセクタ         */
-     STM_SM_TRIG         = CDC_SM_TRIG,          /* トリガービット       */
-     STM_SM_FORM         = CDC_SM_FORM,          /* フォームビット       */
-     STM_SM_RT           = CDC_SM_RT,            /* リアルタイムセクタ   */
-     STM_SM_EOF          = CDC_SM_EOF,           /* ファイル最後のセクタ */
-     STM_SM_END
- };
- 
- 
- /* 最大転送セクタ数                     */
- #define STM_TR_ALL      STM_LONG_MAX
- 
- 
- /* 転送ゲート状態                       */
- enum StmGate {
-     STM_GATE_OPEN       = 0x300,                /* 開き                 */
-     STM_GATE_CLOSE      = 0x301,                /* 閉じ                 */
-     STM_GATE_END
- };
- 
- 
- /* 転送モード                   */
- enum StmTrMode {
-     STM_TR_SCU          = GFS_TMODE_SCU,        /* SCUによるDMA         */
-     STM_TR_SDMA0        = GFS_TMODE_SDMA0,      /* CPUサイクルスチール  */
-     STM_TR_SDMA1        = GFS_TMODE_SDMA1,      /* CPUサイクルスチール  */
-     STM_TR_CPU          = GFS_TMODE_CPU,        /* ソフトウエア転送     */
-     STM_TR_END
- };
- 
- 
- /* 関数ID                       */
- enum StmFuncId {
-     STM_INIT            = 0x300,        /* ストリームシステム初期化     */
-     STM_OPENGRP         = 0x301,        /* ストリームグループのオープン */
-     STM_CLOSEGRP        = 0x302,        /* ストリームグループのクローズ */
-     STM_GETSTMNUM       = 0x303,        /* ストリーム数の取得           */
-     STM_GETSTMHNDL      = 0x304,        /* ストリームハンドルの取得     */
-     STM_SETCDBUFFUNC    = 0x305,        /* バッファサイズ監視関数の登録 */
-     STM_OPENFID         = 0x306,        /* 識別子によるオープン         */
-     STM_OPENFRANGE      = 0x307,        /* セクタ位置によるオープン     */
-     STM_OPENRESI        = 0x308,        /* 常駐ストリームのオープン     */
-     STM_CLOSE           = 0x309,        /* ストリームのクローズ         */
-     STM_SETKEY          = 0x310,        /* ストリームキーの設定         */
-     STM_GETINFO         = 0x311,        /* ストリーム情報の取得         */
-     STM_SCTTOWORD       = 0x312,        /* セクタ数からワード数への変換 */
-     STM_WORDTOSCT       = 0x313,        /* ワード数からセクタ数への変換 */
-     STM_SETALIAS        = 0x314,        /* エイリアスの設定             */
-     STM_UNSETALIAS      = 0x315,        /* エイリアスの解除             */
-     STM_SETTRBUF        = 0x316,        /* 転送領域の設定               */
-     STM_SETTRFUNC       = 0x317,        /* 転送関数の設定               */
-     STM_STARTTRANS      = 0x318,        /* 転送関数における転送開始     */
-     STM_SETTRGATE       = 0x319,        /* 転送ゲートの開閉             */
-     STM_SETTRPARA       = 0x320,        /* 最大転送セクタ数の設定       */
-     STM_SETTRFAD        = 0x321,        /* 転送開始FADの設定            */
-     STM_SETTRMODE       = 0x322,        /* 転送モードの設定             */
-     STM_RESETTRBUF      = 0x323,        /* 転送領域のリセット           */
-     STM_GETNUMCDBUF     = 0x324,        /* CDバッファ有効セクタ数の取得 */
-     STM_GETSCTINFO      = 0x325,        /* 読み込みセクタ情報の取得     */
-     STM_GETLENTRBUF     = 0x326,        /* 転送領域のデータ数の取得     */
-     STM_ISTRBUFFULL     = 0x327,        /* 転送領域フルのチェック       */
-     STM_ISTRANS         = 0x328,        /* 転送中のチェック             */
-     STM_SETEXECGRP      = 0x329,        /* サーバ実行グループの指定     */
-     STM_EXECSERVER      = 0x330,        /* サーバの実行                 */
-     STM_MOVEPICKUP      = 0x331,        /* ピックアップの移動           */
-     STM_SETLOOP         = 0x332,        /* ループストリームの指定       */
-     STM_GETLOOPCNT      = 0x333,        /* ループカウンタの取得         */
-     STM_GETEXECSTAT     = 0x334,        /* 実行状態の取得               */
-     STM_ISCOMPLETE      = 0x335,        /* 実行終了のチェック           */
-     STM_EXECTRANS       = 0x336,        /* ストリームデータの転送       */
-     STM_CONNECTCDBUF    = 0x337,        /* 絞りとCDバッファ区画の接続   */
-     STM_MOVECDBUF       = 0x338,        /* CDバッファデータの移動       */
-     STM_ERASECDBUF      = 0x339,        /* CDバッファデータの消去       */
-     STM_SETERRFUNC      = 0x340,        /* エラー関数の登録             */
-     STM_GETERRSTAT      = 0x341,        /* エラー状態の取得             */
-     STM_FUNC_END
- };
- 
- 
- /* エラーコード         */
- enum StmErrCode {
-     STM_ERR_OK          = GFS_ERR_OK,           /* 正常終了             */
-     STM_ERR_CDRD        = GFS_ERR_CDRD,         /* CDリードエラー       */
-     STM_ERR_CDNODISC    = GFS_ERR_CDNODISC,     /* CDをセットしていない */
-     STM_ERR_FID         = GFS_ERR_FID,          /* ファイル識別子不正   */
-     STM_ERR_HNDL        = GFS_ERR_HNDL,         /* ハンドルが不正       */
-     STM_ERR_NUM         = GFS_ERR_NUM,          /* バイト数などが負     */
-     STM_ERR_PARA        = GFS_ERR_PARA,         /* パラメータが不正     */
-     STM_ERR_NOHNDL      = GFS_ERR_NOHNDL,       /* ハンドルに空きがない */
-     STM_ERR_PUINUSE     = GFS_ERR_PUINUSE,      /* ピックアップ動作中   */
-     STM_ERR_TMOUT       = GFS_ERR_TMOUT,        /* タイムアウト         */
-     STM_ERR_CDOPEN      = GFS_ERR_CDOPEN,       /* トレイが開いている   */
-     STM_ERR_FATAL       = GFS_ERR_FATAL,        /* CDがFATAL状態        */
-     STM_ERR_END
- };
- 
- 
- /*****************************************************************************
-  *      データ型の定義
-  *****************************************************************************/
- 
- /* ストリームハンドル           */
- typedef struct stmobj {
-     void            *grp;           /* 所属するストリームグループ           */
-     struct stmobj   *alias;         /* 実際に操作するストリーム             */
-     struct stmobj   *sfadlst;       /* 開始FAD昇順リスト                    */
-     struct stmobj   *fltlst;        /* 絞りの接続順リスト                   */
-     GfsHn           gfs;            /* ファイルハンドル                     */
-     GfsFlow         *flow;          /* 読み込み管理                         */
-     Sint32          (*trfunc)(void *obj, struct stmobj *stm, Sint32 nsct);
-                                     /* 転送関数(StmTrFunc)                  */
-     void            *obj;           /* 転送関数の第一引数   　　　　        */
-     Uint32          *trsrc;         /* 転送元アドレス                       */
-     Sint32          adlt;           /* 転送元アドレス変化分                 */
-     Sint32          trfad;          /* 転送開始FAD                          */
-     Uint8           atr;            /* アトリビュート                       */
-     Uint8           svrstat;
- } StmObj;
- 
- typedef StmObj      *StmHn;
- 
- 
- /* 転送関数     */
- typedef Sint32  (*StmTrFunc)(void *obj, StmHn stm, Sint32 nsct);
- #define STM_TR_NULLFUNC         ((StmTrFunc)0)
- 
- /* エラー関数   */
- typedef void    (*StmErrFunc)(void *obj, Sint32 ec);
- #define STM_ERR_NULLFUNC        ((StmErrFunc)0)
- 
- /* バッファ監視関数  */
- typedef void    (*StmCdbufFunc)(void *obj);
- #define STM_CDBUF_NULLFUNC      ((StmCdbufFunc)0)
- #define STM_CDBUF_REST          NULL
- 
- /* ストリームグループ           */
- typedef struct {
-     StmHn       sfadlst;        /* 読み込み開始FADによるリスト          */
-     StmHn       fltlst;         /* 絞り接続順リスト                     */
-     StmHn       loopstm;        /* ループストリーム                     */
-     StmHn       lststm;         /* 最終ストリーム                       */
-     StmHn       nexttrns;       /* 次の転送ストリーム           */
-     Sint32      fad;            /* 読み込み実行時、一時停止時のFAD      */
-     Sint32      acstat;         /* アクセス状態                         */
-                                 /* (COMPLETED, PAUSE, DOING, WAIT)      */
-     StmHn       chkstm;         /* バッファサイズ監視ストリーム         */
-     Sint32      chksctnum;      /* バッファサイズ監視関数呼びだしセクタ数 */
-     StmCdbufFunc  chkfunc;      /* バッファサイズ監視関数               */
-     void        *chkobj;        /* バッファサイズ監視オブジェクト       */
-     Sint32      loopmax;        /* ループ回数                           */
-     Sint32      loopcnt;        /* ループカウンタ                       */
-     Sint32      puid;           /* ピックアップユーザID                 */
-     Uint16      atr;            /* アトリビュート                       */
-     Uint8       svrstat;
- } StmGrp;
- 
- typedef StmGrp  *StmGrpHn;
- 
- /* ストリームキー               */
- typedef struct {
-     Sint16      fn;             /* ファイル番号                         */
-     Sint16      cn;             /* チャネル番号                         */
-     Sint16      smmsk;          /* サブモードマスクパターン             */
-     Sint16      smval;          /* サブモード比較値                     */
-     Sint16      cimsk;          /* コーディング情報マスクパターン       */
-     Sint16      cival;          /* コーディング情報比較値               */
- } StmKey;
- 
- #define STM_KEY_FN(stmkey)      ((stmkey)->fn)
- #define STM_KEY_CN(stmkey)      ((stmkey)->cn)
- #define STM_KEY_SMMSK(stmkey)   ((stmkey)->smmsk)
- #define STM_KEY_SMVAL(stmkey)   ((stmkey)->smval)
- #define STM_KEY_CIMSK(stmkey)   ((stmkey)->cimsk)
- #define STM_KEY_CIVAL(stmkey)   ((stmkey)->cival)
- 
- 
- /* ストリーム再生範囲           */
- typedef struct {
-     Sint32      sfad;           /* 再生開始FAD                          */
-     Sint32      fasnum;         /* 再生セクタ数                         */
- } StmFrange;
- 
- #define STM_FRANGE_SFAD(frange)         ((frange)->sfad)
- #define STM_FRANGE_FASNUM(frange)       ((frange)->fasnum)
- 
- 
- /* セクタ情報                   */
- typedef struct {
-     Sint32      fad;            /* フレームアドレス                     */
-     Sint32      fn;             /* ファイル番号                         */
-     Sint32      cn;             /* チャネル番号                         */
-     Uint8       sm;             /* サブモード                           */
-     Uint8       ci;             /* コーディング情報                     */
- } StmSct;
- 
- #define STM_SCT_FAD(sct)        ((sct)->fad)
- #define STM_SCT_FN(sct)         ((sct)->fn)
- #define STM_SCT_CN(sct)         ((sct)->cn)
- #define STM_SCT_SM(sct)         ((sct)->sm)
- #define STM_SCT_CI(sct)         ((sct)->ci)
- 
- 
- /* エラー管理                   */
- typedef struct {
-     Sint32      code;           /* エラーコード                         */
-     Sint32      where;          /* エラー発生場所                       */
-     StmErrFunc  func;           /* エラー発生時の呼びだし関数           */
-     void        *obj;           /* 呼びだし関数の第一引数               */
- } StmErrStat;
- 
- #define STM_ERR_CODE(err)       ((err)->code)
- #define STM_ERR_WHERE(err)      ((err)->where)
- #define STM_ERR_FUNC(err)       ((err)->func)
- #define STM_ERR_OBJ(err)        ((err)->obj)
- 
- 
- /* ストリームシステム管理       */
- typedef struct {
-     StmGrp      *stmgrptbl;     /* ストリームグループ割当て領域         */
-     Sint32      stmgrpmax;      /* ストリームグループ最大数             */
-     StmObj      *stmtbl;        /* ストリーム割当て領域                 */
-     Sint32      stmmax;         /* ストリーム最大数                     */
-     StmGrpHn    curgrp;         /* 現在処理中ストリームグループ         */
-     Sint32      sfad;           /* 再生開始FAD                          */
-     Sint32      efad;           /* 再生終了FAD                          */
-     StmErrStat  err;            /* エラー管理                           */
-     Bool        svrexec;        /* STM_ExecServer処理中                 */
- } StmMng;
- 
- 
- /*****************************************************************************
-  *      処理マクロ
-  *****************************************************************************/
- 
- /* 作業領域サイズの取得                 */
- #define STM_WORK_SIZE(grpmax, stmmax)   \
-     (sizeof(StmMng) + sizeof(StmGrp) * (grpmax) + sizeof(StmObj) * (stmmax))
- 
- /*****************************************************************************
-  *      関数の宣言
-  *****************************************************************************/
- 
- /* ストリームシステム初期化             */
- Bool    STM_Init(Sint32 grpmax, Sint32 stmmax, void *work);
- 
- /* ストリームシステムのリセット         */
- void    STM_Reset(void);
- 
- /* ストリームグループのオープン         */
- StmGrpHn        STM_OpenGrp(void);
- 
- /* ストリームグループのクローズ         */
- void    STM_CloseGrp(StmGrpHn grp);
- 
- /* ストリーム数の取得                   */
- Sint32  STM_GetStmNum(StmGrpHn grp);
- 
- /* ストリームハンドルの取得             */
- StmHn   STM_GetStmHndl(StmGrpHn grp, Sint32 nstm);
- 
- /* バッファサイズ監視関数の登録         */
- void    STM_SetCdbufFunc(StmGrpHn grp, StmHn stm, Sint32 nsct, 
-                                        StmCdbufFunc func, void *obj);
- 
- /* 識別子によるファイルのオープン       */
- StmHn   STM_OpenFid(StmGrpHn grp, Sint32 fid, StmKey *key, Sint32 lpread);
- 
- /* セクタ位置によるファイルのオープン   */
- StmHn   STM_OpenFrange(StmGrpHn grp, StmFrange *frange, StmKey *key,
-                                                            Sint32 lpread);
- 
- /* 常駐ストリームのオープン             */
- StmHn   STM_OpenResi(StmGrpHn grp, Sint32 fid, StmKey *key, Sint32 fad);
- 
- /* ストリームのクローズ                 */
- void    STM_Close(StmHn stm);
- 
- /* ストリームキーの設定                 */
- void    STM_SetKey(StmHn stm, StmKey *stmkey);
- 
- /* ストリーム情報の取得                 */
- StmGrpHn        STM_GetInfo(StmHn stm, Sint32 *fid, StmFrange *range, 
-                                                 Sint32 *bn, StmKey *stmkey);
- 
- /* セクタ数からワード数への変換         */
- Sint32  STM_SctToWord(StmHn stm, Sint32 nsct);
- 
- /* ワード数からセクタ数への変換         */
- Sint32  STM_WordToSct(StmHn stm, Sint32 nword);
- 
- /* ストリームハンドルのエイリアス設定   */
- Bool    STM_SetAlias(StmHn alias, StmHn stm);
- 
- /* ストリームハンドルのエイリアス解除   */
- void    STM_UnsetAlias(StmHn alias);
- 
- /* 転送領域の設定                       */
- void    STM_SetTrBuf(StmHn stm, void *buffer, Sint32 nunit, Sint32 unitsize);
- 
- /* 転送関数の設定                       */
- void    STM_SetTrFunc(StmHn stm, StmTrFunc func, void *obj);
- 
- /* 転送関数における転送開始             */
- Uint32  *STM_StartTrans(StmHn stm, Sint32 *dadr);
- 
- /* 転送ゲートの開閉                     */
- void    STM_SetTrGate(StmHn stm, Sint32 gate);
- 
- /* 最大転送セクタ数の設定               */
- void    STM_SetTrPara(StmHn stm, Sint32 tsct);
- 
- /* 転送開始FADの設定                    */
- void    STM_SetTrFad(StmHn stm, Sint32 fad);
- 
- /* 転送モードの設定                     */
- void    STM_SetTrMode(StmHn stm, Sint32 tmode);
- 
- /* 転送領域のリセット                   */
- void    STM_ResetTrBuf(StmHn stm);
- 
- /* ＣＤバッファ有効セクタ数の取得       */
- Sint32  STM_GetNumCdbuf(StmHn stm);
- 
- /* 読み込みセクタ情報の取得             */
- Bool    STM_GetSctInfo(StmHn stm, Sint32 spos, StmSct *sinfo);
- 
- /* 転送領域のデータ数(ワード)の取得     */
- Sint32  STM_GetLenTrBuf(StmHn stm);
- 
- /* 転送領域フルのチェック               */
- Bool    STM_IsTrBufFull(StmHn stm);
- 
- /* ストリームデータ転送中のチェック     */
- Bool    STM_IsTrans(StmHn stm);
- 
- /* サーバ実行グループの指定(即時復帰)   */
- Bool    STM_NwSetExecGrp(StmGrpHn grp);
- 
- /* サーバ実行グループの指定(完了復帰)   */
- Bool    STM_SetExecGrp(StmGrpHn grp);
- 
- /* サーバの実行                         */
- Sint32  STM_ExecServer(void);
- 
- /* ピックアップの移動                   */
- void    STM_MovePickup(StmHn stm, Sint32 off);
- 
- /* リードエラー発生時のリカバリ         */
- Sint32  STM_Recover(void);
- 
- /* ループストリームの指定               */
- Bool    STM_SetLoop(StmGrpHn grp, StmHn loopstm, Sint32 loopmax);
- 
- /* ループカウンタの取得                 */
- Sint32  STM_GetLoopCnt(StmGrpHn grp);
- 
- /* 実行状態の取得                       */
- Sint32  STM_GetExecStat(StmGrpHn grp, Sint32 *fad);
- 
- /* 実行終了のチェック                   */
- Bool    STM_IsComplete(StmHn stm);
- 
- /* ストリームデータの転送               */
- Bool    STM_ExecTrans(StmHn stm);
- 
- /* ストリームの接続                     */
- void    STM_ConnectCdbuf(StmHn keystm, StmHn bufstm);
- 
- /* CDバッファデータの移動               */
- void    STM_MoveCdbuf(StmHn src, Sint32 spos, Sint32 snum, StmHn dst);
- 
- /* CDバッファデータの消去               */
- void    STM_EraseCdbuf(StmHn stm, Sint32 spos, Sint32 snum);
- 
- /* エラー発生時の呼びだし関数の登録     */
- void    STM_SetErrFunc(StmErrFunc func, void *obj);
- 
- /* エラー状態の取得                     */
- void    STM_GetErrStat(StmErrStat *stat);
- 
- #endif  /* SEGA_STM_H   */
- 
- /* end of sega_stm.h            */
--- 0 ----
diff -crBN --binary sbl6/segalib/stm/stm_acc.c sbl6_patch/segalib/stm/stm_acc.c
*** sbl6/segalib/stm/stm_acc.c	1996-02-08 05:25:44.000000000 -0500
--- sbl6_patch/segalib/stm/stm_acc.c	2024-05-20 08:53:10.000000000 -0400
***************
*** 534,540 ****
   *************************************************/
  Bool    STM_GetSctInfo(StmHn stm, Sint32 spos, StmSct *sinfo)
  {
-     Sint32      ec;
      Bool        ret;
  
      STMERR_SetFunc(STM_GETSCTINFO);
--- 534,539 ----
diff -crBN --binary sbl6/segalib/stm/stm_init.c sbl6_patch/segalib/stm/stm_init.c
*** sbl6/segalib/stm/stm_init.c	1996-02-08 05:25:46.000000000 -0500
--- sbl6_patch/segalib/stm/stm_init.c	2023-01-08 14:04:40.000000000 -0500
***************
*** 202,208 ****
  {
      StmHn       *lst_stm;
      StmHn       before;
-     Sint32      next;
      Sint32      stm_sfad, stm_efad;
      Sint32      lst_sfad, lst_efad;
      Sint32      ret;
--- 202,207 ----
***************
*** 464,478 ****
  {
      StmGrpHn    grp;
      StmHn       *next;
-     StmHn       before;
-     Sint32      bufno;
      Bool        ret = TRUE;;
  
      if (STM_SVRSTAT(stm) == SVR_USE) {
          STM_SVRSTAT(stm) = SVR_UNUSE;
          grp = STM_GRPHN(stm);
          if (grp == NULL) {
!             return;
          }
          /* 再生順リストからストリームを切断する         */
          for (next = &STM_GRP_SFADLST(grp); (*next != NULL)&&(*next != stm); 
--- 463,475 ----
  {
      StmGrpHn    grp;
      StmHn       *next;
      Bool        ret = TRUE;;
  
      if (STM_SVRSTAT(stm) == SVR_USE) {
          STM_SVRSTAT(stm) = SVR_UNUSE;
          grp = STM_GRPHN(stm);
          if (grp == NULL) {
!             return FALSE;
          }
          /* 再生順リストからストリームを切断する         */
          for (next = &STM_GRP_SFADLST(grp); (*next != NULL)&&(*next != stm); 
***************
*** 570,579 ****
      StmHn       next;
      StmGrpHn    grp;
      Sint32      sfad, efad;
!     Sint32      stat, fad, i;
      Sint32      atr;
      Sint32      ret;
-     Uint16      hirq;
  
      grp = STM_GRPHN(stm);
      if (STM_SVRSTAT(stm) == SVR_USE) {    /* オープンストリーム  */
--- 567,575 ----
      StmHn       next;
      StmGrpHn    grp;
      Sint32      sfad, efad;
!     Sint32      fad;
      Sint32      atr;
      Sint32      ret;
  
      grp = STM_GRPHN(stm);
      if (STM_SVRSTAT(stm) == SVR_USE) {    /* オープンストリーム  */
***************
*** 667,673 ****
  void    STM_CloseGrp(StmGrpHn grp)
  {
      StmHn               stm;
!     Bool                close_flag = TRUE;
  
      STMERR_SetFunc(STM_CLOSEGRP);
      if (grp == NULL) {
--- 663,669 ----
  void    STM_CloseGrp(StmGrpHn grp)
  {
      StmHn               stm;
! //    Bool                close_flag = TRUE;
  
      STMERR_SetFunc(STM_CLOSEGRP);
      if (grp == NULL) {
diff -crBN --binary sbl6/segalib/stm/stm_loc.c sbl6_patch/segalib/stm/stm_loc.c
*** sbl6/segalib/stm/stm_loc.c	1996-02-08 05:25:46.000000000 -0500
--- sbl6_patch/segalib/stm/stm_loc.c	2024-05-20 08:17:36.000000000 -0400
***************
*** 28,33 ****
--- 28,34 ----
  #include        "stm_def.h"
  #include        "gfs_def.h"
  #include        "gfs_cdc.h"
+ #include        "gfs_cdb.h"
  #include        "gfs_cdf.h"
  #include        "gfs_dir.h"
  #include        "stm_loc.h"
diff -crBN --binary sbl6/segalib/stm/stm_svr.c sbl6_patch/segalib/stm/stm_svr.c
*** sbl6/segalib/stm/stm_svr.c	1996-02-08 05:25:48.000000000 -0500
--- sbl6_patch/segalib/stm/stm_svr.c	2024-05-20 14:05:32.000000000 -0400
***************
*** 1,27 ****
  /*****************************************************************************
!  *      ソフトウェアライブラリ
   *
   *      Copyright (c) 1994,1995,1996 SEGA
   *
!  * Library: ストリームシステム
!  * Module : サーバモジュール
   * File   : stm_svr.c
   * Date   : 1995-02-01
   * Version: 2.10
   * Author : H.T
   *
   *****************************************************************************/
! /* SGLの場合コンパイルオプションにより定義すること
   * #define USE_SGL
   */
  
  /*****************************************************************************
!  *      インクルードファイル
   *****************************************************************************/
  #include        <stdlib.h>
  #include        <string.h>
  
  #include        "sega_stm.h"
  #include        "gfs_def.h"
  #include        "gfs_cdc.h"
  #include        "gfs_cdf.h"
--- 1,28 ----
  /*****************************************************************************
!  *      ｿｽ\ｿｽtｿｽgｿｽEｿｽFｿｽAｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ
   *
   *      Copyright (c) 1994,1995,1996 SEGA
   *
!  * Library: ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽ
!  * Module : ｿｽTｿｽ[ｿｽoｿｽｿｽｿｽWｿｽｿｽｿｽ[ｿｽｿｽ
   * File   : stm_svr.c
   * Date   : 1995-02-01
   * Version: 2.10
   * Author : H.T
   *
   *****************************************************************************/
! /* SGLｿｽﾌ場合ｿｽRｿｽｿｽｿｽpｿｽCｿｽｿｽｿｽIｿｽvｿｽVｿｽｿｽｿｽｿｽｿｽﾉゑｿｽｿｽｿｽｿｽｿｽｿｽ`ｿｽｿｽｿｽ驍ｱｿｽｿｽ
   * #define USE_SGL
   */
  
  /*****************************************************************************
!  *      ｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽ
   *****************************************************************************/
  #include        <stdlib.h>
  #include        <string.h>
  
  #include        "sega_stm.h"
+ #include        "stm_def.h"
  #include        "gfs_def.h"
  #include        "gfs_cdc.h"
  #include        "gfs_cdf.h"
***************
*** 30,59 ****
  #include        "gfs_buf.h"
  #include        "gfs_dir.h"
  #include        "stm_loc.h"
- #include        "stm_def.h"
  
  /*****************************************************************************
!  *      変数の定義
   *****************************************************************************/
  
! /* コマンド登録領域     */
  StmCmd  stm_cmd_area;
  
  /*****************************************************************************
!  *      関数の定義
   *****************************************************************************/
  /*--- STMMNG functions -------------------------------------------------*/
  
  /*****************************************************
!  * CDストリームがないかどうかを調べる
!  * grp  : ストリームグループ
!  * 戻り値 : TRUE CDストリームはない
   *****************************************************/
  STM_LOCAL Bool  stmmng_isNoCdFile(StmGrpHn grp)
  {
      StmHn       stm;
  
!     /* 常駐ストリームはループストリームにならない       */
      if (STM_GRP_LOOPSTM(grp) != NULL) {
          return (FALSE);
      }
--- 31,59 ----
  #include        "gfs_buf.h"
  #include        "gfs_dir.h"
  #include        "stm_loc.h"
  
  /*****************************************************************************
!  *      ｿｽﾏ撰ｿｽｿｽﾌ抵ｿｽｿｽ`
   *****************************************************************************/
  
! /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽoｿｽ^ｿｽﾌ茨ｿｽ     */
  StmCmd  stm_cmd_area;
  
  /*****************************************************************************
!  *      ｿｽﾖ撰ｿｽｿｽﾌ抵ｿｽｿｽ`
   *****************************************************************************/
  /*--- STMMNG functions -------------------------------------------------*/
  
  /*****************************************************
!  * CDｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾇゑｿｽｿｽｿｽｿｽ調べゑｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * ｿｽﾟゑｿｽｿｽl : TRUE CDｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾍなゑｿｽ
   *****************************************************/
  STM_LOCAL Bool  stmmng_isNoCdFile(StmGrpHn grp)
  {
      StmHn       stm;
  
!     /* ｿｽ駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾍｿｽｿｽ[ｿｽvｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾉなゑｿｽｿｽﾈゑｿｽ       */
      if (STM_GRP_LOOPSTM(grp) != NULL) {
          return (FALSE);
      }
***************
*** 67,85 ****
  
  
  /*****************************************************
!  * 全ストリームが常駐ストリームかどうかを調べる
!  * grp  : ストリームグループ
!  * 戻り値 : TRUE すべて常駐ストリーム
   *****************************************************/
  STM_LOCAL Bool  stmmng_isAllResi(StmGrpHn grp)
  {
      StmHn       stm;
  
!     /* 常駐ストリームはループストリームにならない       */
      if (STM_GRP_LOOPSTM(grp) != NULL) {
          return (FALSE);
      }
!     /* 絞りが接続されている場合 */
      if (STM_GRP_FLTLST(grp) != NULL) {
          return (FALSE);
      }
--- 67,85 ----
  
  
  /*****************************************************
!  * ｿｽSｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽ駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾇゑｿｽｿｽｿｽｿｽ調べゑｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * ｿｽﾟゑｿｽｿｽl : TRUE ｿｽｿｽｿｽﾗて常駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽ
   *****************************************************/
  STM_LOCAL Bool  stmmng_isAllResi(StmGrpHn grp)
  {
      StmHn       stm;
  
!     /* ｿｽ駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾍｿｽｿｽ[ｿｽvｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾉなゑｿｽｿｽﾈゑｿｽ       */
      if (STM_GRP_LOOPSTM(grp) != NULL) {
          return (FALSE);
      }
!     /* ｿｽiｿｽ閧ｪｿｽﾚ托ｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽ鼾 */
      if (STM_GRP_FLTLST(grp) != NULL) {
          return (FALSE);
      }
***************
*** 93,100 ****
  
  
  /*************************************************
!  * CSCTビット関数の登録
!  * grp : 実行中ストリームグループ
   *************************************************/
  STM_LOCAL void  stm_execCsct(void *grp)
  {
--- 93,100 ----
  
  
  /*************************************************
!  * CSCTｿｽrｿｽbｿｽgｿｽﾖ撰ｿｽｿｽﾌ登ｿｽ^
!  * grp : ｿｽｿｽｿｽsｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
   *************************************************/
  STM_LOCAL void  stm_execCsct(void *grp)
  {
***************
*** 118,125 ****
  
  
  /*************************************************
!  * ステータスによるエラーの設定
!  * stat : ドライブのステータス
   *************************************************/
  STM_LOCAL void  stm_setErr(Sint32 stat)
  {
--- 118,125 ----
  
  
  /*************************************************
!  * ｿｽXｿｽeｿｽ[ｿｽ^ｿｽXｿｽﾉゑｿｽｿｽｿｽｿｽGｿｽｿｽｿｽ[ｿｽﾌ設抵ｿｽ
!  * stat : ｿｽhｿｽｿｽｿｽCｿｽuｿｽﾌスｿｽeｿｽ[ｿｽ^ｿｽX
   *************************************************/
  STM_LOCAL void  stm_setErr(Sint32 stat)
  {
***************
*** 142,156 ****
          STMERR_SetCode(code);
      }
  }
!         
  
  /*--- stmtsk functions -------------------------------------------------*/
  
  /*************************************************
!  * サーバ実行グループの変更
!  * grp    : 変更後のストリームグループハンドル
!  * 戻り値 : TRUE        処理完了
!             FALSE       処理中
   *************************************************/
  STM_LOCAL Bool  stmtsk_setExecGrp(void *_grp)
  {
--- 142,156 ----
          STMERR_SetCode(code);
      }
  }
! 
  
  /*--- stmtsk functions -------------------------------------------------*/
  
  /*************************************************
!  * ｿｽTｿｽ[ｿｽoｿｽｿｽｿｽsｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ変更
!  * grp    : ｿｽﾏ更ｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE        ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ
!             FALSE       ｿｽｿｽｿｽｿｽｿｽｿｽ
   *************************************************/
  STM_LOCAL Bool  stmtsk_setExecGrp(void *_grp)
  {
***************
*** 168,178 ****
      grp = (StmGrpHn)_grp;
      if (MNG_CURGRP(stm_mng_ptr) != grp) {
          oldgrp = MNG_CURGRP(stm_mng_ptr);
!         /* 読み込み中のストリームグループを停止する     */
          if (oldgrp != NULL) {
              stat = GFCF_GetStat(&fad, NULL);
!             stm_setErr(stat);                   /* エラーコードの設定   */
!             /* ドライブを停止する       */
              if ((IS_PLAYING(oldgrp) == TRUE)&&
                  (IS_PAUSING(oldgrp) == FALSE)) {
                  ret = STL_StopIn(oldgrp);
--- 168,178 ----
      grp = (StmGrpHn)_grp;
      if (MNG_CURGRP(stm_mng_ptr) != grp) {
          oldgrp = MNG_CURGRP(stm_mng_ptr);
!         /* ｿｽﾇみ搾ｿｽｿｽﾝ抵ｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽｿｽｿｽｿｽｿｽ~ｿｽｿｽｿｽｿｽ     */
          if (oldgrp != NULL) {
              stat = GFCF_GetStat(&fad, NULL);
!             stm_setErr(stat);                   /* ｿｽGｿｽｿｽｿｽ[ｿｽRｿｽ[ｿｽhｿｽﾌ設抵ｿｽ   */
!             /* ｿｽhｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽ~ｿｽｿｽｿｽｿｽ       */
              if ((IS_PLAYING(oldgrp) == TRUE)&&
                  (IS_PAUSING(oldgrp) == FALSE)) {
                  ret = STL_StopIn(oldgrp);
***************
*** 181,209 ****
                  }
                  STM_GRP_ATR(oldgrp) |= STMGRP_ATR_PAUSE;
              }
!             /* ピックアップを解放する   */
              if (STM_GRP_PUID(oldgrp) >= 0) {
                  GFCD_UngetPickup(STM_GRP_PUID(oldgrp));
                  STM_GRP_PUID(oldgrp) = -1;
                  GFCD_SetCsctFunc(GFCD_NULLFUNC, NULL);
              }
!             /* グループが処理中の場合   */
              if (STM_GRP_ACSTAT(oldgrp) != STM_EXEC_COMPLETED) {
!                 STM_GRP_ACSTAT(oldgrp) = STM_EXEC_PAUSE;  /* ポーズ設定 */
!                 /* COMPLETEDの場合ステータスは変化しない        */
              }
!             /* 停止完了                 */
              if (stat == GFS_STAT_NOACT) {
                  next = STM_GRP_NEXTTRNS(oldgrp);
                  if (next != NULL) {
                      GFTR_Stop(STM_GFS(next), GFTR_ALLSCT);
                      GFS_TRN_STAT(&GFS_FILE_TRANS(STM_GFS(next))) =
                                                                GFTR_ST_NOACT;
!                                       /* END 状態にならないようにする   */
                  }
                  if (IS_PAUSING(oldgrp) == TRUE) {
                      lst_fad = STMMNG_GetLstFad(oldgrp);
!                     /* 読み込みを完了していない場合FADを更新する        */
                      fad = STL_GetCurFad();
                      if (STM_GRP_FAD(oldgrp) <= lst_fad) {
                          STM_GRP_FAD(oldgrp) = fad;
--- 181,209 ----
                  }
                  STM_GRP_ATR(oldgrp) |= STMGRP_ATR_PAUSE;
              }
!             /* ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ   */
              if (STM_GRP_PUID(oldgrp) >= 0) {
                  GFCD_UngetPickup(STM_GRP_PUID(oldgrp));
                  STM_GRP_PUID(oldgrp) = -1;
                  GFCD_SetCsctFunc(GFCD_NULLFUNC, NULL);
              }
!             /* ｿｽOｿｽｿｽｿｽ[ｿｽvｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ場合   */
              if (STM_GRP_ACSTAT(oldgrp) != STM_EXEC_COMPLETED) {
!                 STM_GRP_ACSTAT(oldgrp) = STM_EXEC_PAUSE;  /* ｿｽ|ｿｽ[ｿｽYｿｽﾝ抵ｿｽ */
!                 /* COMPLETEDｿｽﾌ場合ｿｽXｿｽeｿｽ[ｿｽ^ｿｽXｿｽﾍ変会ｿｽｿｽｿｽｿｽﾈゑｿｽ        */
              }
!             /* ｿｽｿｽｿｽ~ｿｽｿｽｿｽｿｽ                 */
              if (stat == GFS_STAT_NOACT) {
                  next = STM_GRP_NEXTTRNS(oldgrp);
                  if (next != NULL) {
                      GFTR_Stop(STM_GFS(next), GFTR_ALLSCT);
                      GFS_TRN_STAT(&GFS_FILE_TRANS(STM_GFS(next))) =
                                                                GFTR_ST_NOACT;
!                                       /* END ｿｽｿｽｿｽﾔになゑｿｽｿｽﾈゑｿｽｿｽ謔､ｿｽﾉゑｿｽｿｽｿｽ   */
                  }
                  if (IS_PAUSING(oldgrp) == TRUE) {
                      lst_fad = STMMNG_GetLstFad(oldgrp);
!                     /* ｿｽﾇみ搾ｿｽｿｽﾝゑｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽ鼾FADｿｽｿｽｿｽXｿｽVｿｽｿｽｿｽｿｽ        */
                      fad = STL_GetCurFad();
                      if (STM_GRP_FAD(oldgrp) <= lst_fad) {
                          STM_GRP_FAD(oldgrp) = fad;
***************
*** 215,221 ****
              }
          }
  
!         /* 新しいグループを設定する                     */
          if (oldgrp == NULL) {
              if (grp != NULL) {
                  if (STM_GRP_PUID(grp) < 0) {
--- 215,221 ----
              }
          }
  
!         /* ｿｽVｿｽｿｽｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽｿｽｿｽﾝ定すｿｽｿｽ                     */
          if (oldgrp == NULL) {
              if (grp != NULL) {
                  if (STM_GRP_PUID(grp) < 0) {
***************
*** 226,232 ****
                      GFCD_SetCsctFunc(stm_execCsct, grp);
                  }
                  if (STM_GRP_PUID(grp) >= 0) {
!                     /* CDデバイスの接続変更     */
                      stm = STM_GRP_FLTLST(grp);
                      if (stm != NULL) {
                          fltno = GFS_CDR_FLT(STM_DTSRC(stm));
--- 226,232 ----
                      GFCD_SetCsctFunc(stm_execCsct, grp);
                  }
                  if (STM_GRP_PUID(grp) >= 0) {
!                     /* CDｿｽfｿｽoｿｽCｿｽXｿｽﾌ接托ｿｽｿｽﾏ更     */
                      stm = STM_GRP_FLTLST(grp);
                      if (stm != NULL) {
                          fltno = GFS_CDR_FLT(STM_DTSRC(stm));
***************
*** 258,265 ****
  /*--- STM functions ----------------------------------------------------*/
  
  /*************************************************
!  * サーバ実行グループの指定(7.1)
!  * grp  : ストリームグループハンドル
   *************************************************/
  Bool    STM_NwSetExecGrp(StmGrpHn grp)
  {
--- 258,265 ----
  /*--- STM functions ----------------------------------------------------*/
  
  /*************************************************
!  * ｿｽTｿｽ[ｿｽoｿｽｿｽｿｽsｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ指ｿｽｿｽ(7.1)
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  Bool    STM_NwSetExecGrp(StmGrpHn grp)
  {
***************
*** 275,282 ****
  
  
  /*************************************************
!  * サーバ実行グループの指定(7.2)
!  * grp  : ストリームグループハンドル
   *************************************************/
  Bool    STM_SetExecGrp(StmGrpHn grp)
  {
--- 275,282 ----
  
  
  /*************************************************
!  * ｿｽTｿｽ[ｿｽoｿｽｿｽｿｽsｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ指ｿｽｿｽ(7.2)
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  Bool    STM_SetExecGrp(StmGrpHn grp)
  {
***************
*** 296,305 ****
  
  
  /*************************************************
!  * ストリームデータ転送中の取得(6.3)
!  * stm  : ストリームハンドル
!  * 戻り値 : TRUE        転送中
!  *        : FALSE       転送していない
   *************************************************/
  STM_LOCAL Bool  stmsvr_isTrans(StmHn stm)
  {
--- 296,305 ----
  
  
  /*************************************************
!  * ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽ]ｿｽｿｽｿｽｿｽｿｽﾌ取得(6.3)
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE        ｿｽ]ｿｽｿｽｿｽｿｽ
!  *        : FALSE       ｿｽ]ｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽ
   *************************************************/
  STM_LOCAL Bool  stmsvr_isTrans(StmHn stm)
  {
***************
*** 333,340 ****
  
  
  /*************************************************
!  * 読み込みフラグの解除
!  * grp  : ストリームグループハンドル
   *************************************************/
  STM_LOCAL void  stm_setReadFalse(StmGrpHn grp)
  {
--- 333,340 ----
  
  
  /*************************************************
!  * ｿｽﾇみ搾ｿｽｿｽﾝフｿｽｿｽｿｽOｿｽﾌ会ｿｽｿｽｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  STM_LOCAL void  stm_setReadFalse(StmGrpHn grp)
  {
***************
*** 344,352 ****
  
      fad = STM_GRP_FAD(grp);
      for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
!         /* ストリームの終了FADを取得    */
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!         if (sfad > fad) {       /* 開始セクタが現在位置以降の場合    */
              GFS_FILE_ASTAT(STM_GFS(stm)) = GFS_SVR_COMPLETED;
              STM_ATR(stm) &= ~STM_ATR_READ;
          }
--- 344,352 ----
  
      fad = STM_GRP_FAD(grp);
      for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
!         /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ終ｿｽｿｽFADｿｽｿｽｿｽ謫ｾ    */
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!         if (sfad > fad) {       /* ｿｽJｿｽnｿｽZｿｽNｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝ位置ｿｽﾈ降ｿｽﾌ場合    */
              GFS_FILE_ASTAT(STM_GFS(stm)) = GFS_SVR_COMPLETED;
              STM_ATR(stm) &= ~STM_ATR_READ;
          }
***************
*** 355,362 ****
  
  
  /*************************************************
!  * 転送領域の初期化
!  * grp  : ストリームグループハンドル
   *************************************************/
  STM_LOCAL void  stm_resetTrbuf(StmGrpHn grp)
  {
--- 355,362 ----
  
  
  /*************************************************
!  * ｿｽ]ｿｽｿｽｿｽﾌ茨ｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  STM_LOCAL void  stm_resetTrbuf(StmGrpHn grp)
  {
***************
*** 370,377 ****
  
  
  /*************************************************
!  * 転送フラグのリセット
!  * grp  : ストリームグループ
   *************************************************/
  STM_LOCAL void  stm_resetTrflag(StmGrpHn grp)
  {
--- 370,377 ----
  
  
  /*************************************************
!  * ｿｽ]ｿｽｿｽｿｽtｿｽｿｽｿｽOｿｽﾌｿｽｿｽZｿｽbｿｽg
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
   *************************************************/
  STM_LOCAL void  stm_resetTrflag(StmGrpHn grp)
  {
***************
*** 389,398 ****
  
  
  /*************************************************
!  * ループ開始ストリームの指定(7.5)
!  * grp  : ストリームグループハンドル
!  * stm  : ループ開始ストリーム
!  * loopmax : ループ回数(無限回の場合STM_LOOP_ENDLESS)
   *************************************************/
  STM_LOCAL Bool  stmsvr_setLoop(StmGrpHn grp, StmHn stm, Sint32 loopmax)
  {
--- 389,398 ----
  
  
  /*************************************************
!  * ｿｽｿｽｿｽ[ｿｽvｿｽJｿｽnｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ指ｿｽｿｽ(7.5)
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * stm  : ｿｽｿｽｿｽ[ｿｽvｿｽJｿｽnｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽ
!  * loopmax : ｿｽｿｽｿｽ[ｿｽvｿｽｿｽｿｽｿｽ(ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ場合STM_LOOP_ENDLESS)
   *************************************************/
  STM_LOCAL Bool  stmsvr_setLoop(StmGrpHn grp, StmHn stm, Sint32 loopmax)
  {
***************
*** 403,409 ****
          stm_resetTrflag(grp);
      }
      if (stm == STM_LOOP_DFL) {
!         /* 読み込みの終っていない先頭のストリームをサーチする   */
          for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
              if ((IS_STM_READEND(stm) == FALSE)&&(IS_STM_RESI(stm) == FALSE)) {
                  break;
--- 403,409 ----
          stm_resetTrflag(grp);
      }
      if (stm == STM_LOOP_DFL) {
!         /* ｿｽﾇみ搾ｿｽｿｽﾝの終ｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽ謫ｪｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽTｿｽ[ｿｽ`ｿｽｿｽｿｽｿｽ   */
          for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
              if ((IS_STM_READEND(stm) == FALSE)&&(IS_STM_RESI(stm) == FALSE)) {
                  break;
***************
*** 448,455 ****
  
  
  /*************************************************
!  * 読み込みフラグの設定
!  * grp  : ストリームグループハンドル
   *************************************************/
  STM_LOCAL void  stm_setReadTrue(StmGrpHn grp)
  {
--- 448,455 ----
  
  
  /*************************************************
!  * ｿｽﾇみ搾ｿｽｿｽﾝフｿｽｿｽｿｽOｿｽﾌ設抵ｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  STM_LOCAL void  stm_setReadTrue(StmGrpHn grp)
  {
***************
*** 459,467 ****
  
      fad = STM_GRP_FAD(grp);
      for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
!         /* ストリームの開始FADを取得    */
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!         /* 開始セクタが現在位置以降,または常駐ストリームの場合    */
          if (((sfad >= fad)&&(IS_STM_READEND(stm) == FALSE))||
              (IS_STM_RESI(stm) == TRUE)) {
              STM_ATR(stm) |= STM_ATR_READ;
--- 459,467 ----
  
      fad = STM_GRP_FAD(grp);
      for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
!         /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ開ｿｽnFADｿｽｿｽｿｽ謫ｾ    */
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!         /* ｿｽJｿｽnｿｽZｿｽNｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝ位置ｿｽﾈ降,ｿｽﾜゑｿｽｿｽﾍ常駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ場合    */
          if (((sfad >= fad)&&(IS_STM_READEND(stm) == FALSE))||
              (IS_STM_RESI(stm) == TRUE)) {
              STM_ATR(stm) |= STM_ATR_READ;
***************
*** 473,494 ****
  
  
  /*************************************************
!  * 読み込み終了フラグの設定
!  * grp  : ストリームグループハンドル
   *************************************************/
  void    STMSVR_SetReadEnd(StmGrpHn grp)
  {
      Sint32      fad;
      StmHn       stm;
      Sint32      sfad, efad;
-     Sint32      nsct;
      Sint32      loopmax, loopcnt;
  
      fad = STM_GRP_FAD(grp);
      for (stm = STM_GRP_FLTLST(grp); stm != NULL; stm = STM_FLTLST(stm)) {
!         /* ストリームの開始FADを取得    */
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!         /* 終了セクタが現在位置以前ですでに読み込まれている場合 */
          if ((efad < fad)&&(IS_STM_READ(stm) == TRUE)&&
              (IS_STM_LOOPNOREAD(stm) == TRUE)) {
              STM_ATR(stm) |= STM_ATR_READEND;
--- 473,493 ----
  
  
  /*************************************************
!  * ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽｿｽtｿｽｿｽｿｽOｿｽﾌ設抵ｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  void    STMSVR_SetReadEnd(StmGrpHn grp)
  {
      Sint32      fad;
      StmHn       stm;
      Sint32      sfad, efad;
      Sint32      loopmax, loopcnt;
  
      fad = STM_GRP_FAD(grp);
      for (stm = STM_GRP_FLTLST(grp); stm != NULL; stm = STM_FLTLST(stm)) {
!         /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ開ｿｽnFADｿｽｿｽｿｽ謫ｾ    */
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!         /* ｿｽIｿｽｿｽｿｽZｿｽNｿｽ^ｿｽｿｽｿｽｿｽｿｽﾝ位置ｿｽﾈ前ｿｽﾅゑｿｽｿｽﾅに読み搾ｿｽｿｽﾜゑｿｽｿｽﾄゑｿｽｿｽｿｽｿｽ鼾 */
          if ((efad < fad)&&(IS_STM_READ(stm) == TRUE)&&
              (IS_STM_LOOPNOREAD(stm) == TRUE)) {
              STM_ATR(stm) |= STM_ATR_READEND;
***************
*** 508,518 ****
  
  
  /*************************************************
!  * 再生範囲のチェック
!  * grp  : ストリームグループ
!  * fad  : 現在の再生FAD
!  * 戻り値: 正  移動先FAD
!  *         負  移動不用
   *************************************************/
  STM_LOCAL Sint32        stm_checkArea(StmGrpHn grp, Sint32 fad)
  {
--- 507,517 ----
  
  
  /*************************************************
!  * ｿｽﾄ撰ｿｽｿｽﾍ囲のチｿｽFｿｽbｿｽN
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * fad  : ｿｽｿｽｿｽﾝの再撰ｿｽFAD
!  * ｿｽﾟゑｿｽｿｽl: ｿｽｿｽ  ｿｽﾚ難ｿｽｿｽｿｽFAD
!  *         ｿｽｿｽ  ｿｽﾚ難ｿｽｿｽsｿｽp
   *************************************************/
  STM_LOCAL Sint32        stm_checkArea(StmGrpHn grp, Sint32 fad)
  {
***************
*** 525,567 ****
      for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
          if (IS_STM_READEND(stm) == FALSE) {
              STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!             /* 再生位置が有効範囲内の場合               */
              if ((sfad <= fad)&&(efad >= fad)) {
                  break;
              }
!             /* 次のストリームの開始位置に移動する       */
              if (sfad > fad) {
                  return (sfad);
              }
          }
      }
!     return (-1);                        /* 移動する必要なし             */
  }
  
!         
  
  /*************************************************
!  * ループストリームのFADの取得
!  * grp  : ストリームグループ
   *************************************************/
  STM_LOCAL Sint32        stm_getLoopFad(StmGrpHn grp)
  {
      Sint32      sfad, efad;
  
!     /* ループストリームの開始FADを取得  */
      STL_GetPlayArea(STM_FLOW(STM_GRP_LOOPSTM(grp)), &sfad, &efad);
      return (sfad);
  }
  
  
  /*************************************************
!  * 再生パラメータの取得
!  * grp  : ストリームグループ
!  * fad  : 現在のFAD
!  * efad : ストリームグループの終了FAD
!  * seekpos : ピックアップの移動先
!  * start : 再生を開始するかどうか
!  * 戻り値 : TRUE 読み込み終了  FALSE 読み込み中
   *************************************************/
  STM_LOCAL Bool  stm_getReadParam(StmGrpHn grp, Sint32 fad, Sint32 efad,
                                   Sint32 stat, Sint32 *seekpos, Bool *start)
--- 524,566 ----
      for (stm = STM_GRP_SFADLST(grp); stm != NULL; stm = STM_SFADLST(stm)) {
          if (IS_STM_READEND(stm) == FALSE) {
              STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!             /* ｿｽﾄ撰ｿｽｿｽﾊ置ｿｽｿｽｿｽLｿｽｿｽｿｽﾍ囲難ｿｽｿｽﾌ場合               */
              if ((sfad <= fad)&&(efad >= fad)) {
                  break;
              }
!             /* ｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ開ｿｽnｿｽﾊ置ｿｽﾉ移難ｿｽｿｽｿｽｿｽｿｽ       */
              if (sfad > fad) {
                  return (sfad);
              }
          }
      }
!     return (-1);                        /* ｿｽﾚ難ｿｽｿｽｿｽｿｽｿｽｿｽKｿｽvｿｽﾈゑｿｽ             */
  }
  
! 
  
  /*************************************************
!  * ｿｽｿｽｿｽ[ｿｽvｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽFADｿｽﾌ取得
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
   *************************************************/
  STM_LOCAL Sint32        stm_getLoopFad(StmGrpHn grp)
  {
      Sint32      sfad, efad;
  
!     /* ｿｽｿｽｿｽ[ｿｽvｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ開ｿｽnFADｿｽｿｽｿｽ謫ｾ  */
      STL_GetPlayArea(STM_FLOW(STM_GRP_LOOPSTM(grp)), &sfad, &efad);
      return (sfad);
  }
  
  
  /*************************************************
!  * ｿｽﾄ撰ｿｽｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽﾌ取得
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * fad  : ｿｽｿｽｿｽﾝゑｿｽFAD
!  * efad : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ終ｿｽｿｽFAD
!  * seekpos : ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽﾌ移難ｿｽｿｽｿｽ
!  * start : ｿｽﾄ撰ｿｽｿｽｿｽｿｽJｿｽnｿｽｿｽｿｽ驍ｩｿｽﾇゑｿｽｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽ  FALSE ｿｽﾇみ搾ｿｽｿｽﾝ抵ｿｽ
   *************************************************/
  STM_LOCAL Bool  stm_getReadParam(StmGrpHn grp, Sint32 fad, Sint32 efad,
                                   Sint32 stat, Sint32 *seekpos, Bool *start)
***************
*** 571,586 ****
  
      if (STM_GRP_LOOPCNT(grp) == STM_GRP_LOOPMAX(grp)) {
          if (STM_GRP_FAD(grp) > efad) {
!             /* 全ての読み込みを終了している場合         */
              *seekpos = -1;
              *start = FALSE;
              ret = TRUE;
              return (ret);
          } else if (stat == GFS_STAT_NOACT) {
!             /* 再生範囲を越えた後,ストリームが追加された場合    */
              cdstat = GFCF_GetStat(NULL, NULL);
!             stm_setErr(cdstat);                 /* エラーコードの設定   */
!             /* 再生を終了している場合           */
              if (fad > MNG_EFAD(stm_mng_ptr)) {
                  STM_GRP_FAD(grp) = STL_GetCurFad();
                  STM_GRP_LOOPCNT(grp)--;
--- 570,585 ----
  
      if (STM_GRP_LOOPCNT(grp) == STM_GRP_LOOPMAX(grp)) {
          if (STM_GRP_FAD(grp) > efad) {
!             /* ｿｽSｿｽﾄの読み搾ｿｽｿｽﾝゑｿｽｿｽIｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽ鼾         */
              *seekpos = -1;
              *start = FALSE;
              ret = TRUE;
              return (ret);
          } else if (stat == GFS_STAT_NOACT) {
!             /* ｿｽﾄ撰ｿｽｿｽﾍ囲ゑｿｽｿｽzｿｽｿｽｿｽｿｽｿｽｿｽ,ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾇ会ｿｽｿｽｿｽｿｽ黷ｽｿｽ鼾    */
              cdstat = GFCF_GetStat(NULL, NULL);
!             stm_setErr(cdstat);                 /* ｿｽGｿｽｿｽｿｽ[ｿｽRｿｽ[ｿｽhｿｽﾌ設抵ｿｽ   */
!             /* ｿｽﾄ撰ｿｽｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽ鼾           */
              if (fad > MNG_EFAD(stm_mng_ptr)) {
                  STM_GRP_FAD(grp) = STL_GetCurFad();
                  STM_GRP_LOOPCNT(grp)--;
***************
*** 590,596 ****
          if (((STM_GRP_FAD(grp) > efad)&&(IS_PLAYING(grp) == FALSE))||
              (STM_GRP_FLTLST(grp) == NULL)) {
              if (STM_GRP_LOOPSTM(grp) == NULL) {
!                 /* 全ての読み込みを終了している場合             */
                  *seekpos = -1;
                  *start = FALSE;
                  ret = TRUE;
--- 589,595 ----
          if (((STM_GRP_FAD(grp) > efad)&&(IS_PLAYING(grp) == FALSE))||
              (STM_GRP_FLTLST(grp) == NULL)) {
              if (STM_GRP_LOOPSTM(grp) == NULL) {
!                 /* ｿｽSｿｽﾄの読み搾ｿｽｿｽﾝゑｿｽｿｽIｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽ鼾             */
                  *seekpos = -1;
                  *start = FALSE;
                  ret = TRUE;
***************
*** 600,636 ****
              stm_resetTrflag(grp);
          }
      }
!     /* 読み込みを開始していない場合     */
      if (IS_PLAYING(grp) == FALSE) {
          if (STM_GRP_PUID(grp) >= 0) {
!             /* ピックアップを使用できる場合     */
              *seekpos = stm_checkArea(grp, STM_GRP_FAD(grp));
              if (*seekpos >= 0) {
                  STM_GRP_FAD(grp) = *seekpos;
              }
  
!             *start = TRUE;                      /* 読み込みを開始する   */
              STM_GRP_ACSTAT(grp) = STM_EXEC_DOING;
              *seekpos = -1;
          } else {
!             /* ファイルシステム使用中に呼ばれた場合など */
              *seekpos = -1;
!             *start = FALSE;                     /* 読み込みを開始しない */
          }
      } else if (IS_READING(grp) == TRUE) {
          if (fad <= efad) {
              cdstat = GFCF_GetStat(NULL, NULL);
!             stm_setErr(cdstat);                 /* エラーコードの設定   */
!             /* 再生を終了している場合   */
              if ((stat == GFS_STAT_NOACT)&&(fad > MNG_EFAD(stm_mng_ptr))) {
!                 /* 次回再生開始させる           */
                  STM_GRP_FAD(grp) = fad;
!                 /* 再生終了,読み込み終了        */
                  STM_GRP_ATR(grp) &= ~(STMGRP_ATR_PLAY|STMGRP_ATR_READ|
                                        STMGRP_ATR_SEEK);
                  *seekpos = -1;
              } else {
!                 /* 読み込み中           */
                  STM_GRP_FAD(grp) = fad;
                  if (IS_SEEKING(grp) == FALSE) {
                      *seekpos = stm_checkArea(grp, fad);
--- 599,635 ----
              stm_resetTrflag(grp);
          }
      }
!     /* ｿｽﾇみ搾ｿｽｿｽﾝゑｿｽｿｽJｿｽnｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽ鼾     */
      if (IS_PLAYING(grp) == FALSE) {
          if (STM_GRP_PUID(grp) >= 0) {
!             /* ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽｿｽｿｽgｿｽpｿｽﾅゑｿｽｿｽｿｽｿｽ鼾     */
              *seekpos = stm_checkArea(grp, STM_GRP_FAD(grp));
              if (*seekpos >= 0) {
                  STM_GRP_FAD(grp) = *seekpos;
              }
  
!             *start = TRUE;                      /* ｿｽﾇみ搾ｿｽｿｽﾝゑｿｽｿｽJｿｽnｿｽｿｽｿｽｿｽ   */
              STM_GRP_ACSTAT(grp) = STM_EXEC_DOING;
              *seekpos = -1;
          } else {
!             /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽﾉ呼ばれたｿｽ鼾ｿｽﾈゑｿｽ */
              *seekpos = -1;
!             *start = FALSE;                     /* ｿｽﾇみ搾ｿｽｿｽﾝゑｿｽｿｽJｿｽnｿｽｿｽｿｽﾈゑｿｽ */
          }
      } else if (IS_READING(grp) == TRUE) {
          if (fad <= efad) {
              cdstat = GFCF_GetStat(NULL, NULL);
!             stm_setErr(cdstat);                 /* ｿｽGｿｽｿｽｿｽ[ｿｽRｿｽ[ｿｽhｿｽﾌ設抵ｿｽ   */
!             /* ｿｽﾄ撰ｿｽｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽ鼾   */
              if ((stat == GFS_STAT_NOACT)&&(fad > MNG_EFAD(stm_mng_ptr))) {
!                 /* ｿｽｿｽｿｽｿｽｿｽﾄ撰ｿｽｿｽJｿｽnｿｽｿｽｿｽｿｽｿｽｿｽ           */
                  STM_GRP_FAD(grp) = fad;
!                 /* ｿｽﾄ撰ｿｽｿｽIｿｽｿｽ,ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽ        */
                  STM_GRP_ATR(grp) &= ~(STMGRP_ATR_PLAY|STMGRP_ATR_READ|
                                        STMGRP_ATR_SEEK);
                  *seekpos = -1;
              } else {
!                 /* ｿｽﾇみ搾ｿｽｿｽﾝ抵ｿｽ           */
                  STM_GRP_FAD(grp) = fad;
                  if (IS_SEEKING(grp) == FALSE) {
                      *seekpos = stm_checkArea(grp, fad);
***************
*** 644,658 ****
                      *seekpos = -1;
                  }
              }
!             *start = FALSE;                     /* 読み込みを開始しない */
          } else if (stat == GFS_STAT_NOACT) {
!             /* 読み込み終了             */
              STM_GRP_FAD(grp) = fad;
!             /* 再生終了,読み込み終了    */
              STM_GRP_ATR(grp) &= ~(STMGRP_ATR_PLAY|STMGRP_ATR_READ|
                                    STMGRP_ATR_SEEK);
!             STMSVR_SetReadEnd(grp);     /* 読み込み済みフラグの設定     */
!             /* 常駐ストリームの読込みを終えた時は,stm_transでカウント   */
              if (stmmng_isAllResi(grp) == FALSE) {
                  STM_GRP_LOOPCNT(grp)++;
              }
--- 643,657 ----
                      *seekpos = -1;
                  }
              }
!             *start = FALSE;                     /* ｿｽﾇみ搾ｿｽｿｽﾝゑｿｽｿｽJｿｽnｿｽｿｽｿｽﾈゑｿｽ */
          } else if (stat == GFS_STAT_NOACT) {
!             /* ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽ             */
              STM_GRP_FAD(grp) = fad;
!             /* ｿｽﾄ撰ｿｽｿｽIｿｽｿｽ,ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽ    */
              STM_GRP_ATR(grp) &= ~(STMGRP_ATR_PLAY|STMGRP_ATR_READ|
                                    STMGRP_ATR_SEEK);
!             STMSVR_SetReadEnd(grp);     /* ｿｽﾇみ搾ｿｽｿｽﾝ済みフｿｽｿｽｿｽOｿｽﾌ設抵ｿｽ     */
!             /* ｿｽ駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ読搾ｿｽｿｽﾝゑｿｽｿｽIｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ,stm_transｿｽﾅカｿｽEｿｽｿｽｿｽg   */
              if (stmmng_isAllResi(grp) == FALSE) {
                  STM_GRP_LOOPCNT(grp)++;
              }
***************
*** 663,673 ****
                  ret = TRUE;
              }
          } else {
!             /* 読み込み終了後のビジー状態       */
              *seekpos = -1;
              *start = FALSE;
          }
!     } else {    /* 再生開始後のビジー状態       */
          *seekpos = -1;
          *start = FALSE;
      }
--- 662,672 ----
                  ret = TRUE;
              }
          } else {
!             /* ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽｿｽｿｽｿｽﾌビｿｽWｿｽ[ｿｽｿｽｿｽｿｽ       */
              *seekpos = -1;
              *start = FALSE;
          }
!     } else {    /* ｿｽﾄ撰ｿｽｿｽJｿｽnｿｽｿｽｿｽﾌビｿｽWｿｽ[ｿｽｿｽｿｽｿｽ       */
          *seekpos = -1;
          *start = FALSE;
      }
***************
*** 677,701 ****
  
  
  /*************************************************
!  * 再生コマンドの発行
!  * grp  : ストリームグループ
!  * seekpos : ピックアップの移動先
!  * efad : ストリームグループの最終FAD
!  * start : 再生を開始するかどうか
   *************************************************/
  STM_LOCAL Sint32        stm_putPlayCmd(StmGrpHn grp, Sint32 seekpos,
                                         Sint32 efad, Bool start)
  {
      Sint32      ret = STM_ERR_OK;
  
!     if (seekpos >= 0) {                 /* 次のストリームに移動 */
          ret = STL_MovePlaypos(grp, seekpos);
!         STM_GRP_FAD(grp) = seekpos;             /* 現在のFAD            */
      } else if (STM_GRP_FAD(grp) <= efad) {
!         /* まだ読み込み状態になっていない場合   */
          if ((start == TRUE)&&(IS_PLAYING(grp) == FALSE)) {
!             stm_setReadTrue(grp);               /* 読み込みフラグの設定 */
!             ret = STL_FlowIn(grp);              /* 読み込み開始         */
              if (ret == STM_ERR_OK) {
                  STM_GRP_ATR(grp) |= STMGRP_ATR_PLAY;
              }
--- 676,700 ----
  
  
  /*************************************************
!  * ｿｽﾄ撰ｿｽｿｽRｿｽ}ｿｽｿｽｿｽhｿｽﾌ費ｿｽｿｽs
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * seekpos : ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽﾌ移難ｿｽｿｽｿｽ
!  * efad : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ最終FAD
!  * start : ｿｽﾄ撰ｿｽｿｽｿｽｿｽJｿｽnｿｽｿｽｿｽ驍ｩｿｽﾇゑｿｽｿｽｿｽ
   *************************************************/
  STM_LOCAL Sint32        stm_putPlayCmd(StmGrpHn grp, Sint32 seekpos,
                                         Sint32 efad, Bool start)
  {
      Sint32      ret = STM_ERR_OK;
  
!     if (seekpos >= 0) {                 /* ｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾉ移難ｿｽ */
          ret = STL_MovePlaypos(grp, seekpos);
!         STM_GRP_FAD(grp) = seekpos;             /* ｿｽｿｽｿｽﾝゑｿｽFAD            */
      } else if (STM_GRP_FAD(grp) <= efad) {
!         /* ｿｽﾜゑｿｽｿｽﾇみ搾ｿｽｿｽﾝ擾ｿｽｿｽﾔになゑｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽ鼾   */
          if ((start == TRUE)&&(IS_PLAYING(grp) == FALSE)) {
!             stm_setReadTrue(grp);               /* ｿｽﾇみ搾ｿｽｿｽﾝフｿｽｿｽｿｽOｿｽﾌ設抵ｿｽ */
!             ret = STL_FlowIn(grp);              /* ｿｽﾇみ搾ｿｽｿｽﾝ開ｿｽn         */
              if (ret == STM_ERR_OK) {
                  STM_GRP_ATR(grp) |= STMGRP_ATR_PLAY;
              }
***************
*** 707,718 ****
  
  
  /*************************************************
!  * ストリーム読み込み
!  * grp  : 再生ストリームグループ
!  * fad  : 現在のFAD
!  * efad : ストリームグループの最終FAD
!  * stat : CDブロックの状態
!  * 戻り値 : TRUE 読み込み終了    FALSE 読み込み中
   *************************************************/
  STM_LOCAL Bool  stm_read(StmGrpHn grp, Sint32 fad, Sint32 efad, Sint32 stat)
  {
--- 706,717 ----
  
  
  /*************************************************
!  * ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾇみ搾ｿｽｿｽｿｽ
!  * grp  : ｿｽﾄ撰ｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * fad  : ｿｽｿｽｿｽﾝゑｿｽFAD
!  * efad : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ最終FAD
!  * stat : CDｿｽuｿｽｿｽｿｽbｿｽNｿｽﾌ擾ｿｽｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽ    FALSE ｿｽﾇみ搾ｿｽｿｽﾝ抵ｿｽ
   *************************************************/
  STM_LOCAL Bool  stm_read(StmGrpHn grp, Sint32 fad, Sint32 efad, Sint32 stat)
  {
***************
*** 721,729 ****
      Bool        ret;
      Sint32      err;
  
!     /* 全ての読み込みを終了した場合                     */
      if (stmmng_isAllResi(grp) == TRUE) {
!         /* 全て常駐ストリームの場合、転送のみ実行する   */
          if (((STM_GRP_ACSTAT(grp) == STM_EXEC_PAUSE)||
              ((STM_GRP_ATR(grp) & STMGRP_ATR_ALRSTREND) != 0))&&
              (STM_GRP_SFADLST(grp) != NULL)&&
--- 720,728 ----
      Bool        ret;
      Sint32      err;
  
!     /* ｿｽSｿｽﾄの読み搾ｿｽｿｽﾝゑｿｽｿｽIｿｽｿｽｿｽｿｽｿｽｿｽｿｽ鼾                     */
      if (stmmng_isAllResi(grp) == TRUE) {
!         /* ｿｽSｿｽﾄ常駐ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ場合ｿｽAｿｽ]ｿｽｿｽｿｽﾌみ趣ｿｽｿｽsｿｽｿｽｿｽｿｽ   */
          if (((STM_GRP_ACSTAT(grp) == STM_EXEC_PAUSE)||
              ((STM_GRP_ATR(grp) & STMGRP_ATR_ALRSTREND) != 0))&&
              (STM_GRP_SFADLST(grp) != NULL)&&
***************
*** 737,746 ****
          return (TRUE);
      }
  
!     /* 再生パラメータの取得                             */
      ret = stm_getReadParam(grp, fad, efad, stat, &seekpos, &start);
  
!     /* 再生コマンドの発行                               */
      err = stm_putPlayCmd(grp, seekpos, efad, start);
      if (err != STM_ERR_OK) {
          STMERR_SetCode(err);
--- 736,745 ----
          return (TRUE);
      }
  
!     /* ｿｽﾄ撰ｿｽｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽﾌ取得                             */
      ret = stm_getReadParam(grp, fad, efad, stat, &seekpos, &start);
  
!     /* ｿｽﾄ撰ｿｽｿｽRｿｽ}ｿｽｿｽｿｽhｿｽﾌ費ｿｽｿｽs                               */
      err = stm_putPlayCmd(grp, seekpos, efad, start);
      if (err != STM_ERR_OK) {
          STMERR_SetCode(err);
***************
*** 751,767 ****
  
  
  /*************************************************
!  * CDバッファ内セクタ数の取得(5.1)
!  * stm  : ストリームハンドル
!  * 戻り値: CDバッファ内のセクタ数
   *************************************************/
  Sint32  STMSVR_GetNumCdbuf(StmHn stm)
  {
      Sint32      nsct;
      Sint32      ret;
!     
      if (STM_IS_CDFILE(stm)) {
!         ret = GFCD_GetLenData(GFS_CDR_BUFNO(STM_DTSRC(stm)), 0, 
                                STM_LONG_MAX, &nsct, NULL);
          if (ret != GFCD_ERR_OK) {
              STM_SetGfcdErr(ret);
--- 750,766 ----
  
  
  /*************************************************
!  * CDｿｽoｿｽbｿｽtｿｽ@ｿｽｿｽｿｽZｿｽNｿｽ^ｿｽｿｽｿｽﾌ取得(5.1)
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl: CDｿｽoｿｽbｿｽtｿｽ@ｿｽｿｽｿｽﾌセｿｽNｿｽ^ｿｽｿｽ
   *************************************************/
  Sint32  STMSVR_GetNumCdbuf(StmHn stm)
  {
      Sint32      nsct;
      Sint32      ret;
! 
      if (STM_IS_CDFILE(stm)) {
!         ret = GFCD_GetLenData(GFS_CDR_BUFNO(STM_DTSRC(stm)), 0,
                                STM_LONG_MAX, &nsct, NULL);
          if (ret != GFCD_ERR_OK) {
              STM_SetGfcdErr(ret);
***************
*** 783,789 ****
  {
      Sint32      nsct;
      Sint32      ret;
!     
      STMERR_SetFunc(STM_GETNUMCDBUF);
      if (stm == NULL) {
          STMERR_SetCode(STM_ERR_HNDL);
--- 782,788 ----
  {
      Sint32      nsct;
      Sint32      ret;
! 
      STMERR_SetFunc(STM_GETNUMCDBUF);
      if (stm == NULL) {
          STMERR_SetCode(STM_ERR_HNDL);
***************
*** 801,815 ****
  
  
  /*************************************************
!  * ストリーム状態の取得
!  * stm  : ストリームハンドル
!  * sfad : ストリームの開始FAD
!  * efad : ストリームの終了FAD
!  * nsct : CDバッファのセクタ数
!  * 戻り値: STAT_NOREAD          アクセスされない
!  *         STAT_DOING           処理中
!  *         STAT_WAIT            転送待ち(ゲート閉, 領域フル)
!  *         STAT_COMPLETED       アクセス完了
   *************************************************/
  STM_LOCAL Sint32        stm_getStat(StmHn stm, Sint32 sfad, Sint32 efad, Sint32 nsct)
  {
--- 800,814 ----
  
  
  /*************************************************
!  * ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾔの取得
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * sfad : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ開ｿｽnFAD
!  * efad : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ終ｿｽｿｽFAD
!  * nsct : CDｿｽoｿｽbｿｽtｿｽ@ｿｽﾌセｿｽNｿｽ^ｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl: STAT_NOREAD          ｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ
!  *         STAT_DOING           ｿｽｿｽｿｽｿｽｿｽｿｽ
!  *         STAT_WAIT            ｿｽ]ｿｽｿｽｿｽﾒゑｿｽ(ｿｽQｿｽ[ｿｽgｿｽｿｽ, ｿｽﾌ茨ｿｽｿｽtｿｽｿｽ)
!  *         STAT_COMPLETED       ｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽｿｽ
   *************************************************/
  STM_LOCAL Sint32        stm_getStat(StmHn stm, Sint32 sfad, Sint32 efad, Sint32 nsct)
  {
***************
*** 820,867 ****
  
      fad = STM_GRP_FAD(STM_GRPHN(stm));
      if ((IS_STM_READEND(stm) == TRUE)&&(nsct == 0)) {
!         /* アクセスが完了したストリーム */
          return (STAT_COMPLETED);
      }
!     if ((fad <= efad)&&(STM_IS_CDFILE(stm))) {          /* 読み込み中   */
          if ((IS_STM_READ(stm) == TRUE)||
              (IS_STM_LOOPNOREAD(stm) == FALSE)) {
              stat = GFCF_GetStat(NULL, &hirq);
!             stm_setErr(stat);                   /* エラーコードの設定   */
              if ((hirq & CDC_HIRQ_BFUL) == 0) {
!                 /* CDバッファに空き領域あり     */
                  return (STAT_DOING);
!             } else if (nsct == 0) {     /* CDバッファのデータは全て他の */
!                 return (STAT_WAIT);     /* ストリームのデータ           */
              }
          } else {
              return (STAT_NOREAD);
          }
      } else if ((IS_STM_READ(stm) == TRUE)&&(nsct == 0)) {
!         /* 読み込み完了後,CDバッファにデータがない      */
!         return (STAT_COMPLETED);        /* 転送完了                     */
      }
      if (STM_TRFAD(stm) == STM_FAD_CDEND) {
          trfad = STMMNG_GetLstFad(STM_GRPHN(stm));
      } else {
          trfad = STM_TRFAD(stm);
      }
!     /* 転送ゲートが閉じている,転送FAD未満,バッファフル  */
      if ((!GFS_TRN_ACTIVE(&(GFS_FILE_TRANS(STM_GFS(stm)))))||
          ((fad >= sfad)&&(fad < trfad))||
          (STMTRN_IsTrBufFull(stm) == TRUE)) {
          return (STAT_WAIT);
      }
!     return (STAT_DOING);                        /* 転送中               */
  }
  
  
  
  /*************************************************
!  * ストリームデータの転送
!  * stm  : ストリームハンドル
!  * 戻り値 : TRUE  転送した
!  *          FALSE 転送できなかった
   *************************************************/
  STM_LOCAL Bool  stmsvr_execTrans(StmHn stm)
  {
--- 819,866 ----
  
      fad = STM_GRP_FAD(STM_GRPHN(stm));
      if ((IS_STM_READEND(stm) == TRUE)&&(nsct == 0)) {
!         /* ｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽ */
          return (STAT_COMPLETED);
      }
!     if ((fad <= efad)&&(STM_IS_CDFILE(stm))) {          /* ｿｽﾇみ搾ｿｽｿｽﾝ抵ｿｽ   */
          if ((IS_STM_READ(stm) == TRUE)||
              (IS_STM_LOOPNOREAD(stm) == FALSE)) {
              stat = GFCF_GetStat(NULL, &hirq);
!             stm_setErr(stat);                   /* ｿｽGｿｽｿｽｿｽ[ｿｽRｿｽ[ｿｽhｿｽﾌ設抵ｿｽ   */
              if ((hirq & CDC_HIRQ_BFUL) == 0) {
!                 /* CDｿｽoｿｽbｿｽtｿｽ@ｿｽﾉ空き領域あｿｽｿｽ     */
                  return (STAT_DOING);
!             } else if (nsct == 0) {     /* CDｿｽoｿｽbｿｽtｿｽ@ｿｽﾌデｿｽ[ｿｽ^ｿｽﾍ全ｿｽﾄ托ｿｽｿｽｿｽ */
!                 return (STAT_WAIT);     /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌデｿｽ[ｿｽ^           */
              }
          } else {
              return (STAT_NOREAD);
          }
      } else if ((IS_STM_READ(stm) == TRUE)&&(nsct == 0)) {
!         /* ｿｽﾇみ搾ｿｽｿｽﾝ奇ｿｽｿｽｿｽｿｽｿｽ,CDｿｽoｿｽbｿｽtｿｽ@ｿｽﾉデｿｽ[ｿｽ^ｿｽｿｽｿｽﾈゑｿｽ      */
!         return (STAT_COMPLETED);        /* ｿｽ]ｿｽｿｽｿｽｿｽｿｽｿｽ                     */
      }
      if (STM_TRFAD(stm) == STM_FAD_CDEND) {
          trfad = STMMNG_GetLstFad(STM_GRPHN(stm));
      } else {
          trfad = STM_TRFAD(stm);
      }
!     /* ｿｽ]ｿｽｿｽｿｽQｿｽ[ｿｽgｿｽｿｽｿｽﾂゑｿｽｿｽﾄゑｿｽｿｽｿｽ,ｿｽ]ｿｽｿｽFADｿｽｿｽｿｽｿｽ,ｿｽoｿｽbｿｽtｿｽ@ｿｽtｿｽｿｽ  */
      if ((!GFS_TRN_ACTIVE(&(GFS_FILE_TRANS(STM_GFS(stm)))))||
          ((fad >= sfad)&&(fad < trfad))||
          (STMTRN_IsTrBufFull(stm) == TRUE)) {
          return (STAT_WAIT);
      }
!     return (STAT_DOING);                        /* ｿｽ]ｿｽｿｽｿｽｿｽ               */
  }
  
  
  
  /*************************************************
!  * ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽﾌ転ｿｽｿｽ
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE  ｿｽ]ｿｽｿｽｿｽｿｽｿｽｿｽ
!  *          FALSE ｿｽ]ｿｽｿｽｿｽﾅゑｿｽｿｽﾈゑｿｽｿｽｿｽｿｽｿｽ
   *************************************************/
  STM_LOCAL Bool  stmsvr_execTrans(StmHn stm)
  {
***************
*** 882,889 ****
  
  
  /*************************************************
!  * バッファサイズ監視関数の実行
!  * grp  : ストリームグループハンドル
   *************************************************/
  STM_LOCAL void  stm_execCdbufFunc(StmGrpHn grp)
  {
--- 881,888 ----
  
  
  /*************************************************
!  * ｿｽoｿｽbｿｽtｿｽ@ｿｽTｿｽCｿｽYｿｽﾄ趣ｿｽｿｽﾖ撰ｿｽｿｽﾌ趣ｿｽｿｽs
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  STM_LOCAL void  stm_execCdbufFunc(StmGrpHn grp)
  {
***************
*** 894,911 ****
          STM_GRP_ATR(grp) &= ~STMGRP_ATR_CHKBUF;
      }
  }
!     
  
  /*************************************************
!  * データの転送
!  * grp  : ストリームグループ
!  * first : 最初に転送したストリーム
!  * cdstat : CDのステータス
!  * bflag  : 次のストリームの転送を行なわない場合  TRUE
!  * stat   : 次に転送するストリームのステータス
!  * 戻り値 : 全ストリームの転送を完了した場合 TRUE
   *************************************************/
! STM_LOCAL Bool  stm_trans_sub(StmGrpHn grp, StmHn first, Uint8 cdstat, 
                                                  Bool *bflag, Sint32 *stat)
  {
      Sint32      i;
--- 893,910 ----
          STM_GRP_ATR(grp) &= ~STMGRP_ATR_CHKBUF;
      }
  }
! 
  
  /*************************************************
!  * ｿｽfｿｽ[ｿｽ^ｿｽﾌ転ｿｽｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * first : ｿｽﾅ擾ｿｽｿｽﾉ転ｿｽｿｽｿｽｿｽｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽ
!  * cdstat : CDｿｽﾌスｿｽeｿｽ[ｿｽ^ｿｽX
!  * bflag  : ｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ転ｿｽｿｽｿｽｿｽｿｽsｿｽﾈゑｿｽｿｽﾈゑｿｽｿｽ鼾  TRUE
!  * stat   : ｿｽｿｽｿｽﾉ転ｿｽｿｽｿｽｿｽｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌスｿｽeｿｽ[ｿｽ^ｿｽX
!  * ｿｽﾟゑｿｽｿｽl : ｿｽSｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ転ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ鼾 TRUE
   *************************************************/
! STM_LOCAL Bool  stm_trans_sub(StmGrpHn grp, StmHn first, Uint8 cdstat,
                                                  Bool *bflag, Sint32 *stat)
  {
      Sint32      i;
***************
*** 913,925 ****
      Sint32      nsct;
      Sint32      sfad, efad;
      Sint32      trfad;
!     Bool        req;
      Bool        complete = TRUE;
      Bool        set = FALSE;
      Uint8       atr;
  
      *bflag = FALSE;
!     stm = STM_GRP_NEXTTRNS(grp);                /* 転送ストリーム       */
      if (STM_IS_CDFILE(stm)) {
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
      } else {
--- 912,924 ----
      Sint32      nsct;
      Sint32      sfad, efad;
      Sint32      trfad;
! //    Bool        req;
      Bool        complete = TRUE;
      Bool        set = FALSE;
      Uint8       atr;
  
      *bflag = FALSE;
!     stm = STM_GRP_NEXTTRNS(grp);                /* ｿｽ]ｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽ       */
      if (STM_IS_CDFILE(stm)) {
          STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
      } else {
***************
*** 940,966 ****
          STM_ATR(stm) |= STM_ATR_TREND;
      }
      if (((atr & STM_ATR_TREND) == 0)&&((STM_ATR(stm) & STM_ATR_TREND) != 0)) {
!         /* 再生範囲を越えたらCDバッファにある分だけを転送する   */
          nsct = GFBF_GetNumData(STM_GFS(stm));
          GFTR_SetTransPara(&(GFS_FILE_TRANS(STM_GFS(stm))), nsct);
      } else if (((atr & STM_ATR_TRSTART) == 0)&&
                 ((STM_ATR(stm) & STM_ATR_TRSTART) != 0)) {
!         /* 再生範囲になったらすべてのデータを転送する           */
          GFTR_SetTransPara(&(GFS_FILE_TRANS(STM_GFS(stm))), STM_LONG_MAX);
      }
!     stmsvr_execTrans(stm);                      /* 転送実行             */
      if (stmsvr_isTrans(stm) == TRUE) {
!         /* 転送中の場合         */
          *bflag = TRUE;
          *stat = stm_getStat(stm, sfad, efad, 1);
!                                                 /* 転送中はデータがある */
          return (FALSE);
      }
!     /* 次の転送ストリームの設定         */
      _stm = stm;
      for (i = 0; (i < 2)&&(set != TRUE); i++) {
          for (stm = STM_SFADLST(stm); ; stm = STM_SFADLST(stm)) {
!             /* 最後なら先頭に戻す       */
              if (stm == NULL) {
                  stm = STM_GRP_SFADLST(grp);
              }
--- 939,965 ----
          STM_ATR(stm) |= STM_ATR_TREND;
      }
      if (((atr & STM_ATR_TREND) == 0)&&((STM_ATR(stm) & STM_ATR_TREND) != 0)) {
!         /* ｿｽﾄ撰ｿｽｿｽﾍ囲ゑｿｽｿｽzｿｽｿｽｿｽｿｽｿｽｿｽCDｿｽoｿｽbｿｽtｿｽ@ｿｽﾉゑｿｽｿｽ髟ｪｿｽｿｽｿｽｿｽｿｽｿｽｿｽ]ｿｽｿｽｿｽｿｽｿｽｿｽ   */
          nsct = GFBF_GetNumData(STM_GFS(stm));
          GFTR_SetTransPara(&(GFS_FILE_TRANS(STM_GFS(stm))), nsct);
      } else if (((atr & STM_ATR_TRSTART) == 0)&&
                 ((STM_ATR(stm) & STM_ATR_TRSTART) != 0)) {
!         /* ｿｽﾄ撰ｿｽｿｽﾍ囲になゑｿｽｿｽｿｽｿｽ轤ｷｿｽﾗてのデｿｽ[ｿｽ^ｿｽｿｽｿｽ]ｿｽｿｽｿｽｿｽｿｽｿｽ           */
          GFTR_SetTransPara(&(GFS_FILE_TRANS(STM_GFS(stm))), STM_LONG_MAX);
      }
!     stmsvr_execTrans(stm);                      /* ｿｽ]ｿｽｿｽｿｽｿｽｿｽs             */
      if (stmsvr_isTrans(stm) == TRUE) {
!         /* ｿｽ]ｿｽｿｽｿｽｿｽｿｽﾌ場合         */
          *bflag = TRUE;
          *stat = stm_getStat(stm, sfad, efad, 1);
!                                                 /* ｿｽ]ｿｽｿｽｿｽｿｽｿｽﾍデｿｽ[ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽ */
          return (FALSE);
      }
!     /* ｿｽｿｽｿｽﾌ転ｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ設抵ｿｽ         */
      _stm = stm;
      for (i = 0; (i < 2)&&(set != TRUE); i++) {
          for (stm = STM_SFADLST(stm); ; stm = STM_SFADLST(stm)) {
!             /* ｿｽﾅ鯉ｿｽｿｽﾈゑｿｽｿｽ謫ｪｿｽﾉ戻ゑｿｽ       */
              if (stm == NULL) {
                  stm = STM_GRP_SFADLST(grp);
              }
***************
*** 974,981 ****
                  sfad = efad = STM_FAD_CDTOP;
              }
              *stat = stm_getStat(stm, sfad, efad, nsct);
!             /* 1回目はアクセス中のストリームを探す      */
!             /* 2回目は転送待ちのストリームを探す        */
              if (((nsct > 0)||(cdstat == GFS_STAT_SEEK)||
                   (cdstat == GFS_STAT_READ))&&
                  (((i == 0)&&(*stat == STAT_DOING))||
--- 973,980 ----
                  sfad = efad = STM_FAD_CDTOP;
              }
              *stat = stm_getStat(stm, sfad, efad, nsct);
!             /* 1ｿｽｿｽｿｽﾚはアｿｽNｿｽZｿｽXｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽTｿｽｿｽ      */
!             /* 2ｿｽｿｽｿｽﾚは転ｿｽｿｽｿｽﾒゑｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽTｿｽｿｽ        */
              if (((nsct > 0)||(cdstat == GFS_STAT_SEEK)||
                   (cdstat == GFS_STAT_READ))&&
                  (((i == 0)&&(*stat == STAT_DOING))||
***************
*** 1001,1008 ****
  
  
  /*************************************************
!  * アクセスポインタの初期化
!  * grp  : ストリームグループハンドル
   *************************************************/
  STM_LOCAL void  stm_resetAcp(StmGrpHn grp)
  {
--- 1000,1007 ----
  
  
  /*************************************************
!  * ｿｽAｿｽNｿｽZｿｽXｿｽ|ｿｽCｿｽｿｽｿｽ^ｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽnｿｽｿｽｿｽhｿｽｿｽ
   *************************************************/
  STM_LOCAL void  stm_resetAcp(StmGrpHn grp)
  {
***************
*** 1015,1050 ****
  
  
  /*************************************************
!  * データの転送
!  * grp  : ストリームグループ
!  * cdstat : CDのステータス
!  * 戻り値 : TRUE 転送終了  FALSE 転送中
   *************************************************/
  STM_LOCAL Bool  stm_trans(StmGrpHn grp, Uint8 cdstat)
  {
!     StmHn       stm, first;
      Sint32      stat;
      Bool        bflag;
      Bool        ret;
  
!     /* 転送ストリームが未設定の場合             */
      if (STM_GRP_NEXTTRNS(grp) == NULL) {
          STM_GRP_NEXTTRNS(grp) = STM_GRP_SFADLST(grp);
      }
      first = STM_GRP_NEXTTRNS(grp);
  
!     /* 各ストリームを１度づつ実行を試みる       */
!     /* 転送中または１周まわったらおわり         */
      do {
          stm = STM_GRP_NEXTTRNS(grp);
          ret = stm_trans_sub(grp, first, cdstat, &bflag, &stat);
      } while(bflag == FALSE);
  
!     /* WAIT <-> DOINGの移行     */
      if ((stat == STM_EXEC_WAIT)||(STM_GRP_ACSTAT(grp) == STM_EXEC_WAIT)) {
          STM_GRP_ACSTAT(grp) = stat;
      } else if (stmmng_isAllResi(grp) == TRUE) {
!         /* 常駐のみの場合全ての転送が終了したらループしたことにする     */
          if (STM_GRP_LOOPCNT(grp) < STM_GRP_LOOPMAX(grp)) {
              if (stat == STM_EXEC_COMPLETED) {
                  STM_GRP_LOOPCNT(grp)++;
--- 1014,1051 ----
  
  
  /*************************************************
!  * ｿｽfｿｽ[ｿｽ^ｿｽﾌ転ｿｽｿｽ
!  * grp  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽv
!  * cdstat : CDｿｽﾌスｿｽeｿｽ[ｿｽ^ｿｽX
!  * ｿｽﾟゑｿｽｿｽl : TRUE ｿｽ]ｿｽｿｽｿｽIｿｽｿｽ  FALSE ｿｽ]ｿｽｿｽｿｽｿｽ
   *************************************************/
  STM_LOCAL Bool  stm_trans(StmGrpHn grp, Uint8 cdstat)
  {
!     StmHn       stm;
!     StmHn	first;
      Sint32      stat;
      Bool        bflag;
      Bool        ret;
  
!     (void)stm;
!     /* ｿｽ]ｿｽｿｽｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾝ抵ｿｽｿｽﾌ場合             */
      if (STM_GRP_NEXTTRNS(grp) == NULL) {
          STM_GRP_NEXTTRNS(grp) = STM_GRP_SFADLST(grp);
      }
      first = STM_GRP_NEXTTRNS(grp);
  
!     /* ｿｽeｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽPｿｽxｿｽﾃつ趣ｿｽｿｽsｿｽｿｽｿｽｿｽｿｽﾝゑｿｽ       */
!     /* ｿｽ]ｿｽｿｽｿｽｿｽｿｽﾜゑｿｽｿｽﾍ１ｿｽｿｽｿｽﾜゑｿｽｿｽｿｽｿｽｿｽｿｽ轤ｨｿｽｿｽｿｽｿｽ         */
      do {
          stm = STM_GRP_NEXTTRNS(grp);
          ret = stm_trans_sub(grp, first, cdstat, &bflag, &stat);
      } while(bflag == FALSE);
  
!     /* WAIT <-> DOINGｿｽﾌ移行     */
      if ((stat == STM_EXEC_WAIT)||(STM_GRP_ACSTAT(grp) == STM_EXEC_WAIT)) {
          STM_GRP_ACSTAT(grp) = stat;
      } else if (stmmng_isAllResi(grp) == TRUE) {
!         /* ｿｽ駐ｿｽﾌみの場合ｿｽSｿｽﾄの転ｿｽｿｽｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽｿｽｿｽ辜具ｿｽ[ｿｽvｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾆにゑｿｽｿｽｿｽ     */
          if (STM_GRP_LOOPCNT(grp) < STM_GRP_LOOPMAX(grp)) {
              if (stat == STM_EXEC_COMPLETED) {
                  STM_GRP_LOOPCNT(grp)++;
***************
*** 1060,1073 ****
      return (ret);
  }
  
!     
  
  /*************************************************
!  * サーバの実行(7.3)
!  * 戻り値: STM_EXEC_COMPLETED   アクセス終了
!  *         STM_EXEC_PAUSE       一時停止
!  *         STM_EXEC_DOING       アクセス中
!  *         STM_EXEC_WAIT        転送待ち状態
   *************************************************/
  Sint32  STM_ExecServer(void)
  {
--- 1061,1074 ----
      return (ret);
  }
  
! 
  
  /*************************************************
!  * ｿｽTｿｽ[ｿｽoｿｽﾌ趣ｿｽｿｽs(7.3)
!  * ｿｽﾟゑｿｽｿｽl: STM_EXEC_COMPLETED   ｿｽAｿｽNｿｽZｿｽXｿｽIｿｽｿｽ
!  *         STM_EXEC_PAUSE       ｿｽ齊橸ｿｽｿｽｿｽ~
!  *         STM_EXEC_DOING       ｿｽAｿｽNｿｽZｿｽXｿｽｿｽ
!  *         STM_EXEC_WAIT        ｿｽ]ｿｽｿｽｿｽﾒゑｿｽｿｽｿｽｿｽｿｽ
   *************************************************/
  Sint32  STM_ExecServer(void)
  {
***************
*** 1076,1085 ****
      Sint32      ret;
      Bool        read, trans;
      Bool        complete;
!     Sint32      hirq;
      Sint32      stat;
  
!     /* 処理中のタスクがある場合 */
      if (CMD_FUNC(&stm_cmd_area) != CMD_NULLFUNC) {
          complete = CMD_FUNC(&stm_cmd_area)(CMD_OBJ(&stm_cmd_area));
          if (complete == TRUE) {
--- 1077,1086 ----
      Sint32      ret;
      Bool        read, trans;
      Bool        complete;
! //    Sint32      hirq;
      Sint32      stat;
  
!     /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌタｿｽXｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽ鼾 */
      if (CMD_FUNC(&stm_cmd_area) != CMD_NULLFUNC) {
          complete = CMD_FUNC(&stm_cmd_area)(CMD_OBJ(&stm_cmd_area));
          if (complete == TRUE) {
***************
*** 1089,1105 ****
          return (STM_ERR_WHERE(&MNG_ERR(stm_mng_ptr)));
      }
  
!     /* ストリームアクセス       */
      STMERR_SetFunc(STM_EXECSERVER);
      grp = MNG_CURGRP(stm_mng_ptr);
!     /* 処理中のストリームがある場合     */
      if ((grp != NULL)&&(STM_GRP_SFADLST(grp) != NULL)) {
          if (MNG_SVREXEC(stm_mng_ptr) == FALSE) {
              MNG_SVREXEC(stm_mng_ptr) = TRUE;
!             /* SCU-DMA使用中の場合には転送終了チェックをおこなう        */
              if (gfs_use_scudma == TRUE) {
                  GFTR_ExecSvr(STM_GFS(STM_GRP_NEXTTRNS(grp)), &trans);
!                 /* A-Busアクセス不可のため以降の処理はおこなわない      */
                  if (gfs_use_scudma == TRUE) {
                      MNG_SVREXEC(stm_mng_ptr) = FALSE;
                      stat = STMERR_CheckFatalErr();
--- 1090,1106 ----
          return (STM_ERR_WHERE(&MNG_ERR(stm_mng_ptr)));
      }
  
!     /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽAｿｽNｿｽZｿｽX       */
      STMERR_SetFunc(STM_EXECSERVER);
      grp = MNG_CURGRP(stm_mng_ptr);
!     /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ鼾     */
      if ((grp != NULL)&&(STM_GRP_SFADLST(grp) != NULL)) {
          if (MNG_SVREXEC(stm_mng_ptr) == FALSE) {
              MNG_SVREXEC(stm_mng_ptr) = TRUE;
!             /* SCU-DMAｿｽgｿｽpｿｽｿｽｿｽﾌ場合ｿｽﾉは転ｿｽｿｽｿｽIｿｽｿｽｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ        */
              if (gfs_use_scudma == TRUE) {
                  GFTR_ExecSvr(STM_GFS(STM_GRP_NEXTTRNS(grp)), &trans);
!                 /* A-BusｿｽAｿｽNｿｽZｿｽXｿｽsｿｽﾂのゑｿｽｿｽﾟ以降ｿｽﾌ擾ｿｽｿｽｿｽｿｽﾍゑｿｽｿｽｿｽｿｽﾈゑｿｽｿｽﾈゑｿｽ      */
                  if (gfs_use_scudma == TRUE) {
                      MNG_SVREXEC(stm_mng_ptr) = FALSE;
                      stat = STMERR_CheckFatalErr();
***************
*** 1109,1125 ****
                      return STM_GRP_ACSTAT(grp);
                  }
              }
!             /* ストリームアクセス処理   */
!             stm_execCdbufFunc(grp);     /* バッファサイズ監視関数の実行 */
!             stat = GFCF_GetStat(&fad, NULL);    /* 現在のFAD取得        */
!             stm_setErr(stat);                   /* エラーコードの設定   */
              if (IS_SET_ERRCODE(stm_mng_ptr) == TRUE) {
                  STMERR_Exec();
              } else {
!                 efad = STMMNG_GetLstFad(grp);   /* 最終FADの取得        */
                  read = stm_read(grp, fad, efad, stat);
!                                                 /* ストリームの読み込み */
!                 trans = stm_trans(grp, stat);   /* ストリームの転送     */
                  if ((read == TRUE)&&(trans == TRUE)) {
                      STM_GRP_ACSTAT(grp) = STM_EXEC_COMPLETED;
                      stm_resetAcp(grp);
--- 1110,1126 ----
                      return STM_GRP_ACSTAT(grp);
                  }
              }
!             /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽｿｽ   */
!             stm_execCdbufFunc(grp);     /* ｿｽoｿｽbｿｽtｿｽ@ｿｽTｿｽCｿｽYｿｽﾄ趣ｿｽｿｽﾖ撰ｿｽｿｽﾌ趣ｿｽｿｽs */
!             stat = GFCF_GetStat(&fad, NULL);    /* ｿｽｿｽｿｽﾝゑｿｽFADｿｽ謫ｾ        */
!             stm_setErr(stat);                   /* ｿｽGｿｽｿｽｿｽ[ｿｽRｿｽ[ｿｽhｿｽﾌ設抵ｿｽ   */
              if (IS_SET_ERRCODE(stm_mng_ptr) == TRUE) {
                  STMERR_Exec();
              } else {
!                 efad = STMMNG_GetLstFad(grp);   /* ｿｽﾅ終FADｿｽﾌ取得        */
                  read = stm_read(grp, fad, efad, stat);
!                                                 /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ読み搾ｿｽｿｽｿｽ */
!                 trans = stm_trans(grp, stat);   /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ転ｿｽｿｽ     */
                  if ((read == TRUE)&&(trans == TRUE)) {
                      STM_GRP_ACSTAT(grp) = STM_EXEC_COMPLETED;
                      stm_resetAcp(grp);
***************
*** 1133,1139 ****
          } else {
              ret = STM_GRP_ACSTAT(grp);
          }
!     } else {                            /* 処理中のストリームがない場合 */
          ret = STM_EXEC_PAUSE;
      }
      return ret;
--- 1134,1140 ----
          } else {
              ret = STM_GRP_ACSTAT(grp);
          }
!     } else {                            /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌスｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽ鼾 */
          ret = STM_EXEC_PAUSE;
      }
      return ret;
***************
*** 1142,1150 ****
  
  
  /*************************************************
!  * ピックアップの移動(7.4)
!  * stm  : ストリームハンドル
!  * off  : ストリーム先頭からのオフセット
   *************************************************/
  void    STM_MovePickup(StmHn stm, Sint32 off)
  {
--- 1143,1151 ----
  
  
  /*************************************************
!  * ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽﾌ移難ｿｽ(7.4)
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * off  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽ謫ｪｿｽｿｽｿｽｿｽｿｽﾌオｿｽtｿｽZｿｽbｿｽg
   *************************************************/
  void    STM_MovePickup(StmHn stm, Sint32 off)
  {
***************
*** 1161,1190 ****
      }
      stm = STM_ALIAS(stm);
      grp = STM_GRPHN(stm);
!     if (MNG_CURGRP(stm_mng_ptr) == grp) {       /* 処理中グループの場合 */
          if (IS_PLAYING(grp) == TRUE) {
!             ret = STL_StopIn(STM_GRPHN(stm));   /* 読み込み停止         */
              if (ret != STM_ERR_OK) {
                  STMERR_SetCode(ret);
              }
!             STM_GRP_ACSTAT(grp) = STM_EXEC_PAUSE; /* 次回サーバにて移動 */
          }
!         stat = GFCF_GetStat(&sfad, NULL);       /* 現在のFADを取得      */
!         stm_setErr(stat);                       /* エラーコードの設定   */
          if (IS_SET_ERRCODE(stm_mng_ptr) == TRUE) {
              STMERR_Exec();
              return;
          }
          if (sfad >= 0) {
!             STM_GRP_FAD(grp) = sfad;            /* 現在位置を設定       */
          }
!         /* 再生終了,読み込み終了        */
          STM_GRP_ATR(grp) &= ~(STMGRP_ATR_PLAY|STMGRP_ATR_READ|STMGRP_ATR_SEEK);
      }
!     STMSVR_SetReadEnd(grp);     /* 読み込み済みフラグの設定             */
!     stm_setReadFalse(grp);      /* 読み込み位置以降のフラグをFALSEに設定  */
  
!     /* 移動先FADを取得  */
      STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
  
      STM_GRP_FAD(grp) = sfad + off;
--- 1162,1191 ----
      }
      stm = STM_ALIAS(stm);
      grp = STM_GRPHN(stm);
!     if (MNG_CURGRP(stm_mng_ptr) == grp) {       /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌ場合 */
          if (IS_PLAYING(grp) == TRUE) {
!             ret = STL_StopIn(STM_GRPHN(stm));   /* ｿｽﾇみ搾ｿｽｿｽﾝ抵ｿｽｿｽ~         */
              if (ret != STM_ERR_OK) {
                  STMERR_SetCode(ret);
              }
!             STM_GRP_ACSTAT(grp) = STM_EXEC_PAUSE; /* ｿｽｿｽｿｽｿｽｿｽTｿｽ[ｿｽoｿｽﾉて移難ｿｽ */
          }
!         stat = GFCF_GetStat(&sfad, NULL);       /* ｿｽｿｽｿｽﾝゑｿｽFADｿｽｿｽｿｽ謫ｾ      */
!         stm_setErr(stat);                       /* ｿｽGｿｽｿｽｿｽ[ｿｽRｿｽ[ｿｽhｿｽﾌ設抵ｿｽ   */
          if (IS_SET_ERRCODE(stm_mng_ptr) == TRUE) {
              STMERR_Exec();
              return;
          }
          if (sfad >= 0) {
!             STM_GRP_FAD(grp) = sfad;            /* ｿｽｿｽｿｽﾝ位置ｿｽｿｽｿｽﾝ抵ｿｽ       */
          }
!         /* ｿｽﾄ撰ｿｽｿｽIｿｽｿｽ,ｿｽﾇみ搾ｿｽｿｽﾝ終ｿｽｿｽ        */
          STM_GRP_ATR(grp) &= ~(STMGRP_ATR_PLAY|STMGRP_ATR_READ|STMGRP_ATR_SEEK);
      }
!     STMSVR_SetReadEnd(grp);     /* ｿｽﾇみ搾ｿｽｿｽﾝ済みフｿｽｿｽｿｽOｿｽﾌ設抵ｿｽ             */
!     stm_setReadFalse(grp);      /* ｿｽﾇみ搾ｿｽｿｽﾝ位置ｿｽﾈ降ｿｽﾌフｿｽｿｽｿｽOｿｽｿｽFALSEｿｽﾉ設抵ｿｽ  */
  
!     /* ｿｽﾚ難ｿｽｿｽｿｽFADｿｽｿｽｿｽ謫ｾ  */
      STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
  
      STM_GRP_FAD(grp) = sfad + off;
***************
*** 1193,1201 ****
  
  
  /*************************************************
!  * リードエラー発生時のリカバリ(9.3)
!  * 戻り値 : STM_ERR_CDRD  リカバリ失敗
!  *          STM_ERR_OK    リカバリ成功
   *************************************************/
  Sint32  STM_Recover(void)
  {
--- 1194,1202 ----
  
  
  /*************************************************
!  * ｿｽｿｽｿｽ[ｿｽhｿｽGｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌｿｽｿｽJｿｽoｿｽｿｽ(9.3)
!  * ｿｽﾟゑｿｽｿｽl : STM_ERR_CDRD  ｿｽｿｽｿｽJｿｽoｿｽｿｽｿｽｿｽｿｽs
!  *          STM_ERR_OK    ｿｽｿｽｿｽJｿｽoｿｽｿｽｿｽｿｽｿｽｿｽ
   *************************************************/
  Sint32  STM_Recover(void)
  {
***************
*** 1212,1228 ****
  
  
  /*************************************************
!  * アクセス終了のチェック(7.8)
!  * stm  : ストリームハンドル
!  * 戻り値 : TRUE  ストリームアクセスを終了した
!  *          FALSE ストリームアクセスを終了していない
   *************************************************/
  Bool    STM_IsComplete(StmHn stm)
  {
      Sint32      nsct;
      Sint32      stat;
      Sint32      sfad, efad;
!     Uint16      hirq;
  
      STMERR_SetFunc(STM_ISCOMPLETE);
      if (stm == NULL) {
--- 1213,1229 ----
  
  
  /*************************************************
!  * ｿｽAｿｽNｿｽZｿｽXｿｽIｿｽｿｽｿｽﾌチｿｽFｿｽbｿｽN(7.8)
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE  ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽｿｽ
!  *          FALSE ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽ
   *************************************************/
  Bool    STM_IsComplete(StmHn stm)
  {
      Sint32      nsct;
      Sint32      stat;
      Sint32      sfad, efad;
! //    Uint16      hirq;
  
      STMERR_SetFunc(STM_ISCOMPLETE);
      if (stm == NULL) {
***************
*** 1231,1246 ****
          return (FALSE);
      }
      stm = STM_ALIAS(stm);
!     nsct = STMSVR_GetNumCdbuf(stm);             /* バッファセクタ数     */
      STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!     stat = stm_getStat(stm, sfad, efad, nsct);  /* ストリームステータス */
      STMERR_CheckFatalErr();
!     if (stat == STAT_COMPLETED) {               /* アクセス完了の場合   */
          return (TRUE);
      }
      if ((stat == STAT_WAIT)&&
          (!GFS_TRN_ACTIVE(&(GFS_FILE_TRANS(STM_GFS(stm)))))) {
!                                               /* ウエイト状態、ゲート閉 */
          return (TRUE);
      }
      return (FALSE);
--- 1232,1247 ----
          return (FALSE);
      }
      stm = STM_ALIAS(stm);
!     nsct = STMSVR_GetNumCdbuf(stm);             /* ｿｽoｿｽbｿｽtｿｽ@ｿｽZｿｽNｿｽ^ｿｽｿｽ     */
      STL_GetPlayArea(STM_FLOW(stm), &sfad, &efad);
!     stat = stm_getStat(stm, sfad, efad, nsct);  /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽXｿｽeｿｽ[ｿｽ^ｿｽX */
      STMERR_CheckFatalErr();
!     if (stat == STAT_COMPLETED) {               /* ｿｽAｿｽNｿｽZｿｽXｿｽｿｽｿｽｿｽｿｽﾌ場合   */
          return (TRUE);
      }
      if ((stat == STAT_WAIT)&&
          (!GFS_TRN_ACTIVE(&(GFS_FILE_TRANS(STM_GFS(stm)))))) {
!                                               /* ｿｽEｿｽGｿｽCｿｽgｿｽｿｽｿｽﾔ、ｿｽQｿｽ[ｿｽgｿｽｿｽ */
          return (TRUE);
      }
      return (FALSE);
***************
*** 1248,1261 ****
  
  
  /*************************************************
!  * ストリームデータの転送(7.9)
!  * stm  : ストリームハンドル
!  * 戻り値 : TRUE  転送した
!  *          FALSE 転送できなかった
   *************************************************/
  Bool    STM_ExecTrans(StmHn stm)
  {
!     GfsHn       gfs;
      Sint32      tsct;
      GftrHn      gftr;
      Bool        trans;
--- 1249,1262 ----
  
  
  /*************************************************
!  * ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽﾌ転ｿｽｿｽ(7.9)
!  * stm  : ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽ
!  * ｿｽﾟゑｿｽｿｽl : TRUE  ｿｽ]ｿｽｿｽｿｽｿｽｿｽｿｽ
!  *          FALSE ｿｽ]ｿｽｿｽｿｽﾅゑｿｽｿｽﾈゑｿｽｿｽｿｽｿｽｿｽ
   *************************************************/
  Bool    STM_ExecTrans(StmHn stm)
  {
! //    GfsHn       gfs;
      Sint32      tsct;
      GftrHn      gftr;
      Bool        trans;
***************
*** 1269,1278 ****
      if (MNG_SVREXEC(stm_mng_ptr) == FALSE) {
          MNG_SVREXEC(stm_mng_ptr) = TRUE;
          stm = STM_ALIAS(stm);
!         /* SCU-DMA使用中の場合には転送終了チェックをおこなう    */
          if (gfs_use_scudma == TRUE) {
              GFTR_ExecSvr(STM_GFS(stm), &trans);
!             /* A-Busアクセス不可のため以降の処理はおこなわない  */
              if (gfs_use_scudma == TRUE) {
                  MNG_SVREXEC(stm_mng_ptr) = FALSE;
                  return (trans);
--- 1270,1279 ----
      if (MNG_SVREXEC(stm_mng_ptr) == FALSE) {
          MNG_SVREXEC(stm_mng_ptr) = TRUE;
          stm = STM_ALIAS(stm);
!         /* SCU-DMAｿｽgｿｽpｿｽｿｽｿｽﾌ場合ｿｽﾉは転ｿｽｿｽｿｽIｿｽｿｽｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ    */
          if (gfs_use_scudma == TRUE) {
              GFTR_ExecSvr(STM_GFS(stm), &trans);
!             /* A-BusｿｽAｿｽNｿｽZｿｽXｿｽsｿｽﾂのゑｿｽｿｽﾟ以降ｿｽﾌ擾ｿｽｿｽｿｽｿｽﾍゑｿｽｿｽｿｽｿｽﾈゑｿｽｿｽﾈゑｿｽ  */
              if (gfs_use_scudma == TRUE) {
                  MNG_SVREXEC(stm_mng_ptr) = FALSE;
                  return (trans);
diff -crBN --binary sbl6/segalib/stm/stm_trn.c sbl6_patch/segalib/stm/stm_trn.c
*** sbl6/segalib/stm/stm_trn.c	1996-02-08 05:25:48.000000000 -0500
--- sbl6_patch/segalib/stm/stm_trn.c	2023-01-07 14:36:46.000000000 -0500
***************
*** 61,67 ****
   *************************************************/
  void    STM_SetTrFunc(StmHn stm, StmTrFunc func, void *obj)
  {
-     GfsTransFunc    tfunc;
      GftrHn          gftr;
  
      STMERR_SetFunc(STM_SETTRFUNC);
--- 61,66 ----
***************
*** 142,148 ****
  
  void    STM_SetTrBuf(StmHn stm, void *buffer, Sint32 nunit, Sint32 unitsize)
  {
!     Sint32      bufsize;
  
      STMERR_SetFunc(STM_SETTRBUF);
      if (stm == NULL) {
--- 141,147 ----
  
  void    STM_SetTrBuf(StmHn stm, void *buffer, Sint32 nunit, Sint32 unitsize)
  {
! //    Sint32      bufsize;
  
      STMERR_SetFunc(STM_SETTRBUF);
      if (stm == NULL) {
***************
*** 190,198 ****
  
  void    STM_ResetTrBuf(StmHn stm)
  {
-     Uint8       *data;
-     Sint32      bsize;
- 
      STMERR_SetFunc(STM_RESETTRBUF);
      if (stm == NULL) {
          STMERR_SetCode(STM_ERR_HNDL);
--- 189,194 ----
diff -crBN --binary sbl6/segasmp/bup/font/fnt_cod1.c sbl6_patch/segasmp/bup/font/fnt_cod1.c
*** sbl6/segasmp/bup/font/fnt_cod1.c	1996-02-08 05:26:36.000000000 -0500
--- sbl6_patch/segasmp/bup/font/fnt_cod1.c	2021-12-18 11:44:08.000000000 -0500
***************
*** 1,3 ****
--- 1,5 ----
+ #include <string.h>
+ 
  #include	<sega_xpt.h>
  
  #define		FNT_JAPAN	1
***************
*** 89,95 ****
  #ifndef __GNUC__
  	if(wx > FntXsize)	wx = FntXsize/2 - strlen(str)*4;
  #else
! 	if(wx > FntXsize)	wx = FntXsize/2 - strlen((Uint8 *)str)*4;
  #endif
  
  	i=0;
--- 91,97 ----
  #ifndef __GNUC__
  	if(wx > FntXsize)	wx = FntXsize/2 - strlen(str)*4;
  #else
! 	if(wx > FntXsize)	wx = FntXsize/2 - strlen((const char *)str)*4;
  #endif
  
  	i=0;
***************
*** 118,121 ****
  		i++;
  	}
  }
! 
\ No newline at end of file
--- 120,123 ----
  		i++;
  	}
  }
! 
diff -crBN --binary sbl6/segasmp/bup/smpbup1.c sbl6_patch/segasmp/bup/smpbup1.c
*** sbl6/segasmp/bup/smpbup1.c	1996-02-08 05:26:38.000000000 -0500
--- sbl6_patch/segasmp/bup/smpbup1.c	2024-05-20 10:08:34.000000000 -0400
***************
*** 4,14 ****
  *	Copyright(c) 1994 SEGA
  *
  *  PURPOSE:
! *	「バックアップライブラリ」テストプログラム
  *
  *  AUTHOR(S):
  *	K.M
! *		
  *  MOD HISTORY:
  *	Written by K.M on 1994-08-27 Ver.1.00
  *	Updated by K.M on 1994-09-12 Ver.1.00
--- 4,14 ----
  *	Copyright(c) 1994 SEGA
  *
  *  PURPOSE:
! *	ｿｽuｿｽoｿｽbｿｽNｿｽAｿｽbｿｽvｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽvｿｽeｿｽXｿｽgｿｽvｿｽｿｽｿｽOｿｽｿｽｿｽｿｽ
  *
  *  AUTHOR(S):
  *	K.M
! *
  *  MOD HISTORY:
  *	Written by K.M on 1994-08-27 Ver.1.00
  *	Updated by K.M on 1994-09-12 Ver.1.00
***************
*** 17,27 ****
  
  #include	<stdio.h>
  #include	<machine.h>
  #include	"sega_scl.h"
  #include	"sega_per.h"
  #include	"sega_bup.h"
! #include	"..\v_blank\v_blank.h"
! #include	"font\smp_font.h"
  
  #define 	BUP_START_ADDR	0x6070000
  
--- 17,28 ----
  
  #include	<stdio.h>
  #include	<machine.h>
+ 
  #include	"sega_scl.h"
  #include	"sega_per.h"
  #include	"sega_bup.h"
! #include	"v_blank/v_blank.h"
! #include	"font/smp_font.h"
  
  #define 	BUP_START_ADDR	0x6070000
  
***************
*** 73,79 ****
  	"SAT"
  };
  
! void main(void)
  {
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
--- 74,80 ----
  	"SAT"
  };
  
! int main(void)
  {
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
***************
*** 101,112 ****
  	clock = CLOCK_26;
  	DispInit(clock);
  
! 	/* バックアップライブラリ初期化 */
  	BackUpInit(CnTb);
  
  	while(1) switch(MainMenu(&sel)){
  		case	1:
! 			/* バックアップライブラリ初期化 */
  			BackUpInit(CnTb);
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
--- 102,113 ----
  	clock = CLOCK_26;
  	DispInit(clock);
  
! 	/* ｿｽoｿｽbｿｽNｿｽAｿｽbｿｽvｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  	BackUpInit(CnTb);
  
  	while(1) switch(MainMenu(&sel)){
  		case	1:
! 			/* ｿｽoｿｽbｿｽNｿｽAｿｽbｿｽvｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  			BackUpInit(CnTb);
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
***************
*** 133,143 ****
  			FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,buff,20,80,2,0);
  #endif
  			part=0;
! 			PadInputWait();/* パッド入力待ち */
  			dummy = 0;
  			break;
  		case	2:
! 			/* パーティション選択 */
  			if(device==2){
  				if(part==0)	part = 1;
  				else		part = 0;
--- 134,144 ----
  			FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,buff,20,80,2,0);
  #endif
  			part=0;
! 			PadInputWait();/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽﾍ待ゑｿｽ */
  			dummy = 0;
  			break;
  		case	2:
! 			/* ｿｽpｿｽ[ｿｽeｿｽBｿｽVｿｽｿｽｿｽｿｽｿｽIｿｽｿｽ */
  			if(device==2){
  				if(part==0)	part = 1;
  				else		part = 0;
***************
*** 145,151 ****
  			}
  			break;
  		case	3:
! 			/* Ｆｏｒｍａｔ */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  			ClrVram((Uint8 *)SCL_VDP2_VRAM_A0);
--- 146,152 ----
  			}
  			break;
  		case	3:
! 			/* ｿｽeｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  			ClrVram((Uint8 *)SCL_VDP2_VRAM_A0);
***************
*** 159,165 ****
  			err_disp( BackUpFormat(device),ON);
  			break;
  		case	4:
! 			/* ステイタス取得 */
  			err_disp( BUP_Stat(device,10,&StTb),OFF);
  			sprintf((char *)buff,"Total Size  :%10ld",StTb.totalsize);
  /* #if !(__GNUC__) */
--- 160,166 ----
  			err_disp( BackUpFormat(device),ON);
  			break;
  		case	4:
! 			/* ｿｽXｿｽeｿｽCｿｽ^ｿｽXｿｽ謫ｾ */
  			err_disp( BUP_Stat(device,10,&StTb),OFF);
  			sprintf((char *)buff,"Total Size  :%10ld",StTb.totalsize);
  /* #if !(__GNUC__) */
***************
*** 191,199 ****
  			PadInputWait();
  			break;
  		case	5:
! 			/* ファイル書き込み */
  			sprintf((char *)DirTb[0].filename,"DUMMYDAT%03d",dummy);
! 			sprintf((char *)DirTb[0].comment,"ｺﾒﾝﾄ%03d",dummy);
  			DirTb[0].language = BUP_JAPANESE;
  			DirTb[0].datasize = sizeof(DummyData);
  			DirTb[0].date = 0;
--- 192,200 ----
  			PadInputWait();
  			break;
  		case	5:
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  			sprintf((char *)DirTb[0].filename,"DUMMYDAT%03d",dummy);
! 			sprintf((char *)DirTb[0].comment,"ｿｽｿｽｿｽｿｽ%03d",dummy);
  			DirTb[0].language = BUP_JAPANESE;
  			DirTb[0].datasize = sizeof(DummyData);
  			DirTb[0].date = 0;
***************
*** 201,207 ****
  			dummy++;
  			break;
  		case	6:
! 			/* ファイル読み込み */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  			err_disp( BUP_Read(device,DirTb[fp].filename,
--- 202,208 ----
  			dummy++;
  			break;
  		case	6:
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾇみ搾ｿｽｿｽｿｽ */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  			err_disp( BUP_Read(device,DirTb[fp].filename,
***************
*** 228,238 ****
  #endif
  			break;
  		case	7:
! 			/* ファイルの削除 */
  			err_disp( BackUpDelete(device,DirTb[fp].filename),ON );
  			break;
  		case	8:
! 			/* ファイル一覧取得 */
  			num = BUP_Dir(device,(Uint8 *)"",50,DirTb);
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
--- 229,239 ----
  #endif
  			break;
  		case	7:
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ削除 */
  			err_disp( BackUpDelete(device,DirTb[fp].filename),ON );
  			break;
  		case	8:
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽ齬暦ｿｽ謫ｾ */
  			num = BUP_Dir(device,(Uint8 *)"",50,DirTb);
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
***************
*** 312,318 ****
  			}
  			break;
  		case	9:
! 			/* ベリファイ */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  			err_disp( BUP_Verify(device,DirTb[fp].filename,
--- 313,319 ----
  			}
  			break;
  		case	9:
! 			/* ｿｽxｿｽｿｽｿｽtｿｽ@ｿｽC */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  			err_disp( BUP_Verify(device,DirTb[fp].filename,
***************
*** 323,329 ****
  #endif
  			break;
  		case	10:
! 			/* クロックチェンジ */
  			if(clock == CLOCK_26)	clock = CLOCK_28;
  			else			clock = CLOCK_26;
  			DispInit(clock);
--- 324,330 ----
  #endif
  			break;
  		case	10:
! 			/* ｿｽNｿｽｿｽｿｽbｿｽNｿｽ`ｿｽFｿｽｿｽｿｽW */
  			if(clock == CLOCK_26)	clock = CLOCK_28;
  			else			clock = CLOCK_26;
  			DispInit(clock);
***************
*** 336,344 ****
  		case	12:if(!size)	size =   1000;
  		case	13:if(!size)	size =  10000;
  		case	14:if(!size)	size = 100000;
! 			/* ファイル書き込み */
  			sprintf((char *)DirTb[0].filename,"DUMMYDAT%03d",dummy);
! 			sprintf((char *)DirTb[0].comment,"ｺﾒﾝﾄ%03d",dummy);
  			DirTb[0].language = BUP_JAPANESE;
  			DirTb[0].datasize = size;
  			size = 0;
--- 337,345 ----
  		case	12:if(!size)	size =   1000;
  		case	13:if(!size)	size =  10000;
  		case	14:if(!size)	size = 100000;
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  			sprintf((char *)DirTb[0].filename,"DUMMYDAT%03d",dummy);
! 			sprintf((char *)DirTb[0].comment,"ｿｽｿｽｿｽｿｽ%03d",dummy);
  			DirTb[0].language = BUP_JAPANESE;
  			DirTb[0].datasize = size;
  			size = 0;
***************
*** 356,370 ****
  		case	16:
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
! 			/* ファイルの無限オーバーライト */
  			ClrVram((Uint8 *)SCL_VDP2_VRAM_A0);
  			FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 				(Uint8 *)"ﾊﾞｯｸｱｯﾌﾟﾗｲﾌﾞﾗﾘ Test Program",40,10,2,0);
  #else
! 			/* ファイルの無限オーバーライト */
  			ClrVram((volatile Uint8 *)SCL_VDP2_VRAM_A0);
  			FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 				(Uint8 *)"ﾊﾞｯｸｱｯﾌﾟﾗｲﾌﾞﾗﾘ Test Program",40,10,2,0);
  #endif
  			dummy = 0;
  			count = 0;
--- 357,371 ----
  		case	16:
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ厄ｿｽｿｽｿｽｿｽIｿｽ[ｿｽoｿｽ[ｿｽｿｽｿｽCｿｽg */
  			ClrVram((Uint8 *)SCL_VDP2_VRAM_A0);
  			FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 				(Uint8 *)"ｿｽﾞｯｿｽｿｽｿｽｿｽｿｽﾗｲｿｽｿｽｿｽｿｽ Test Program",40,10,2,0);
  #else
! 			/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ厄ｿｽｿｽｿｽｿｽIｿｽ[ｿｽoｿｽ[ｿｽｿｽｿｽCｿｽg */
  			ClrVram((volatile Uint8 *)SCL_VDP2_VRAM_A0);
  			FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 				(Uint8 *)"ｿｽﾞｯｿｽｿｽｿｽｿｽｿｽﾗｲｿｽｿｽｿｽｿｽ Test Program",40,10,2,0);
  #endif
  			dummy = 0;
  			count = 0;
***************
*** 376,382 ****
  			PadData1E = 0;
  			while( !(PadData1E & PAD_B) ){
  				sprintf((char *)DirTb[0].filename,"DUMMYDA%04d",dummy);
! 				sprintf((char *)DirTb[0].comment,"ｺﾒﾝﾄ%04d",dummy);
  				ret = BackUpWrite(device,&DirTb[0],DummyData2,(Uint8 )OFF);
  				sprintf((char *)buff,"Write :%s",DirTb[0].filename);
  /* #if !(__GNUC__) */
--- 377,383 ----
  			PadData1E = 0;
  			while( !(PadData1E & PAD_B) ){
  				sprintf((char *)DirTb[0].filename,"DUMMYDA%04d",dummy);
! 				sprintf((char *)DirTb[0].comment,"ｿｽｿｽｿｽｿｽ%04d",dummy);
  				ret = BackUpWrite(device,&DirTb[0],DummyData2,(Uint8 )OFF);
  				sprintf((char *)buff,"Write :%s",DirTb[0].filename);
  /* #if !(__GNUC__) */
***************
*** 433,438 ****
--- 434,441 ----
  			PadInputWait();
  			break;
  	}
+ 
+ 	return 0;
  }
  
  
***************
*** 450,462 ****
  
  
  static	Uint32	color[7] = {
! 	0x00000000,/* 透明色になるところだから何を入れても良い */
! 	0x00000000,/* 黒 */
! 	0x00FFFFFF,/* 白 */
! 	0x00FF0000,/* 青 */
! 	0x0000FF00,/* 緑 */
! 	0x000000FF,/* 赤 */
! 	0x00008000 /* 深緑 */
  };
  
  #define	BLACK	1
--- 453,465 ----
  
  
  static	Uint32	color[7] = {
! 	0x00000000,/* ｿｽｿｽｿｽｿｽｿｽFｿｽﾉなゑｿｽｿｽﾆゑｿｽｿｽだｿｽｿｽｿｽ迚ｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾇゑｿｽ */
! 	0x00000000,/* ｿｽｿｽ */
! 	0x00FFFFFF,/* ｿｽｿｽ */
! 	0x00FF0000,/* ｿｽｿｽ */
! 	0x0000FF00,/* ｿｽｿｽ */
! 	0x000000FF,/* ｿｽｿｽ */
! 	0x00008000 /* ｿｽ[ｿｽｿｽ */
  };
  
  #define	BLACK	1
***************
*** 475,490 ****
  
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
! 	*(Uint16 *)0x25F80000 &= 0x7fff;/* 画面表示をＯＦＦにする */
  #else
! 	*(volatile Uint16 *)0x25F80000 &= 0x7fff;/* 画面表示をＯＦＦにする */
  #endif
  	SCL_Vdp2Init();
  	if(clock == CLOCK_26)
  		SCL_SetDisplayMode(SCL_NON_INTER,SCL_240LINE,SCL_NORMAL_A);
  	else
  		SCL_SetDisplayMode(SCL_NON_INTER,SCL_240LINE,SCL_NORMAL_B);
! 	PER_SMPC_RES_ENA();/* リセットボタン有効 */
  
  	SCL_SetColRamMode(SCL_CRM24_1024);
  	BackCol = RGB16_COLOR(0,0,0) & 0x7fff;
--- 478,493 ----
  
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
! 	*(Uint16 *)0x25F80000 &= 0x7fff;/* ｿｽｿｽｿｽﾊ表ｿｽｿｽｿｽｿｽｿｽnｿｽeｿｽeｿｽﾉゑｿｽｿｽｿｽ */
  #else
! 	*(volatile Uint16 *)0x25F80000 &= 0x7fff;/* ｿｽｿｽｿｽﾊ表ｿｽｿｽｿｽｿｽｿｽnｿｽeｿｽeｿｽﾉゑｿｽｿｽｿｽ */
  #endif
  	SCL_Vdp2Init();
  	if(clock == CLOCK_26)
  		SCL_SetDisplayMode(SCL_NON_INTER,SCL_240LINE,SCL_NORMAL_A);
  	else
  		SCL_SetDisplayMode(SCL_NON_INTER,SCL_240LINE,SCL_NORMAL_B);
! 	PER_SMPC_RES_ENA();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽLｿｽｿｽ */
  
  	SCL_SetColRamMode(SCL_CRM24_1024);
  	BackCol = RGB16_COLOR(0,0,0) & 0x7fff;
***************
*** 492,498 ****
  #ifndef __GNUC__
  	SCL_SetBack(SCL_VDP2_VRAM+0x80000-2,1,&BackCol);
  #else
! 	SCL_SetBack((volatile)(SCL_VDP2_VRAM+0x80000-2),1,&BackCol);
  #endif
  	FNT_SetBuffSize(512,256,FNT_JAPAN);
  	SetVblank();
--- 495,501 ----
  #ifndef __GNUC__
  	SCL_SetBack(SCL_VDP2_VRAM+0x80000-2,1,&BackCol);
  #else
! 	SCL_SetBack((volatile Uint32)(SCL_VDP2_VRAM+0x80000-2),1,&BackCol);
  #endif
  	FNT_SetBuffSize(512,256,FNT_JAPAN);
  	SetVblank();
***************
*** 505,511 ****
  
  	SCL_SetPriority(SCL_NBG0,5);
  
! 	/* サイクルパターン設定 */
  	Scl_s_reg.vramcyc[0] = 0x44FF;	/* NBG0 256 Bitmap */
  
  	SCL_InitConfigTb(&Nbg0Scfg);
--- 508,514 ----
  
  	SCL_SetPriority(SCL_NBG0,5);
  
! 	/* ｿｽTｿｽCｿｽNｿｽｿｽｿｽpｿｽ^ｿｽ[ｿｽｿｽｿｽﾝ抵ｿｽ */
  	Scl_s_reg.vramcyc[0] = 0x44FF;	/* NBG0 256 Bitmap */
  
  	SCL_InitConfigTb(&Nbg0Scfg);
***************
*** 517,528 ****
  #ifndef __GNUC__
  		Nbg0Scfg.plate_addr[i] = SCL_VDP2_VRAM_A0;
  #else
! 		Nbg0Scfg.plate_addr[i] = (volatile) SCL_VDP2_VRAM_A0;
  #endif
  	SCL_SetConfig(SCL_NBG0, &Nbg0Scfg);
  
  	/**************************************
! 	*	スクロール画面の初期描画      *
  	**************************************/
  	SCL_Open(SCL_NBG0);
  		SCL_MoveTo(FIXED(0), FIXED(0), FIXED(0));
--- 520,531 ----
  #ifndef __GNUC__
  		Nbg0Scfg.plate_addr[i] = SCL_VDP2_VRAM_A0;
  #else
! 		Nbg0Scfg.plate_addr[i] = (volatile Uint32) SCL_VDP2_VRAM_A0;
  #endif
  	SCL_SetConfig(SCL_NBG0, &Nbg0Scfg);
  
  	/**************************************
! 	*	ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾊの擾ｿｽｿｽｿｽｿｽ`ｿｽｿｽ      *
  	**************************************/
  	SCL_Open(SCL_NBG0);
  		SCL_MoveTo(FIXED(0), FIXED(0), FIXED(0));
***************
*** 542,552 ****
  #ifndef __GNUC__
  	ClrVram((Uint8 *)SCL_VDP2_VRAM_A0);
  	FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 		(Uint8 *)"ﾊﾞｯｸｱｯﾌﾟﾗｲﾌﾞﾗﾘ Test Program",40,10,2,0);
  #else
  	ClrVram((volatile Uint8 *)SCL_VDP2_VRAM_A0);
  	FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 		(Uint8 *)"ﾊﾞｯｸｱｯﾌﾟﾗｲﾌﾞﾗﾘ Test Program",40,10,2,0);
  #endif
  	for(i=0;i<16;i++)	back[i] = 0;
  
--- 545,555 ----
  #ifndef __GNUC__
  	ClrVram((Uint8 *)SCL_VDP2_VRAM_A0);
  	FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 		(Uint8 *)"ｿｽﾞｯｿｽｿｽｿｽｿｽｿｽﾗｲｿｽｿｽｿｽｿｽ Test Program",40,10,2,0);
  #else
  	ClrVram((volatile Uint8 *)SCL_VDP2_VRAM_A0);
  	FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 		(Uint8 *)"ｿｽﾞｯｿｽｿｽｿｽｿｽｿｽﾗｲｿｽｿｽｿｽｿｽ Test Program",40,10,2,0);
  #endif
  	for(i=0;i<16;i++)	back[i] = 0;
  
***************
*** 607,616 ****
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  					FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ﾅｲｿﾞｳ ﾒﾓﾘ ",200, 40,WHITE,0);
  #else
  					FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ﾅｲｿﾞｳ ﾒﾓﾘ ",200, 40,WHITE,0);
  #endif
  					break;
  				case	1:
--- 610,619 ----
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  					FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ﾅｲｿｽﾞｳ ｿｽｿｽｿｽ ",200, 40,WHITE,0);
  #else
  					FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ﾅｲｿｽﾞｳ ｿｽｿｽｿｽ ",200, 40,WHITE,0);
  #endif
  					break;
  				case	1:
***************
*** 618,627 ****
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  					FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｶｰﾄﾘｯｼﾞ   ",200, 40,WHITE,0);
  #else
  					FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｶｰﾄﾘｯｼﾞ   ",200, 40,WHITE,0);
  #endif
  					break;
  				case	2:
--- 621,630 ----
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  					FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｿｽｿｽｿｽﾘｯｿｽｿｽ   ",200, 40,WHITE,0);
  #else
  					FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｿｽｿｽｿｽﾘｯｿｽｿｽ   ",200, 40,WHITE,0);
  #endif
  					break;
  				case	2:
***************
*** 629,638 ****
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  					FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｼﾘｱﾙ      ",200, 40,WHITE,0);
  #else
  					FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｼﾘｱﾙ      ",200, 40,WHITE,0);
  #endif
  					break;
  			}
--- 632,641 ----
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  					FNT_Print256((Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｿｽﾘｱｿｽ      ",200, 40,WHITE,0);
  #else
  					FNT_Print256((volatile Uint8 *)SCL_VDP2_VRAM_A0,
! 						(Uint8 *)"ｿｽﾘｱｿｽ      ",200, 40,WHITE,0);
  #endif
  					break;
  			}
***************
*** 713,719 ****
  	return(*sel+1);
  }
  
! /* パッド入力待ち */
  void	PadInputWait(void)
  {
  	PadData1E = 0;
--- 716,722 ----
  	return(*sel+1);
  }
  
! /* ｿｽpｿｽbｿｽhｿｽｿｽｿｽﾍ待ゑｿｽ */
  void	PadInputWait(void)
  {
  	PadData1E = 0;
***************
*** 776,793 ****
  
  
  /****************************/
! /* 書き込み中断防止特別処理 */
  /****************************/
  void	BackUpInit(BupConfig cntb[3])
  {
! 	PER_SMPC_RES_DIS();/* リセットボタン無効 */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  	BUP_Init((Uint32 *)BUP_START_ADDR,BackUpRamWork,cntb);
  #else
  	BUP_Init((volatile Uint32 *)BUP_START_ADDR,BackUpRamWork,cntb);
  #endif
! 	PER_SMPC_RES_ENA();/* リセットボタン有効 */
  }
  
  void	DispDate(char *comment,Uint16 x,Uint16 y)
--- 779,796 ----
  
  
  /****************************/
! /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾝ抵ｿｽｿｽfｿｽhｿｽ~ｿｽｿｽｿｽﾊ擾ｿｽｿｽｿｽ */
  /****************************/
  void	BackUpInit(BupConfig cntb[3])
  {
! 	PER_SMPC_RES_DIS();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽ */
  /* #if !(__GNUC__) */
  #ifndef __GNUC__
  	BUP_Init((Uint32 *)BUP_START_ADDR,BackUpRamWork,cntb);
  #else
  	BUP_Init((volatile Uint32 *)BUP_START_ADDR,BackUpRamWork,cntb);
  #endif
! 	PER_SMPC_RES_ENA();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽLｿｽｿｽ */
  }
  
  void	DispDate(char *comment,Uint16 x,Uint16 y)
***************
*** 823,829 ****
  	Uint8	*time;
  	BupDate	date;
  
! 	/* 日付データが０だったら現在の日付を入力する */
  	if(!dir->date){
  		time = PER_GET_TIM();
  		date.year = (Uint8 )( (Uint16 )(time[6]>>4) * 1000
--- 826,832 ----
  	Uint8	*time;
  	BupDate	date;
  
! 	/* ｿｽｿｽｿｽtｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽｿｽｿｽ迪ｻｿｽﾝの難ｿｽｿｽtｿｽｿｽｿｽｿｽｿｽﾍゑｿｽｿｽｿｽ */
  	if(!dir->date){
  		time = PER_GET_TIM();
  		date.year = (Uint8 )( (Uint16 )(time[6]>>4) * 1000
***************
*** 837,845 ****
  		dir->date = BUP_SetDate(&date);
  	}
  
! 	PER_SMPC_RES_DIS();/* リセットボタン無効 */
  	ret = BUP_Write(device,dir,data,sw);
! 	PER_SMPC_RES_ENA();/* リセットボタン有効 */
  
  	return(ret);
  }
--- 840,848 ----
  		dir->date = BUP_SetDate(&date);
  	}
  
! 	PER_SMPC_RES_DIS();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽ */
  	ret = BUP_Write(device,dir,data,sw);
! 	PER_SMPC_RES_ENA();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽLｿｽｿｽ */
  
  	return(ret);
  }
***************
*** 848,856 ****
  {
  	Sint32	ret;
  
! 	PER_SMPC_RES_DIS();/* リセットボタン無効 */
  	ret = BUP_Delete(device,filename);
! 	PER_SMPC_RES_ENA();/* リセットボタン有効 */
  
  	return(ret);
  }
--- 851,859 ----
  {
  	Sint32	ret;
  
! 	PER_SMPC_RES_DIS();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽ */
  	ret = BUP_Delete(device,filename);
! 	PER_SMPC_RES_ENA();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽLｿｽｿｽ */
  
  	return(ret);
  }
***************
*** 859,868 ****
  {
  	Sint32	ret;
  
! 	PER_SMPC_RES_DIS();/* リセットボタン無効 */
  	ret = BUP_Format(device);
! 	PER_SMPC_RES_ENA();/* リセットボタン有効 */
  
  	return(ret);
  }
! 
\ No newline at end of file
--- 862,871 ----
  {
  	Sint32	ret;
  
! 	PER_SMPC_RES_DIS();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽ */
  	ret = BUP_Format(device);
! 	PER_SMPC_RES_ENA();/* ｿｽｿｽｿｽZｿｽbｿｽgｿｽ{ｿｽ^ｿｽｿｽｿｽLｿｽｿｽ */
  
  	return(ret);
  }
! 
diff -crBN --binary sbl6/segasmp/csh/smpcsh.c sbl6_patch/segasmp/csh/smpcsh.c
*** sbl6/segasmp/csh/smpcsh.c	1996-02-08 05:28:00.000000000 -0500
--- sbl6_patch/segasmp/csh/smpcsh.c	2021-12-18 11:30:38.000000000 -0500
***************
*** 1,13 ****
  #include "sega_xpt.h"
  #include "sega_csh.h"
  
! void main(void)
  {
  	CSH_Init(CSH_4WAY);
  	CSH_AllClr();
! 	CSH_Purge((volatile void *)0x06000008, (Uint32)0x10);
  
  	while(1)
  		;
  }
! 
\ No newline at end of file
--- 1,14 ----
  #include "sega_xpt.h"
  #include "sega_csh.h"
  
! int main(void)
  {
  	CSH_Init(CSH_4WAY);
  	CSH_AllClr();
! 	CSH_Purge((void *)0x06000008, (Uint32)0x10);
  
  	while(1)
  		;
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/dbg/smpdbg1/smpdbg10.c sbl6_patch/segasmp/dbg/smpdbg1/smpdbg10.c
*** sbl6/segasmp/dbg/smpdbg1/smpdbg10.c	1996-02-08 05:28:04.000000000 -0500
--- sbl6_patch/segasmp/dbg/smpdbg1/smpdbg10.c	2022-09-17 20:33:48.000000000 -0400
***************
*** 12,17 ****
--- 12,18 ----
  
  #include	<stdio.h>
  #include	<stdlib.h>
+ #include	<string.h>
  #include	<machine.h>
  
  #define		_SPR2_
***************
*** 322,328 ****
  extern Uint16	PadData1;
  #endif
  
! void main()
  {
      Uint8  *VRAM;
      int    i, j, l;
--- 323,329 ----
  extern Uint16	PadData1;
  #endif
  
! int main(void)
  {
      Uint8  *VRAM;
      int    i, j, l;
***************
*** 378,384 ****
          if(val == 99)
              *(Uint32*)0x6000001 = val; /* cause program error */
      }
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 379,386 ----
          if(val == 99)
              *(Uint32*)0x6000001 = val; /* cause program error */
      }
+     return 0;
  }
  
  /*  end of file */
! 
diff -crBN --binary sbl6/segasmp/dma/smpdma0/smpdma0.c sbl6_patch/segasmp/dma/smpdma0/smpdma0.c
*** sbl6/segasmp/dma/smpdma0/smpdma0.c	1996-02-08 05:28:08.000000000 -0500
--- sbl6_patch/segasmp/dma/smpdma0/smpdma0.c	2021-12-18 11:46:30.000000000 -0500
***************
*** 16,25 ****
  void SDMA_CpuAllStart(void);
  void SDMA_CpuCst(Uint32 , Uint32 ,void *, void *, Uint32);
  Uint32 SDMA_CpuResult(Uint32);
! Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! void main(void)
  {
      void *src, *dst;
      Uint32 cnt;
--- 16,25 ----
  void SDMA_CpuAllStart(void);
  void SDMA_CpuCst(Uint32 , Uint32 ,void *, void *, Uint32);
  Uint32 SDMA_CpuResult(Uint32);
! Uint32 hikaku(void *, void *, Uint32, Uint32, char *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! int main(void)
  {
      void *src, *dst;
      Uint32 cnt;
***************
*** 55,60 ****
--- 55,62 ----
      hikaku((void *)0x00000, (void *)0x6050000, 0x400, 1, "BOOT to WORK");
  
      for(;;);
+     
+     return 0;
  }
  /****************************************************************************/
  /*  全チャネルDMA開始                                                       */
***************
*** 140,146 ****
  /****************************************************************************/
  /*  結果比較関数                                                            */
  /****************************************************************************/
! Uint32 hikaku(void *src, void *dst, Uint32 cnt, Uint32 size, Sint8 *msg)
  {
  #if	0
  	/*
--- 142,148 ----
  /****************************************************************************/
  /*  結果比較関数                                                            */
  /****************************************************************************/
! Uint32 hikaku(void *src, void *dst, Uint32 cnt, Uint32 size, char *msg)
  {
  #if	0
  	/*
***************
*** 162,168 ****
      sprintf(pbuf, "[[ \'%s\' %08X >> %08X : %08X Count, %01X Byte ",
       msg, src, dst, cnt, size);
  #else
!     sprintf(pbuf, "[[ \'%s\' %08lX >> %08lX : %08lX Count, %01lX Byte ",
       msg, ( Uint32 )src, ( Uint32 )dst, cnt, size);
  #endif
      pbuf += strlen(pbuf);
--- 164,170 ----
      sprintf(pbuf, "[[ \'%s\' %08X >> %08X : %08X Count, %01X Byte ",
       msg, src, dst, cnt, size);
  #else
!     sprintf((const char *)pbuf, "[[ \'%s\' %08lX >> %08lX : %08lX Count, %01lX Byte ",
       msg, ( Uint32 )src, ( Uint32 )dst, cnt, size);
  #endif
      pbuf += strlen(pbuf);
***************
*** 308,311 ****
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
\ No newline at end of file
--- 310,313 ----
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
diff -crBN --binary sbl6/segasmp/dma/smpdma1/smpdma1.c sbl6_patch/segasmp/dma/smpdma1/smpdma1.c
*** sbl6/segasmp/dma/smpdma1/smpdma1.c	1996-02-08 05:28:12.000000000 -0500
--- sbl6_patch/segasmp/dma/smpdma1/smpdma1.c	2022-01-17 19:55:44.000000000 -0500
***************
*** 16,22 ****
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! void main(void)
  {
      void *src, *dst;
      Uint32 cnt;
--- 16,22 ----
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! int main(void)
  {
      void *src, *dst;
      Uint32 cnt;
***************
*** 43,48 ****
--- 43,50 ----
      hikaku(src, dst, cnt, 1, "BOOT to WORK");
  
      for(;;) ;
+     
+     return 0;
  }
  /****************************************************************************/
  /*  結果比較関数                                                            */
***************
*** 209,212 ****
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
\ No newline at end of file
--- 211,214 ----
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
diff -crBN --binary sbl6/segasmp/dma/smpdma10/smpdma10.c sbl6_patch/segasmp/dma/smpdma10/smpdma10.c
*** sbl6/segasmp/dma/smpdma10/smpdma10.c	1996-02-08 05:28:14.000000000 -0500
--- sbl6_patch/segasmp/dma/smpdma10/smpdma10.c	2022-01-17 19:55:10.000000000 -0500
***************
*** 18,24 ****
  Uint32 SDMA_ScuResult(Uint32);
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  
! void main(void)
  {
      void *src, *dst;
      Uint32 cnt;
--- 18,24 ----
  Uint32 SDMA_ScuResult(Uint32);
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  
! int main(void)
  {
      void *src, *dst;
      Uint32 cnt;
***************
*** 58,63 ****
--- 58,65 ----
      hikaku((void *)0x06050000, (void *)0x25c00000, 0x0600, 1, "ADR to ADR");
  
      for(;;);
+     
+     return 0;
  }
  /****************************************************************************/
  /*  ステータス取得(チャネル指定)                                            */
***************
*** 227,230 ****
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
\ No newline at end of file
--- 229,232 ----
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
diff -crBN --binary sbl6/segasmp/dma/smpdma12/smpdma12.c sbl6_patch/segasmp/dma/smpdma12/smpdma12.c
*** sbl6/segasmp/dma/smpdma12/smpdma12.c	1996-02-08 05:28:18.000000000 -0500
--- sbl6_patch/segasmp/dma/smpdma12/smpdma12.c	2022-01-17 19:54:56.000000000 -0500
***************
*** 16,22 ****
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! void main(void)
  {
      void *src, *dst;
      Uint32 cnt;
--- 16,22 ----
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! int main(void)
  {
      void *src, *dst;
      Uint32 cnt;
***************
*** 34,39 ****
--- 34,41 ----
      hikaku(src, dst, cnt, 1, "WORK to VDP1");
  
      for(;;) ;
+     
+     return 0;
  }
  /****************************************************************************/
  /*  結果比較関数                                                            */
***************
*** 200,203 ****
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
\ No newline at end of file
--- 202,205 ----
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
diff -crBN --binary sbl6/segasmp/dma/smpdma2/smpdma2.c sbl6_patch/segasmp/dma/smpdma2/smpdma2.c
*** sbl6/segasmp/dma/smpdma2/smpdma2.c	1996-02-08 05:28:22.000000000 -0500
--- sbl6_patch/segasmp/dma/smpdma2/smpdma2.c	2022-01-17 19:55:28.000000000 -0500
***************
*** 15,21 ****
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! void main(void)
  {
      void *src, *dst;
      Uint32 cnt;
--- 15,21 ----
  Uint32 hikaku(void *, void *, Uint32, Uint32, Sint8 *); /*  結果確認関数    */
  void rev(void *, void *, Uint32, Uint32);   /*  転送先データ破壊関数        */
  
! int main(void)
  {
      void *src, *dst;
      Uint32 cnt;
***************
*** 115,120 ****
--- 115,122 ----
      hikaku(src, dst, cnt, 1, "BOOT to all VDP2");
  
      for(;;) ;
+     
+     return 0;
  }
  /****************************************************************************/
  /*  結果比較関数                                                            */
***************
*** 281,284 ****
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
\ No newline at end of file
--- 283,286 ----
  /****************************************************************************/
  /*  End of File                                                             */
  /****************************************************************************/
! 
diff -crBN --binary sbl6/segasmp/dual/sega_spr.h sbl6_patch/segasmp/dual/sega_spr.h
*** sbl6/segasmp/dual/sega_spr.h	1996-02-08 05:28:24.000000000 -0500
--- sbl6_patch/segasmp/dual/sega_spr.h	2024-08-18 20:46:44.000000000 -0400
***************
*** 1,22 ****
  /*----------------------------------------------------------------------------
!  *  sega_spr.h -- SPR ライブラリ インクルードファイル
   *  Copyright(c) 1994 SEGA
   *  Written by H.E on 1994-02-15 Ver.0.80
   *  Updated by H.E on 1994-02-15 Ver.0.80
   *
!  *  スプライト表示用インクルードファイルで使用スプライト表示ライブラリの種別に
!  *  より以下のように定義します。
   *
!  *  （１）スプライト表示基本処理のみの場合
   *
   *        #include "sega_spr.h"
   *
!  *  （２）スプライト表示拡張処理の場合
   *
   *        #define  _SPR2_
   *        #include "sega_spr.h"
   *
!  *  （３）スプライト３Ｄ表示処理の場合
   *
   *        #define  _SPR3_
   *        #include "sega_spr.h"
--- 1,22 ----
  /*----------------------------------------------------------------------------
!  *  sega_spr.h -- SPR ｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ ｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽ
   *  Copyright(c) 1994 SEGA
   *  Written by H.E on 1994-02-15 Ver.0.80
   *  Updated by H.E on 1994-02-15 Ver.0.80
   *
!  *  ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ\ｿｽｿｽｿｽpｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾅ使ｿｽpｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ\ｿｽｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ趣ｿｽｿｽﾊゑｿｽ
!  *  ｿｽｿｽｿｽｿｽｿｽﾈ会ｿｽｿｽﾌようｿｽﾉ抵ｿｽｿｽ`ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
!  *  ｿｽiｿｽPｿｽjｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ\ｿｽｿｽｿｽｿｽｿｽ{ｿｽｿｽｿｽｿｽｿｽﾌみの場合
   *
   *        #include "sega_spr.h"
   *
!  *  ｿｽiｿｽQｿｽjｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ\ｿｽｿｽｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ場合
   *
   *        #define  _SPR2_
   *        #include "sega_spr.h"
   *
!  *  ｿｽiｿｽRｿｽjｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽRｿｽcｿｽ\ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ場合
   *
   *        #define  _SPR3_
   *        #include "sega_spr.h"
***************
*** 28,33 ****
--- 28,34 ----
  #ifndef SEGA_SPR_H
  #define SEGA_SPR_H
  
+ 
  /*-----------------------------------
   * Select 3D Execute Machine
   *---------------------------------*/
***************
*** 70,75 ****
--- 71,84 ----
  typedef long                  Long;
  typedef float                 Float;
  typedef double                Double;
+ typedef unsigned    char    Uint8;      /* ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽPｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef signed      char    Sint8;      /* ｿｽｿｽｿｽｿｽｿｽﾂゑｿｽｿｽPｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef unsigned    short   Uint16;     /* ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽQｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef signed      short   Sint16;     /* ｿｽｿｽｿｽｿｽｿｽﾂゑｿｽｿｽQｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef unsigned    long    Uint32;     /* ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽSｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef signed      long    Sint32;     /* ｿｽｿｽｿｽｿｽｿｽﾂゑｿｽｿｽSｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef float               Float32;    /* ｿｽSｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
+ typedef double              Float64;    /* ｿｽWｿｽoｿｽCｿｽgｿｽｿｽｿｽｿｽ */
  typedef Sint32                Fixed32;    /* Fixed-point representation         */
  					  /* Radix point is between bit 15 & 16 */
  
***************
*** 93,103 ****
  #ifndef FALSE
  #define FALSE                 0
  #endif
! */
  #ifndef TRUE
  #define TRUE                  1
  #endif
! 
  #ifndef NIL
  #define NIL                   0
  #endif
--- 102,112 ----
  #ifndef FALSE
  #define FALSE                 0
  #endif
! 
  #ifndef TRUE
  #define TRUE                  1
  #endif
! */
  #ifndef NIL
  #define NIL                   0
  #endif
***************
*** 109,122 ****
  #ifndef Void
  #define Void                  void
  #endif
! 
  #ifndef OK
  #define OK                    0
  #endif
! 
! #ifndef NG
! #define NG                    -1
! #endif
  
  /*
   * MACROS DECLARATIONS
--- 118,131 ----
  #ifndef Void
  #define Void                  void
  #endif
! /*
  #ifndef OK
  #define OK                    0
  #endif
! */
! // #ifndef NG
! // #define NG                    -1
! // #endif
  
  /*
   * MACROS DECLARATIONS
***************
*** 126,146 ****
  #define FIXED(x)	      ((Fixed32)((x) * 65536.0))
  #define FIXED_TO_FLOAT(x)     ((Float32)((long)(x) / 65536.0))
  
! #if(_MACHINE == _SH_)
  #define INT_TO_FIXED(x)       SPR_ITOF(x)
  #define FIXED_TO_INT(x)       SPR_FTOI(x)
  #define MUL_FIXED(a, b)       SPR_MULF(a, b)
  #define DIV_FIXED(a, b)       SPR_DIVF(a, b)
! PROTOTYPE(Fixed32, SPR_ITOF, (int x));
! PROTOTYPE(int,     SPR_FTOI, (Fixed32 x));
! PROTOTYPE(Fixed32, SPR_MULF, (Fixed32 a, Fixed32 b));
! PROTOTYPE(Fixed32, SPR_DIVF, (Fixed32 a, Fixed32 b));
! #else
! #define INT_TO_FIXED(x)       ((Fixed32)((x) * 65536))
! #define FIXED_TO_INT(x)       ((Sint32)((x) / 65536))
! #define MUL_FIXED(a, b)       (((a) / 256) * ((b) / 256))
! #define DIV_FIXED(a, b)       (((a) / ((b) / 256)) * 256)
! #endif
  
  PROTOTYPE(Fixed32, fxsin, (Fixed32 degree));
  PROTOTYPE(Fixed32, fxcos, (Fixed32 degree));
--- 135,157 ----
  #define FIXED(x)	      ((Fixed32)((x) * 65536.0))
  #define FIXED_TO_FLOAT(x)     ((Float32)((long)(x) / 65536.0))
  
! //#if(_MACHINE == _SH_)
! Fixed32 SPR_ITOF(int x);
! int SPR_FTOI(Fixed32 x);
! Fixed32 SPR_MULF(Fixed32 a, Fixed32 b);
! Fixed32 SPR_DIVF(Fixed32 a, Fixed32 b);
! 
  #define INT_TO_FIXED(x)       SPR_ITOF(x)
  #define FIXED_TO_INT(x)       SPR_FTOI(x)
  #define MUL_FIXED(a, b)       SPR_MULF(a, b)
  #define DIV_FIXED(a, b)       SPR_DIVF(a, b)
! 
! // #else
! // #define INT_TO_FIXED(x)       ((Fixed32)((x) * 65536))
! // #define FIXED_TO_INT(x)       ((Sint32)((x) / 65536))
! // #define MUL_FIXED(a, b)       (((a) / 256) * ((b) / 256))
! // #define DIV_FIXED(a, b)       (((a) / ((b) / 256)) * 256)
! // #endif
  
  PROTOTYPE(Fixed32, fxsin, (Fixed32 degree));
  PROTOTYPE(Fixed32, fxcos, (Fixed32 degree));
***************
*** 159,166 ****
   * GLOBAL DEFINES/MACROS DEFINES
   */
  
- #define  RGB(r,g,b)  ((b<<10) + (g<<5) + r + 0x8000)
- 
  #define  VRAM_SIZE           512*1024   /* 512 Kbyte                        */
  
  #define  AUTO_FRAME_CHG      0          /* auto frame change mode           */
--- 170,175 ----
***************
*** 392,398 ****
  PROTOTYPE(Void  , SPR_2Line, (Uint16, Uint16, GlbXYint *, Uint16));
  PROTOTYPE(Void  , SPR_2PolyLine, (Uint16, Uint16, GlbXYint *, Uint16));
  PROTOTYPE(Void  , SPR_2Polygon, (Uint16, Uint16, GlbXYint *, Uint16));
! PROTOTYPE(Void  , SPR_2NormSpr, (Uint16, Uint16, Uint16, 
  				       Uint16, GlbXYint *, Uint16));
  PROTOTYPE(Void  , SPR_2ScaleSpr, (Uint16, Uint16, Uint16,
  					Uint16, GlbXYint *xy, Uint16));
--- 401,407 ----
  PROTOTYPE(Void  , SPR_2Line, (Uint16, Uint16, GlbXYint *, Uint16));
  PROTOTYPE(Void  , SPR_2PolyLine, (Uint16, Uint16, GlbXYint *, Uint16));
  PROTOTYPE(Void  , SPR_2Polygon, (Uint16, Uint16, GlbXYint *, Uint16));
! PROTOTYPE(Void  , SPR_2NormSpr, (Uint16, Uint16, Uint16,
  				       Uint16, GlbXYint *, Uint16));
  PROTOTYPE(Void  , SPR_2ScaleSpr, (Uint16, Uint16, Uint16,
  					Uint16, GlbXYint *xy, Uint16));
***************
*** 422,480 ****
   * STRUCTURE DECLARATIONS
   */
  struct GlbCluster {
!     GlbObject3D	*object;        /* ３Ｄオブジェクト                          */
!     GlbCluster	*next;       	/* 次クラスタ                                */
!     GlbCluster	*child;      	/* 子クラスタ                                */
!     Uint16	angleSeq;       /* 回転順序                                  */
!     GlbXYZ	angle;	        /* 親クラスタの座標系における回転            */
!     GlbXYZ	point;	        /* 親クラスタの座標系における原点の座標      */
!     GlbXYZ	worldPoint;     /* ワールド座標系における原点の座標          */
  };
  
  struct GlbObject3D {
!     Uint16      dispFlag;       /* 表示フラグ                                */
!     Uint16      vertCount;      /* 頂点数                                    */
!     Uint16      surfaceCount;   /* 面数                                      */
!     GlbXYZ      *vertPoint;     /* 頂点座標テーブル                          */
!     GlbXYZ      *vertNormal;    /* 頂点の法線ベクトルテーブル                */
!     GlbSurface  *surface;       /* 面定義テーブル                            */
!     GlbXYZ      *surfaceNormal; /* 面の法線ベクトルテーブル                  */
!     Uint16      **shdIdxTbl;    /* シェーディングインデックステーブル        */
!     GlbObject3D *next;          /* 次３Ｄオブジェクト                        */
  };
  
  struct GlbSurface {
!     Uint16     vertNo[4];       /* 面を構成する頂点番号                      */
!     Uint16     drawMode;        /* 描画モード                                */
!     Uint16     color;           /* カラーデータ                              */
  };
  
  struct GlbTexture {
!     Uint16       charNo;        /* 面を構成する頂点番号                      */
!     Uint16       colorMode;     /* カラーモード                              */
!     Uint16       width;         /* キャラクタの幅                            */
!     Uint16       height;        /* キャラクタの高さ                          */
!     Uint8        *charData;     /* キャラクタデータのポインタ                */
!     GlbLookupTbl *lookupTbl;    /* ルックアップテーブルのポインタ            */
  };
  
  struct GlbCmdChain {
!     Fixed32     z;              /* Ｚソート代表値                            */
!     GlbCmdChain *next;          /* 次のコマンドチェインエントリポインタ      */
!     Uint16      cmdNo;          /* コマンド番号                              */
  };
  
  struct Glb3WorkArea {
!     Uint16      drawPolMax;     /* 描画ポリゴン最大数                        */
!     Uint16      objSurfMax;     /* オブジェクト内最大面数                    */
!     Uint16      objVertMax;     /* オブジェクト内最大頂点数                  */
!     Uint16      sortBlkMax;     /* ソートブロック最大エントリ数              */
!     Uint8       *surfBright;    /* 面輝度テーブル                            */
!     Uint8       *vertBright;    /* 頂点輝度テーブル                          */
!     GlbXYZ      *coord3D;       /* ３Ｄ座標変換後テーブル                    */
!     GlbXYint    *coord2D;       /* ２Ｄ透視変換後テーブル                    */
!     GlbCmdChain *cmdChain;      /* 描画ポリゴンコマンドチェインテーブル      */
!     GlbCmdChain **zSortBlk;     /* Ｚソートブロックエリア                    */
  };
  
  
--- 431,489 ----
   * STRUCTURE DECLARATIONS
   */
  struct GlbCluster {
!     GlbObject3D	*object;        /* ｿｽRｿｽcｿｽIｿｽuｿｽWｿｽFｿｽNｿｽg                          */
!     GlbCluster	*next;       	/* ｿｽｿｽｿｽNｿｽｿｽｿｽXｿｽ^                                */
!     GlbCluster	*child;      	/* ｿｽqｿｽNｿｽｿｽｿｽXｿｽ^                                */
!     Uint16	angleSeq;       /* ｿｽｿｽｿｽ]ｿｽｿｽｿｽｿｽ                                  */
!     GlbXYZ	angle;	        /* ｿｽeｿｽNｿｽｿｽｿｽXｿｽ^ｿｽﾌ搾ｿｽｿｽWｿｽnｿｽﾉゑｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ]            */
!     GlbXYZ	point;	        /* ｿｽeｿｽNｿｽｿｽｿｽXｿｽ^ｿｽﾌ搾ｿｽｿｽWｿｽnｿｽﾉゑｿｽｿｽｿｽｿｽ骭ｴｿｽ_ｿｽﾌ搾ｿｽｿｽW      */
!     GlbXYZ	worldPoint;     /* ｿｽｿｽｿｽ[ｿｽｿｽｿｽhｿｽｿｽｿｽWｿｽnｿｽﾉゑｿｽｿｽｿｽｿｽ骭ｴｿｽ_ｿｽﾌ搾ｿｽｿｽW          */
  };
  
  struct GlbObject3D {
!     Uint16      dispFlag;       /* ｿｽ\ｿｽｿｽｿｽtｿｽｿｽｿｽO                                */
!     Uint16      vertCount;      /* ｿｽｿｽｿｽ_ｿｽｿｽ                                    */
!     Uint16      surfaceCount;   /* ｿｽﾊ撰ｿｽ                                      */
!     GlbXYZ      *vertPoint;     /* ｿｽｿｽｿｽ_ｿｽｿｽｿｽWｿｽeｿｽ[ｿｽuｿｽｿｽ                          */
!     GlbXYZ      *vertNormal;    /* ｿｽｿｽｿｽ_ｿｽﾌ法ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽ                */
!     GlbSurface  *surface;       /* ｿｽﾊ抵ｿｽｿｽ`ｿｽeｿｽ[ｿｽuｿｽｿｽ                            */
!     GlbXYZ      *surfaceNormal; /* ｿｽﾊの法ｿｽｿｽｿｽxｿｽNｿｽgｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽ                  */
!     Uint16      **shdIdxTbl;    /* ｿｽVｿｽFｿｽ[ｿｽfｿｽBｿｽｿｽｿｽOｿｽCｿｽｿｽｿｽfｿｽbｿｽNｿｽXｿｽeｿｽ[ｿｽuｿｽｿｽ        */
!     GlbObject3D *next;          /* ｿｽｿｽｿｽRｿｽcｿｽIｿｽuｿｽWｿｽFｿｽNｿｽg                        */
  };
  
  struct GlbSurface {
!     Uint16     vertNo[4];       /* ｿｽﾊゑｿｽｿｽ\ｿｽｿｽｿｽｿｽｿｽ髓ｸｿｽ_ｿｽﾔ搾ｿｽ                      */
!     Uint16     drawMode;        /* ｿｽ`ｿｽ諠ゑｿｽ[ｿｽh                                */
!     Uint16     color;           /* ｿｽJｿｽｿｽｿｽ[ｿｽfｿｽ[ｿｽ^                              */
  };
  
  struct GlbTexture {
!     Uint16       charNo;        /* ｿｽﾊゑｿｽｿｽ\ｿｽｿｽｿｽｿｽｿｽ髓ｸｿｽ_ｿｽﾔ搾ｿｽ                      */
!     Uint16       colorMode;     /* ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽ[ｿｽh                              */
!     Uint16       width;         /* ｿｽLｿｽｿｽｿｽｿｽｿｽNｿｽ^ｿｽﾌ包ｿｽ                            */
!     Uint16       height;        /* ｿｽLｿｽｿｽｿｽｿｽｿｽNｿｽ^ｿｽﾌ搾ｿｽｿｽｿｽ                          */
!     Uint8        *charData;     /* ｿｽLｿｽｿｽｿｽｿｽｿｽNｿｽ^ｿｽfｿｽ[ｿｽ^ｿｽﾌポｿｽCｿｽｿｽｿｽ^                */
!     GlbLookupTbl *lookupTbl;    /* ｿｽｿｽｿｽbｿｽNｿｽAｿｽbｿｽvｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌポｿｽCｿｽｿｽｿｽ^            */
  };
  
  struct GlbCmdChain {
!     Fixed32     z;              /* ｿｽyｿｽ\ｿｽ[ｿｽgｿｽｿｽｿｽ\ｿｽl                            */
!     GlbCmdChain *next;          /* ｿｽｿｽｿｽﾌコｿｽ}ｿｽｿｽｿｽhｿｽ`ｿｽFｿｽCｿｽｿｽｿｽGｿｽｿｽｿｽgｿｽｿｽｿｽ|ｿｽCｿｽｿｽｿｽ^      */
!     Uint16      cmdNo;          /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽﾔ搾ｿｽ                              */
  };
  
  struct Glb3WorkArea {
!     Uint16      drawPolMax;     /* ｿｽ`ｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾅ大数                        */
!     Uint16      objSurfMax;     /* ｿｽIｿｽuｿｽWｿｽFｿｽNｿｽgｿｽｿｽｿｽﾅ托ｿｽｿｽﾊ撰ｿｽ                    */
!     Uint16      objVertMax;     /* ｿｽIｿｽuｿｽWｿｽFｿｽNｿｽgｿｽｿｽｿｽﾅ大頂ｿｽ_ｿｽｿｽ                  */
!     Uint16      sortBlkMax;     /* ｿｽ\ｿｽ[ｿｽgｿｽuｿｽｿｽｿｽbｿｽNｿｽﾅ托ｿｽｿｽGｿｽｿｽｿｽgｿｽｿｽｿｽｿｽ              */
!     Uint8       *surfBright;    /* ｿｽﾊ輝ｿｽxｿｽeｿｽ[ｿｽuｿｽｿｽ                            */
!     Uint8       *vertBright;    /* ｿｽｿｽｿｽ_ｿｽPｿｽxｿｽeｿｽ[ｿｽuｿｽｿｽ                          */
!     GlbXYZ      *coord3D;       /* ｿｽRｿｽcｿｽｿｽｿｽWｿｽﾏ奇ｿｽｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽ                    */
!     GlbXYint    *coord2D;       /* ｿｽQｿｽcｿｽｿｽｿｽｿｽｿｽﾏ奇ｿｽｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽ                    */
!     GlbCmdChain *cmdChain;      /* ｿｽ`ｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽRｿｽ}ｿｽｿｽｿｽhｿｽ`ｿｽFｿｽCｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽ      */
!     GlbCmdChain **zSortBlk;     /* ｿｽyｿｽ\ｿｽ[ｿｽgｿｽuｿｽｿｽｿｽbｿｽNｿｽGｿｽｿｽｿｽA                    */
  };
  
  
diff -crBN --binary sbl6/segasmp/dual/slv_mtx3.h sbl6_patch/segasmp/dual/slv_mtx3.h
*** sbl6/segasmp/dual/slv_mtx3.h	1996-02-08 05:28:26.000000000 -0500
--- sbl6_patch/segasmp/dual/slv_mtx3.h	2022-09-24 21:43:30.000000000 -0400
***************
*** 1,15 ****
  /*----------------------------------------------------------------------------
!  *  spr_mtx3.h -- SPR ライブラリ MTX3 インクルードファイル
   *  Copyright(c) 1994 SEGA
   *  Written by K.M on 1993-12-14 Ver.0.80
   *  Updated by H.E on 1994-02-15 Ver.0.80
   *
!  *  このインクルードファイルはスプライト３Ｄ表示のマトリックス演算ルーチン
!  *  定義。
   *
   *----------------------------------------------------------------------------
   */
!  
  #define	PRODUCT(a, b)\
  (MUL_FIXED((a).x, (b).x) + MUL_FIXED((a).y, (b).y) + MUL_FIXED((a).z, (b).z))
  
--- 1,19 ----
  /*----------------------------------------------------------------------------
!  *  spr_mtx3.h -- SPR ｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ MTX3 ｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽ
   *  Copyright(c) 1994 SEGA
   *  Written by K.M on 1993-12-14 Ver.0.80
   *  Updated by H.E on 1994-02-15 Ver.0.80
   *
!  *  ｿｽｿｽｿｽﾌイｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾍスｿｽvｿｽｿｽｿｽCｿｽgｿｽRｿｽcｿｽ\ｿｽｿｽｿｽﾌマｿｽgｿｽｿｽｿｽbｿｽNｿｽXｿｽｿｽｿｽZｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽ
!  *  ｿｽｿｽｿｽ`ｿｽB
   *
   *----------------------------------------------------------------------------
   */
! 
! #include "sega_spr.h"
! 
! struct GlbXYZ;
! 
  #define	PRODUCT(a, b)\
  (MUL_FIXED((a).x, (b).x) + MUL_FIXED((a).y, (b).y) + MUL_FIXED((a).z, (b).z))
  
diff -crBN --binary sbl6/segasmp/dual/slvsamp.c sbl6_patch/segasmp/dual/slvsamp.c
*** sbl6/segasmp/dual/slvsamp.c	1996-02-08 05:28:26.000000000 -0500
--- sbl6_patch/segasmp/dual/slvsamp.c	2024-08-18 20:34:44.000000000 -0400
***************
*** 4,10 ****
--- 4,12 ----
  
  #include "sega_xpt.h"
  #define _SPR2_
+ 
  #include "sega_spr.h"
+ #include "sl_def.h"
  #include "spr_mtx3.h"
  #include "slv_mtx3.h"
  
***************
*** 25,32 ****
  extern volatile Uint8 *SMPC_COM;  /* SMPC command register */
  extern volatile Uint8 *SMPC_RET;  /* SMPC result register */
  extern volatile Uint8 *SMPC_SF;   /* SMPC status flag */
! extern const Uint8 SMPC_SSHON;    /* SMPC slave SH on command */
! extern const Uint8 SMPC_SSHOFF;   /* SMPC slave SH off command */
  
  void SpFlipVram(void);
  
--- 27,34 ----
  extern volatile Uint8 *SMPC_COM;  /* SMPC command register */
  extern volatile Uint8 *SMPC_RET;  /* SMPC result register */
  extern volatile Uint8 *SMPC_SF;   /* SMPC status flag */
! //extern const Uint8 SMPC_SSHON;    /* SMPC slave SH on command */
! //extern const Uint8 SMPC_SSHOFF;   /* SMPC slave SH off command */
  
  void SpFlipVram(void);
  
***************
*** 34,44 ****
  #define SCRN_H 224
  
  Uint16 drawCount = 0;
! /* データのよみこみ */
  
! /* VDPI のコマンドテーブルの初期化部分 */
  static GlbSpCmd  spCmdS[] = {
!    {/* [-3]     */  /* システムクリップ設定 */
      /* control  */ (JUMP_NEXT | FUNC_SCLIP),
      /* link     */  0,
      /* drawMode */  0,
--- 36,46 ----
  #define SCRN_H 224
  
  Uint16 drawCount = 0;
! /* ｿｽfｿｽ[ｿｽ^ｿｽﾌゑｿｽｿｽﾝゑｿｽｿｽｿｽ */
  
! /* VDPI ｿｽﾌコｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  static GlbSpCmd  spCmdS[] = {
!    {/* [-3]     */  /* ｿｽVｿｽXｿｽeｿｽｿｽｿｽNｿｽｿｽｿｽbｿｽvｿｽﾝ抵ｿｽ */
      /* control  */ (JUMP_NEXT | FUNC_SCLIP),
      /* link     */  0,
      /* drawMode */  0,
***************
*** 52,58 ****
      /* grshAddr */  0,
      /* dummy    */  0},
  
!    {/* [-2]     */  /* ローカル座標系設定 */
      /* control  */ (JUMP_NEXT | FUNC_LCOORD),
      /* link     */  0,
      /* drawMode */  0,
--- 54,60 ----
      /* grshAddr */  0,
      /* dummy    */  0},
  
!    {/* [-2]     */  /* ｿｽｿｽｿｽ[ｿｽJｿｽｿｽｿｽｿｽｿｽWｿｽnｿｽﾝ抵ｿｽ */
      /* control  */ (JUMP_NEXT | FUNC_LCOORD),
      /* link     */  0,
      /* drawMode */  0,
***************
*** 66,72 ****
      /* grshAddr */  0,
      /* dummy    */  0},
  
!    {/* [-1]     */ /* ユーザクリップ設定 */
      /* control  */ (JUMP_NEXT | FUNC_UCLIP),
      /* link     */  0,
      /* drawMode */  0,
--- 68,74 ----
      /* grshAddr */  0,
      /* dummy    */  0},
  
!    {/* [-1]     */ /* ｿｽｿｽｿｽ[ｿｽUｿｽNｿｽｿｽｿｽbｿｽvｿｽﾝ抵ｿｽ */
      /* control  */ (JUMP_NEXT | FUNC_UCLIP),
      /* link     */  0,
      /* drawMode */  0,
***************
*** 84,90 ****
      /* control  */ (JUMP_NEXT | ZOOM_NOPOINT | DIR_NOREV | FUNC_POLYGON),
      /* link     */ 0,
      /* drawMode */ (COLOR_0 | ECDSPD_DISABLE),
!     /* color    */ 0x0000,  /* 透明 */
      /* charAddr */ 0x0000,
      /* charSize */ 0x0000,
      /* ax, ay   */   0,   0,
--- 86,92 ----
      /* control  */ (JUMP_NEXT | ZOOM_NOPOINT | DIR_NOREV | FUNC_POLYGON),
      /* link     */ 0,
      /* drawMode */ (COLOR_0 | ECDSPD_DISABLE),
!     /* color    */ 0x0000,  /* ｿｽｿｽｿｽｿｽ */
      /* charAddr */ 0x0000,
      /* charSize */ 0x0000,
      /* ax, ay   */   0,   0,
***************
*** 95,101 ****
      /* dummy    */   0}
  };
  
! /* VDPI のコマンドテーブルのテンプレート */
  
  #define SPRITE_COMMAND \
     {/* [ 0]     */ \
--- 97,103 ----
      /* dummy    */   0}
  };
  
! /* VDPI ｿｽﾌコｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌテｿｽｿｽｿｽvｿｽｿｽｿｽ[ｿｽg */
  
  #define SPRITE_COMMAND \
     {/* [ 0]     */ \
***************
*** 128,134 ****
     SPRITE_COMMAND
  };
  
! /* VDPI のエンドコマンドのテンプレート */
  static GlbSpCmd  spCmdE[] = {
     {/* [ E]     */
      /* control  */ (CTRL_END),
--- 130,136 ----
     SPRITE_COMMAND
  };
  
! /* VDPI ｿｽﾌエｿｽｿｽｿｽhｿｽRｿｽ}ｿｽｿｽｿｽhｿｽﾌテｿｽｿｽｿｽvｿｽｿｽｿｽ[ｿｽg */
  static GlbSpCmd  spCmdE[] = {
     {/* [ E]     */
      /* control  */ (CTRL_END),
***************
*** 148,163 ****
  Uint16	extCtrl = JUMP_NEXT | ZOOM_NOPOINT | DIR_NOREV | FUNC_POLYGON;
  Uint16	extMode = COLOR_0 | ECDSPD_DISABLE | COMPO_REP;
  Uint16	extSize = 0;
! Uint16  PolygonColor = 0xC210; /* 初期化用のポリゴンの色 */
  
! static Uint16 *Spbase[2]; /* VDPI コマンドテーブル(FW, BK)アドレスのテーブル */
  static Sint16 FWBank = 0, BKBank = 1;
  
! #define VRAM1		0x25C00000 /* VDPI コマンドテーブルの先頭(FWBank) */
! #define VRAM2		0x25C10000 /* VDPI コマンドテーブルの先頭(BKBank) */
  #define VRAMSize	   0x10000
  
! Void /* VDPI のレジスタの初期化 */
    VDPI_INIT(void)
  {
      *(Uint16 *)(0x25D00000) = 0x0;    /* NTSC, no-turn-around, 16bit/pixel */
--- 150,165 ----
  Uint16	extCtrl = JUMP_NEXT | ZOOM_NOPOINT | DIR_NOREV | FUNC_POLYGON;
  Uint16	extMode = COLOR_0 | ECDSPD_DISABLE | COMPO_REP;
  Uint16	extSize = 0;
! Uint16  PolygonColor = 0xC210; /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽpｿｽﾌポｿｽｿｽｿｽSｿｽｿｽｿｽﾌ色 */
  
! static Uint16 *Spbase[2]; /* VDPI ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽ(FW, BK)ｿｽAｿｽhｿｽｿｽｿｽXｿｽﾌテｿｽ[ｿｽuｿｽｿｽ */
  static Sint16 FWBank = 0, BKBank = 1;
  
! #define VRAM1		0x25C00000 /* VDPI ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌ先頭(FWBank) */
! #define VRAM2		0x25C10000 /* VDPI ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌ先頭(BKBank) */
  #define VRAMSize	   0x10000
  
! Void /* VDPI ｿｽﾌｿｽｿｽWｿｽXｿｽ^ｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
    VDPI_INIT(void)
  {
      *(Uint16 *)(0x25D00000) = 0x0;    /* NTSC, no-turn-around, 16bit/pixel */
***************
*** 168,174 ****
      *(Uint16 *)(0x25D0000a) = 0xffff; /* set e/w right bottom point to ffff */
  }
  
! void /* VDPI のコマンドテーブルに関する各種初期化 */
    sp_init(void)
  {
  	Sint32 i;
--- 170,176 ----
      *(Uint16 *)(0x25D0000a) = 0xffff; /* set e/w right bottom point to ffff */
  }
  
! void /* VDPI ｿｽﾌコｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾉ関ゑｿｽｿｽｿｽｿｽeｿｽ初ｿｽｿｽｿｽｿｽ */
    sp_init(void)
  {
  	Sint32 i;
***************
*** 213,229 ****
  	VDPI_INIT();
      }
  
! #define MAX_POLYGON_NUM 12 /* 描画を行なうポリゴンの最大数 */
  
! /* マスタ CPU が処理するポリゴン数 */
! #define MASTR_POLYGON_NUM MAX_POLYGON_NUM/2 
  
! /* スレーブ CPU が処理するポリゴン数 */
  #define SLAV_POLYGON_NUM MAX_POLYGON_NUM/2
  
  #define NUM_OF_MODEL0_SURF 6
  
! #define SCALE 16.0 /* 立方体の一辺の大きさ */
  GlbXYZ model0[4*NUM_OF_MODEL0_SURF] = {
      /* polygon 0 */
      {FIXED(-1.0*SCALE), FIXED(-1.0*SCALE), FIXED( 1.0*SCALE)},
--- 215,231 ----
  	VDPI_INIT();
      }
  
! #define MAX_POLYGON_NUM 12 /* ｿｽ`ｿｽｿｽｿｽｿｽｿｽsｿｽﾈゑｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ最大数 */
  
! /* ｿｽ}ｿｽXｿｽ^ CPU ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽ */
! #define MASTR_POLYGON_NUM MAX_POLYGON_NUM/2
  
! /* ｿｽXｿｽｿｽｿｽ[ｿｽu CPU ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽ */
  #define SLAV_POLYGON_NUM MAX_POLYGON_NUM/2
  
  #define NUM_OF_MODEL0_SURF 6
  
! #define SCALE 16.0 /* ｿｽｿｽｿｽｿｽｿｽﾌの茨ｿｽｿｽﾓの大きｿｽｿｽ */
  GlbXYZ model0[4*NUM_OF_MODEL0_SURF] = {
      /* polygon 0 */
      {FIXED(-1.0*SCALE), FIXED(-1.0*SCALE), FIXED( 1.0*SCALE)},
***************
*** 255,265 ****
      {FIXED(-1.0*SCALE), FIXED(-1.0*SCALE), FIXED( 1.0*SCALE)},
      {FIXED( 1.0*SCALE), FIXED(-1.0*SCALE), FIXED( 1.0*SCALE)},
      {FIXED( 1.0*SCALE), FIXED(-1.0*SCALE), FIXED(-1.0*SCALE)}
! }; /* モデルのデータ */
  
! #define EYEDIST FIXED(328.0) /* 視点の距離 */
  
! void /* Z ソートを行なう */
    zSort(Fixed32 *zBuff, Uint16 *SortBuff, Uint16 NumOfElement)
  {
      Uint16 i, j, count;
--- 257,267 ----
      {FIXED(-1.0*SCALE), FIXED(-1.0*SCALE), FIXED( 1.0*SCALE)},
      {FIXED( 1.0*SCALE), FIXED(-1.0*SCALE), FIXED( 1.0*SCALE)},
      {FIXED( 1.0*SCALE), FIXED(-1.0*SCALE), FIXED(-1.0*SCALE)}
! }; /* ｿｽｿｽｿｽfｿｽｿｽｿｽﾌデｿｽ[ｿｽ^ */
  
! #define EYEDIST FIXED(328.0) /* ｿｽｿｽｿｽ_ｿｽﾌ具ｿｽｿｽｿｽ */
  
! void /* Z ｿｽ\ｿｽ[ｿｽgｿｽｿｽｿｽsｿｽﾈゑｿｽ */
    zSort(Fixed32 *zBuff, Uint16 *SortBuff, Uint16 NumOfElement)
  {
      Uint16 i, j, count;
***************
*** 275,281 ****
      }
  }
  
! Uint16 Color[] = {   /* 各ポリゴンの色のテーブル */
      0x801F,
      0xC210,
      0xFC00,
--- 277,283 ----
      }
  }
  
! Uint16 Color[] = {   /* ｿｽeｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ色ｿｽﾌテｿｽ[ｿｽuｿｽｿｽ */
      0x801F,
      0xC210,
      0xFC00,
***************
*** 291,313 ****
      0xFC1F
    };
  
! Uint16 orig_x = 160, orig_y = 112; /* 原点のスクリーン上での位置 */
  
  void
    PutSpCommand(GlbXYint FourPoints[], Uint16 *SortBuff, Uint16 CommandNumber)
  {
      Uint16 *wp;
!     
      wp = Spbase[BKBank]+sizeof(GlbSpCmd)*CommandNumber/2+0x06/2;
      *wp++ = Color[SortBuff[CommandNumber]]; /* Polygon Color */
      wp += 2;
!     *wp++ =  orig_x+FourPoints[0].x; /* XA */  /* 左上座標 */
      *wp++ =  orig_y+FourPoints[0].y; /* YA */
!     *wp++ =  orig_x+FourPoints[1].x; /* XB */  /* 右上座標 */
      *wp++ =  orig_y+FourPoints[1].y; /* YB */
!     *wp++ =  orig_x+FourPoints[2].x; /* XC */  /* 右下座標 */
      *wp++ =  orig_y+FourPoints[2].y; /* YC */
!     *wp++ =  orig_x+FourPoints[3].x; /* XD */  /* 左下座標 */
      *wp++ =  orig_y+FourPoints[3].y; /* YD */
  }
  
--- 293,315 ----
      0xFC1F
    };
  
! Uint16 orig_x = 160, orig_y = 112; /* ｿｽｿｽｿｽ_ｿｽﾌスｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾅの位置 */
  
  void
    PutSpCommand(GlbXYint FourPoints[], Uint16 *SortBuff, Uint16 CommandNumber)
  {
      Uint16 *wp;
! 
      wp = Spbase[BKBank]+sizeof(GlbSpCmd)*CommandNumber/2+0x06/2;
      *wp++ = Color[SortBuff[CommandNumber]]; /* Polygon Color */
      wp += 2;
!     *wp++ =  orig_x+FourPoints[0].x; /* XA */  /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[0].y; /* YA */
!     *wp++ =  orig_x+FourPoints[1].x; /* XB */  /* ｿｽEｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[1].y; /* YB */
!     *wp++ =  orig_x+FourPoints[2].x; /* XC */  /* ｿｽEｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[2].y; /* YC */
!     *wp++ =  orig_x+FourPoints[3].x; /* XD */  /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[3].y; /* YD */
  }
  
***************
*** 321,333 ****
      wp = Spbase[BKBank]+sizeof(GlbSpCmd)*(CommandNumber+MASTR_POLYGON_NUM)/2+0x06/2;
      *wp++ = Color[SortBuff[CommandNumber]+MASTR_POLYGON_NUM]; /* Polygon Color */
      wp += 2;
!     *wp++ =  orig_x+FourPoints[0].x; /* XA */  /* 左上座標 */
      *wp++ =  orig_y+FourPoints[0].y; /* YA */
!     *wp++ =  orig_x+FourPoints[1].x; /* XB */  /* 右上座標 */
      *wp++ =  orig_y+FourPoints[1].y; /* YB */
!     *wp++ =  orig_x+FourPoints[2].x; /* XC */  /* 右下座標 */
      *wp++ =  orig_y+FourPoints[2].y; /* YC */
!     *wp++ =  orig_x+FourPoints[3].x; /* XD */  /* 左下座標 */
      *wp++ =  orig_y+FourPoints[3].y; /* YD */
  }
  
--- 323,335 ----
      wp = Spbase[BKBank]+sizeof(GlbSpCmd)*(CommandNumber+MASTR_POLYGON_NUM)/2+0x06/2;
      *wp++ = Color[SortBuff[CommandNumber]+MASTR_POLYGON_NUM]; /* Polygon Color */
      wp += 2;
!     *wp++ =  orig_x+FourPoints[0].x; /* XA */  /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[0].y; /* YA */
!     *wp++ =  orig_x+FourPoints[1].x; /* XB */  /* ｿｽEｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[1].y; /* YB */
!     *wp++ =  orig_x+FourPoints[2].x; /* XC */  /* ｿｽEｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[2].y; /* YC */
!     *wp++ =  orig_x+FourPoints[3].x; /* XD */  /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽW */
      *wp++ =  orig_y+FourPoints[3].y; /* YD */
  }
  
***************
*** 335,341 ****
    PutSpEndCommand(Uint16 CommandNumber)
  {
      Uint16 *wp;
!     
      wp = Spbase[BKBank]+sizeof(GlbSpCmd)*CommandNumber/2+0x00/2;
      *wp = 0x8000;
  }
--- 337,343 ----
    PutSpEndCommand(Uint16 CommandNumber)
  {
      Uint16 *wp;
! 
      wp = Spbase[BKBank]+sizeof(GlbSpCmd)*CommandNumber/2+0x00/2;
      *wp = 0x8000;
  }
***************
*** 347,365 ****
  
  #if	1
  /*
! **■1995-09-21	高橋智延
! **	スレーブ側とのＩ／Ｆは cache through かつ volatile にすること。
  */
  	extern volatile void	*SlaveCommand;
  	#define	slave_command	*( volatile Uint32 * )(( Uint32 )&SlaveCommand + 0x20000000 )
  #endif
! void /* マスタ CPU のメイン関数(スレーブ CPU に関数 slave の実行を依頼する) */
    main(void)
  {
  #if	0
  /*
! **■1995-09-21	高橋智延
! **	スレーブ側とのＩ／Ｆは cache through かつ volatile にすること。
  */
      extern void *SlaveCommand;
  #endif
--- 349,367 ----
  
  #if	1
  /*
! **ｿｽｿｽ1995-09-21	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽXｿｽｿｽｿｽ[ｿｽuｿｽｿｽｿｽﾆのＩｿｽ^ｿｽeｿｽｿｽ cache through ｿｽｿｽｿｽｿｽ volatile ｿｽﾉゑｿｽｿｽ驍ｱｿｽﾆ。
  */
  	extern volatile void	*SlaveCommand;
  	#define	slave_command	*( volatile Uint32 * )(( Uint32 )&SlaveCommand + 0x20000000 )
  #endif
! int /* ｿｽ}ｿｽXｿｽ^ CPU ｿｽﾌｿｽｿｽCｿｽｿｽｿｽﾖ撰ｿｽ(ｿｽXｿｽｿｽｿｽ[ｿｽu CPU ｿｽﾉ関撰ｿｽ slave ｿｽﾌ趣ｿｽｿｽsｿｽｿｽｿｽﾋ暦ｿｽｿｽｿｽｿｽｿｽ) */
    main(void)
  {
  #if	0
  /*
! **ｿｽｿｽ1995-09-21	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽXｿｽｿｽｿｽ[ｿｽuｿｽｿｽｿｽﾆのＩｿｽ^ｿｽeｿｽｿｽ cache through ｿｽｿｽｿｽｿｽ volatile ｿｽﾉゑｿｽｿｽ驍ｱｿｽﾆ。
  */
      extern void *SlaveCommand;
  #endif
***************
*** 399,406 ****
  
  #if	0
  /*
! **■1995-09-21	高橋智延
! **	スレーブ側とのＩ／Ｆは cache through かつ volatile にすること。
  */
      while(1){
  	SlaveCommand = slave;
--- 401,408 ----
  
  #if	0
  /*
! **ｿｽｿｽ1995-09-21	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽXｿｽｿｽｿｽ[ｿｽuｿｽｿｽｿｽﾆのＩｿｽ^ｿｽeｿｽｿｽ cache through ｿｽｿｽｿｽｿｽ volatile ｿｽﾉゑｿｽｿｽ驍ｱｿｽﾆ。
  */
      while(1){
  	SlaveCommand = slave;
***************
*** 416,449 ****
  	for(;;){
  		slave_command = ( Uint32 )slave;
  		*( Uint16 * )0x21000000 = 0xffff;
! 		
  		master();
! 		
  		while( slave_command != 0 )
  			;
! 		
  		SpFlipVram();
  		*( Uint16 * )0x25d00002 = 0x0003;
  	}
  #endif
  }
  
! void /* マスタ CPU が実行する関数 */
    master(void)
! {	
  /*	95-7-26	unuse
      Uint16 *wp;
! */  
      static Sint16 arg = 45;
      static Fixed32 cube0_x = FIXED(0.0), cube0_dx = -FIXED(1.7);
      static Fixed32 cube0_y = FIXED(0.0), cube0_dy = -FIXED(1.3);
      static Fixed32 cube0_z = FIXED(413.0), cube0_dz = FIXED(2.7);
      Uint16 i, j;
      Uint16 PolyNumber;
!     GlbXYZ Coord3D[4*MASTR_POLYGON_NUM]; /* 回転後の座標データバッファ */
!     GlbXYint  Coord2D[4*MASTR_POLYGON_NUM]; /* 透視変換後のデータバッファ */
!     Fixed32 zBuff[MASTR_POLYGON_NUM];    /* 各頂点の Z 値のバッファ    */
!     Uint16 SortBuff[MASTR_POLYGON_NUM];  /* Z 値でソートした頂点番号の並び */
  
      arg++;
      /* Control cube0 movements. */
--- 418,452 ----
  	for(;;){
  		slave_command = ( Uint32 )slave;
  		*( Uint16 * )0x21000000 = 0xffff;
! 
  		master();
! 
  		while( slave_command != 0 )
  			;
! 
  		SpFlipVram();
  		*( Uint16 * )0x25d00002 = 0x0003;
  	}
  #endif
+ 	return 0;
  }
  
! void /* ｿｽ}ｿｽXｿｽ^ CPU ｿｽｿｽｿｽｿｽｿｽsｿｽｿｽｿｽｿｽｿｽﾖ撰ｿｽ */
    master(void)
! {
  /*	95-7-26	unuse
      Uint16 *wp;
! */
      static Sint16 arg = 45;
      static Fixed32 cube0_x = FIXED(0.0), cube0_dx = -FIXED(1.7);
      static Fixed32 cube0_y = FIXED(0.0), cube0_dy = -FIXED(1.3);
      static Fixed32 cube0_z = FIXED(413.0), cube0_dz = FIXED(2.7);
      Uint16 i, j;
      Uint16 PolyNumber;
!     GlbXYZ Coord3D[4*MASTR_POLYGON_NUM]; /* ｿｽｿｽｿｽ]ｿｽｿｽｿｽﾌ搾ｿｽｿｽWｿｽfｿｽ[ｿｽ^ｿｽoｿｽbｿｽtｿｽ@ */
!     GlbXYint  Coord2D[4*MASTR_POLYGON_NUM]; /* ｿｽｿｽｿｽｿｽｿｽﾏ奇ｿｽｿｽｿｽｿｽﾌデｿｽ[ｿｽ^ｿｽoｿｽbｿｽtｿｽ@ */
!     Fixed32 zBuff[MASTR_POLYGON_NUM];    /* ｿｽeｿｽｿｽｿｽ_ｿｽｿｽ Z ｿｽlｿｽﾌバｿｽbｿｽtｿｽ@    */
!     Uint16 SortBuff[MASTR_POLYGON_NUM];  /* Z ｿｽlｿｽﾅソｿｽ[ｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽ_ｿｽﾔ搾ｿｽｿｽﾌ包ｿｽｿｽｿｽ */
  
      arg++;
      /* Control cube0 movements. */
***************
*** 462,468 ****
      if((cube0_z >= FIXED(600.2)) || (cube0_z <= FIXED(300.0))){
  	cube0_dz = -cube0_dz;
      }
!     
      /* model0 Matrix calc */
      sp3PushMatrix();
      sp3MoveMatrix(cube0_x, cube0_y, cube0_z);
--- 465,471 ----
      if((cube0_z >= FIXED(600.2)) || (cube0_z <= FIXED(300.0))){
  	cube0_dz = -cube0_dz;
      }
! 
      /* model0 Matrix calc */
      sp3PushMatrix();
      sp3MoveMatrix(cube0_x, cube0_y, cube0_z);
***************
*** 471,478 ****
      sp3RotateMatrixZ(FIXED(arg));
      /* model 0 coord trans */
      sp3CoordTrans(4*NUM_OF_MODEL0_SURF, &model0[0], &Coord3D[0]);
!     
!     /* ポリゴンの Z sort のための z 値（4 頂点の平均 * 4) を得る */
      for(PolyNumber = 0;
  	PolyNumber < MASTR_POLYGON_NUM;
  	PolyNumber++){
--- 474,481 ----
      sp3RotateMatrixZ(FIXED(arg));
      /* model 0 coord trans */
      sp3CoordTrans(4*NUM_OF_MODEL0_SURF, &model0[0], &Coord3D[0]);
! 
!     /* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽ Z sort ｿｽﾌゑｿｽｿｽﾟゑｿｽ z ｿｽlｿｽi4 ｿｽｿｽｿｽ_ｿｽﾌ包ｿｽｿｽｿｽ * 4) ｿｽ得ゑｿｽ */
      for(PolyNumber = 0;
  	PolyNumber < MASTR_POLYGON_NUM;
  	PolyNumber++){
***************
*** 483,493 ****
  		+ Coord3D[PolyNumber*4+3].z;
  	SortBuff[PolyNumber] = PolyNumber;
      }
!     
!     /* 昇順に Z sort */
      zSort(zBuff, SortBuff, MASTR_POLYGON_NUM);
!     
!     /* ソートされた順番に 透視変換 */
      for(i = 0; i < MASTR_POLYGON_NUM; i++){
  	PolyNumber = SortBuff[i];
  	for(j = 0; j < 4; j++){
--- 486,496 ----
  		+ Coord3D[PolyNumber*4+3].z;
  	SortBuff[PolyNumber] = PolyNumber;
      }
! 
!     /* ｿｽｿｽｿｽｿｽｿｽｿｽ Z sort */
      zSort(zBuff, SortBuff, MASTR_POLYGON_NUM);
! 
!     /* ｿｽ\ｿｽ[ｿｽgｿｽｿｽｿｽ黷ｽｿｽｿｽｿｽﾔゑｿｽ ｿｽｿｽｿｽｿｽｿｽﾏ奇ｿｽ */
      for(i = 0; i < MASTR_POLYGON_NUM; i++){
  	PolyNumber = SortBuff[i];
  	for(j = 0; j < 4; j++){
***************
*** 501,518 ****
  				       ,EYEDIST));
  	}
      }
!     /* スプライトコマンド生成, 転送 */
      for(i = 0; i < MAX_POLYGON_NUM/2; i++){
  	PutSpCommand(&Coord2D[i*4], SortBuff, i);
      }
      PutSpEndCommand(MAX_POLYGON_NUM);
!     
      sp3PopMatrix();
  }
  
! void /* スレーブ CPU が、実行する関数 */
    slave(void)
! {	
  /*	95-7-26	unuse
      Uint16 *wp;
  */
--- 504,521 ----
  				       ,EYEDIST));
  	}
      }
!     /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽｿｽ, ｿｽ]ｿｽｿｽ */
      for(i = 0; i < MAX_POLYGON_NUM/2; i++){
  	PutSpCommand(&Coord2D[i*4], SortBuff, i);
      }
      PutSpEndCommand(MAX_POLYGON_NUM);
! 
      sp3PopMatrix();
  }
  
! void /* ｿｽXｿｽｿｽｿｽ[ｿｽu CPU ｿｽｿｽｿｽAｿｽｿｽｿｽsｿｽｿｽｿｽｿｽｿｽﾖ撰ｿｽ */
    slave(void)
! {
  /*	95-7-26	unuse
      Uint16 *wp;
  */
***************
*** 522,531 ****
      static Fixed32 cube1_z = FIXED(412.7), cube1_dz = FIXED(3.7);
      Uint16 i, j;
      Uint16 PolyNumber;
!     GlbXYZ Coord3D[4*SLAV_POLYGON_NUM]; /* 回転後の座標データバッファ */
!     GlbXYint  Coord2D[4*SLAV_POLYGON_NUM]; /* 透視変換後のデータバッファ */
!     Fixed32 zBuff[SLAV_POLYGON_NUM];    /* 各頂点の Z 値のバッファ    */
!     Uint16 SortBuff[SLAV_POLYGON_NUM];  /* Z 値でソートした頂点番号の並び */
  
      arg++;
      /* Control cube1 movements. */
--- 525,534 ----
      static Fixed32 cube1_z = FIXED(412.7), cube1_dz = FIXED(3.7);
      Uint16 i, j;
      Uint16 PolyNumber;
!     GlbXYZ Coord3D[4*SLAV_POLYGON_NUM]; /* ｿｽｿｽｿｽ]ｿｽｿｽｿｽﾌ搾ｿｽｿｽWｿｽfｿｽ[ｿｽ^ｿｽoｿｽbｿｽtｿｽ@ */
!     GlbXYint  Coord2D[4*SLAV_POLYGON_NUM]; /* ｿｽｿｽｿｽｿｽｿｽﾏ奇ｿｽｿｽｿｽｿｽﾌデｿｽ[ｿｽ^ｿｽoｿｽbｿｽtｿｽ@ */
!     Fixed32 zBuff[SLAV_POLYGON_NUM];    /* ｿｽeｿｽｿｽｿｽ_ｿｽｿｽ Z ｿｽlｿｽﾌバｿｽbｿｽtｿｽ@    */
!     Uint16 SortBuff[SLAV_POLYGON_NUM];  /* Z ｿｽlｿｽﾅソｿｽ[ｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽ_ｿｽﾔ搾ｿｽｿｽﾌ包ｿｽｿｽｿｽ */
  
      arg++;
      /* Control cube1 movements. */
***************
*** 553,560 ****
      s_sp3RotateMatrixZ(FIXED(-arg));
      /* cube 1 coord trans */
      s_sp3CoordTrans(4*NUM_OF_MODEL0_SURF, &model0[0], &Coord3D[0]);
!     
!     /* ポリゴンの Z sort のための z 値（4 頂点の平均 * 4) を得る */
      for(PolyNumber = 0;
  	PolyNumber < SLAV_POLYGON_NUM;
  	PolyNumber++){
--- 556,563 ----
      s_sp3RotateMatrixZ(FIXED(-arg));
      /* cube 1 coord trans */
      s_sp3CoordTrans(4*NUM_OF_MODEL0_SURF, &model0[0], &Coord3D[0]);
! 
!     /* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽ Z sort ｿｽﾌゑｿｽｿｽﾟゑｿｽ z ｿｽlｿｽi4 ｿｽｿｽｿｽ_ｿｽﾌ包ｿｽｿｽｿｽ * 4) ｿｽ得ゑｿｽ */
      for(PolyNumber = 0;
  	PolyNumber < SLAV_POLYGON_NUM;
  	PolyNumber++){
***************
*** 565,575 ****
  		+ Coord3D[PolyNumber*4+3].z;
  	SortBuff[PolyNumber] = PolyNumber;
      }
!     
!     /* 昇順に Z sort */
      zSort(zBuff, SortBuff, SLAV_POLYGON_NUM);
!     
!     /* ソートされた順番に 透視変換 */
      for(i = 0; i < SLAV_POLYGON_NUM; i++){
  	PolyNumber = SortBuff[i];
  	for(j = 0; j < 4; j++){
--- 568,578 ----
  		+ Coord3D[PolyNumber*4+3].z;
  	SortBuff[PolyNumber] = PolyNumber;
      }
! 
!     /* ｿｽｿｽｿｽｿｽｿｽｿｽ Z sort */
      zSort(zBuff, SortBuff, SLAV_POLYGON_NUM);
! 
!     /* ｿｽ\ｿｽ[ｿｽgｿｽｿｽｿｽ黷ｽｿｽｿｽｿｽﾔゑｿｽ ｿｽｿｽｿｽｿｽｿｽﾏ奇ｿｽ */
      for(i = 0; i < SLAV_POLYGON_NUM; i++){
  	PolyNumber = SortBuff[i];
  	for(j = 0; j < 4; j++){
***************
*** 583,589 ****
  				       ,EYEDIST));
  	}
      }
!     /* スプライトコマンド生成, 転送 */
      for(i = 0; i < SLAV_POLYGON_NUM; i++){
  	s_PutSpCommand(&Coord2D[i*4], SortBuff, i);
      }
--- 586,592 ----
  				       ,EYEDIST));
  	}
      }
!     /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽｿｽ, ｿｽ]ｿｽｿｽ */
      for(i = 0; i < SLAV_POLYGON_NUM; i++){
  	s_PutSpCommand(&Coord2D[i*4], SortBuff, i);
      }
***************
*** 594,600 ****
  void
    SpFlipVram(void)
  {
!     /* コマンドテーブルを切替える */
      if (BKBank == 1) {
  	*(Uint16 *)(VRAM1) = 0x9 /*(JUMP_NEXT | FUNC_SCLIP)*/;
  	*(Uint16 *)(VRAM1+0x2) = 0;
--- 597,603 ----
  void
    SpFlipVram(void)
  {
!     /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽeｿｽ[ｿｽuｿｽｿｽｿｽｿｽｿｽﾘ替ゑｿｽｿｽｿｽ */
      if (BKBank == 1) {
  	*(Uint16 *)(VRAM1) = 0x9 /*(JUMP_NEXT | FUNC_SCLIP)*/;
  	*(Uint16 *)(VRAM1+0x2) = 0;
***************
*** 605,608 ****
      FWBank = 1 - FWBank; /* 1 -> 0; 0 -> 1 */
      BKBank = 1 - BKBank; /* 1 -> 0; 0 -> 1 */
  }
! 
\ No newline at end of file
--- 608,611 ----
      FWBank = 1 - FWBank; /* 1 -> 0; 0 -> 1 */
      BKBank = 1 - BKBank; /* 1 -> 0; 0 -> 1 */
  }
! 
diff -crBN --binary sbl6/segasmp/dual/spr_mtx3.h sbl6_patch/segasmp/dual/spr_mtx3.h
*** sbl6/segasmp/dual/spr_mtx3.h	1996-02-08 05:28:28.000000000 -0500
--- sbl6_patch/segasmp/dual/spr_mtx3.h	2024-01-20 19:56:24.000000000 -0500
***************
*** 9,14 ****
--- 9,16 ----
   *
   *----------------------------------------------------------------------------
   */
+  
+ #include "sega_spr.h"
  
  #define	PRODUCT(a, b)\
  (MUL_FIXED((a).x, (b).x) + MUL_FIXED((a).y, (b).y) + MUL_FIXED((a).z, (b).z))
diff -crBN --binary sbl6/segasmp/dual/spr_xpt.c sbl6_patch/segasmp/dual/spr_xpt.c
*** sbl6/segasmp/dual/spr_xpt.c	1996-02-08 05:28:28.000000000 -0500
--- sbl6_patch/segasmp/dual/spr_xpt.c	2024-08-18 20:49:00.000000000 -0400
***************
*** 1,16 ****
  /*----------------------------------------------------------------------------
!  *  spr_xpt.c -- SPR ライブラリ XPT モジュール
   *  Copyright(c) 1994 SEGA
   *  Written by H.E on 1994-02-15 Ver.0.80
   *  Updated by H.E on 1994-02-15 Ver.0.80
   *
!  *  このライブラリはスプライト表示処理のマシンに依存するルーチンを含む。
   *
!  *  fxsin                   -  ＳＩＮの計算
!  *  fxcos                   -  ＣＯＳの計算
!  *  dmemcpy                 -  メモリコピー
   *
!  *  このライブラリを使用するには次のインクルードファイルを定義する必要がある。
   *
   *   #include "sega_xpt.h"
   *   #include "sega_spr.h"
--- 1,16 ----
  /*----------------------------------------------------------------------------
!  *  spr_xpt.c -- SPR ｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ XPT ｿｽｿｽｿｽWｿｽｿｽｿｽ[ｿｽｿｽ
   *  Copyright(c) 1994 SEGA
   *  Written by H.E on 1994-02-15 Ver.0.80
   *  Updated by H.E on 1994-02-15 Ver.0.80
   *
!  *  ｿｽｿｽｿｽﾌｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾍスｿｽvｿｽｿｽｿｽCｿｽgｿｽ\ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌマｿｽVｿｽｿｽｿｽﾉ依托ｿｽｿｽｿｽｿｽ驛具ｿｽ[ｿｽ`ｿｽｿｽｿｽｿｽｿｽﾜむ。
   *
!  *  fxsin                   -  ｿｽrｿｽhｿｽmｿｽﾌ計ｿｽZ
!  *  fxcos                   -  ｿｽbｿｽnｿｽrｿｽﾌ計ｿｽZ
!  *  dmemcpy                 -  ｿｽｿｽｿｽｿｽｿｽｿｽｿｽRｿｽsｿｽ[
   *
!  *  ｿｽｿｽｿｽﾌｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽﾉは趣ｿｽｿｽﾌイｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽ`ｿｽｿｽｿｽｿｽｿｽKｿｽvｿｽｿｽｿｽｿｽｿｽｿｽｿｽB
   *
   *   #include "sega_xpt.h"
   *   #include "sega_spr.h"
***************
*** 20,27 ****
--- 20,29 ----
  
  #include "sega_xpt.h"
  #include "sega_spr.h"
+ #include "sl_def.h"
  
  #include	<machine.h>
+ #include  <string.h>
  
  extern Fixed32 fsin(Fixed32 degree);
  extern Fixed32 fcos(Fixed32 degree);
***************
*** 77,82 ****
  }
  
  /*  end of file */
- 
- 
- 
--- 79,81 ----
diff -crBN --binary sbl6/segasmp/fld/smpfld01/exit.c sbl6_patch/segasmp/fld/smpfld01/exit.c
*** sbl6/segasmp/fld/smpfld01/exit.c	1996-02-08 05:28:32.000000000 -0500
--- sbl6_patch/segasmp/fld/smpfld01/exit.c	2022-12-18 13:13:54.000000000 -0500
***************
*** 1,11 ****
  /*****************************************************************************
!  *      デモデモソフトファイルローダ
   *
   *      Copyright (c) 1995 CSK Research Institute Corp.
   *      Copyright (c) 1995 SEGA
   *
   * Library:FLD
!  * Module :終了関数
   * File   :exit.c
   * Date   :1995-08-03
   * Version:1.10
--- 1,11 ----
  /*****************************************************************************
!  *      ｿｽfｿｽｿｽｿｽfｿｽｿｽｿｽ\ｿｽtｿｽgｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽ[ｿｽ_
   *
   *      Copyright (c) 1995 CSK Research Institute Corp.
   *      Copyright (c) 1995 SEGA
   *
   * Library:FLD
!  * Module :ｿｽIｿｽｿｽｿｽﾖ撰ｿｽ
   * File   :exit.c
   * Date   :1995-08-03
   * Version:1.10
***************
*** 14,20 ****
   *****************************************************************************/
  
  /*****************************************************************************
!  *      インクルードファイル
   *****************************************************************************/
  #ifdef	__GNUC__
  	#include <machine.h>
--- 14,20 ----
   *****************************************************************************/
  
  /*****************************************************************************
!  *      ｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽ
   *****************************************************************************/
  #ifdef	__GNUC__
  	#include <machine.h>
***************
*** 28,59 ****
  #include "sega_per.h"
  
  /*****************************************************************************
!  *      定数マクロ
   *****************************************************************************/
! /* 絞り番号 */
! #define FLT_READ        0       /* 作業用 */
! #define FLT_DUMMY       23      /* ルートディレクトリへの移動用 */
! 
! /* タイムアウト値 */
! #define TMOUT_HIRQREQ    2900000    /* HIRQREQのデフォルト :  4s */
! #define TMOUT_IPLTSK    15000000    /* IP読み込みタスク    : 21s */
  
! /* スタックポインタ */
  #define STACKPTR        0x06002000
  
  /*****************************************************************************
!  *      処理マクロ
   *****************************************************************************/
! /* IPロード処理（即時復帰型） */
  #define SYS_IPLGAMECD(dummy) \
              ((**(Sint32 (**)(Sint32))0x600029c)(dummy))
  
! /* IPチェック＆ラン（即時復帰型） */
  #define SYS_RUNGAMECD(dummy) \
              ((**(Sint32 (**)(Sint32))0x6000288)(dummy))
  
  /*****************************************************************************
!  *      関数の宣言
   *****************************************************************************/
  static void restart(void);
  static void execRestart(void);
--- 28,59 ----
  #include "sega_per.h"
  
  /*****************************************************************************
!  *      ｿｽ關費ｿｽ}ｿｽNｿｽｿｽ
   *****************************************************************************/
! /* ｿｽiｿｽｿｽｿｽﾔ搾ｿｽ */
! #define FLT_READ        0       /* ｿｽｿｽｿｽﾆ用 */
! #define FLT_DUMMY       23      /* ｿｽｿｽｿｽ[ｿｽgｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽﾖの移難ｿｽｿｽp */
! 
! /* ｿｽ^ｿｽCｿｽｿｽｿｽAｿｽEｿｽgｿｽl */
! #define TMOUT_HIRQREQ    2900000    /* HIRQREQｿｽﾌデｿｽtｿｽHｿｽｿｽｿｽg :  4s */
! #define TMOUT_IPLTSK    15000000    /* IPｿｽﾇみ搾ｿｽｿｽﾝタｿｽXｿｽN    : 21s */
  
! /* ｿｽXｿｽ^ｿｽbｿｽNｿｽ|ｿｽCｿｽｿｽｿｽ^ */
  #define STACKPTR        0x06002000
  
  /*****************************************************************************
!  *      ｿｽｿｽｿｽｿｽｿｽ}ｿｽNｿｽｿｽ
   *****************************************************************************/
! /* IPｿｽｿｽｿｽ[ｿｽhｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽｿｽｿｽｿｽｿｽAｿｽ^ｿｽj */
  #define SYS_IPLGAMECD(dummy) \
              ((**(Sint32 (**)(Sint32))0x600029c)(dummy))
  
! /* IPｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽｿｽｿｽｿｽｿｽAｿｽ^ｿｽj */
  #define SYS_RUNGAMECD(dummy) \
              ((**(Sint32 (**)(Sint32))0x6000288)(dummy))
  
  /*****************************************************************************
!  *      ｿｽﾖ撰ｿｽｿｽﾌ宣言
   *****************************************************************************/
  static void restart(void);
  static void execRestart(void);
***************
*** 65,91 ****
  static Sint32 setStackptr(Sint32 addr);
  
  /*****************************************************************************
!  *      関数の定義
   *****************************************************************************/
  
  /*
!  * 終了関数
!  * [入力]
!  *      code : 機能コード
!  *           0      : 再起動（IPチェック＆ランの実行）
!  *           1      : マルチプレーヤの起動
!  *           負の値 : 無限ループ
!  *           その他 : 0と同じ（デフォルト）
   */
  void exit(Sint32 code)
  {
      switch(code) {
!     case 1:     /* マルチプレーヤにジャンプ */
          SYS_EXECDMP();
          break;
      default:
          if (code < 0) {
!             for(;;);        /* 負の値の場合は無限ループ */
          }
          restart();
          break;
--- 65,91 ----
  static Sint32 setStackptr(Sint32 addr);
  
  /*****************************************************************************
!  *      ｿｽﾖ撰ｿｽｿｽﾌ抵ｿｽｿｽ`
   *****************************************************************************/
  
  /*
!  * ｿｽIｿｽｿｽｿｽﾖ撰ｿｽ
!  * [ｿｽｿｽｿｽｿｽ]
!  *      code : ｿｽ@ｿｽ\ｿｽRｿｽ[ｿｽh
!  *           0      : ｿｽﾄ起ｿｽｿｽｿｽiIPｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ趣ｿｽｿｽsｿｽj
!  *           1      : ｿｽ}ｿｽｿｽｿｽ`ｿｽvｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ起ｿｽｿｽ
!  *           ｿｽｿｽｿｽﾌ値 : ｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽv
!  *           ｿｽｿｽｿｽﾌ托ｿｽ : 0ｿｽﾆ難ｿｽｿｽｿｽｿｽiｿｽfｿｽtｿｽHｿｽｿｽｿｽgｿｽj
   */
  void exit(Sint32 code)
  {
      switch(code) {
!     case 1:     /* ｿｽ}ｿｽｿｽｿｽ`ｿｽvｿｽｿｽｿｽ[ｿｽｿｽｿｽﾉジｿｽｿｽｿｽｿｽｿｽv */
          SYS_EXECDMP();
          break;
      default:
          if (code < 0) {
!             for(;;);        /* ｿｽｿｽｿｽﾌ値ｿｽﾌ場合ｿｽﾍ厄ｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽv */
          }
          restart();
          break;
***************
*** 93,160 ****
  }
  
  
! /* 再起動実行関数 */
  static void restart(void)
  {
!     /* 割り込み禁止 */
      set_imask(15);
  
!     /* 再起動の実行 */
      execRestart();
  
      /*
!      * マルチプレーヤの起動
!      * （再起動が失敗したときのみ実行される。）
       */
      SYS_EXECDMP();
  }
  
  
! /* 再起動実行関数 */
  static void execRestart(void)
  {
      Sint32  ret;
      Sint32  timer;
  
!     /* デモデモ実行中以外ならマルチプレーヤを実行 */
      if (GFS_IS_DDS() == FALSE) {
          return;
      }
  
!     /* マシンの初期化 */
      initSaturn();
  
!     /* CDのソフトリセット */
      if (resetCd() != OK) {
          return;
      }
  
!     /* IPロードの開始 */
      ret = SYS_IPLGAMECD(0);
      if (ret != OK) {
          return;
      }
  
!     /* IPチェック＆ラン処理 */
      execIpChkRun();
  }
  
  
! /* マシンの初期化 */
  static void initSaturn(void)
  {
!     /* SMPCの終了待ち＆スレーブCPUの停止 */
      PER_SMPC_SSH_OFF();
  
!     /* 26MHzにクロックチェンジ */
      SYS_CHGSYSCK(0);
  }
  
  
! /* CDのソフトリセット */
  static Sint32 resetCd(void)
  {
!     /* ソフトリセット＆終了待ち */
      if (CDC_CdInit(1, 0, 0, 0) != CDC_ERR_OK) {
          return NG;
      }
--- 93,160 ----
  }
  
  
! /* ｿｽﾄ起ｿｽｿｽｿｽｿｽｿｽsｿｽﾖ撰ｿｽ */
  static void restart(void)
  {
!     /* ｿｽｿｽｿｽ闕橸ｿｽﾝ禁止 */
      set_imask(15);
  
!     /* ｿｽﾄ起ｿｽｿｽｿｽﾌ趣ｿｽｿｽs */
      execRestart();
  
      /*
!      * ｿｽ}ｿｽｿｽｿｽ`ｿｽvｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ起ｿｽｿｽ
!      * ｿｽiｿｽﾄ起ｿｽｿｽｿｽｿｽｿｽｿｽｿｽsｿｽｿｽｿｽｿｽｿｽﾆゑｿｽｿｽﾌみ趣ｿｽｿｽsｿｽｿｽｿｽｿｽｿｽｿｽｿｽBｿｽj
       */
      SYS_EXECDMP();
  }
  
  
! /* ｿｽﾄ起ｿｽｿｽｿｽｿｽｿｽsｿｽﾖ撰ｿｽ */
  static void execRestart(void)
  {
      Sint32  ret;
      Sint32  timer;
  
!     /* ｿｽfｿｽｿｽｿｽfｿｽｿｽｿｽｿｽｿｽsｿｽｿｽｿｽﾈ外ｿｽﾈゑｿｽｿｽ}ｿｽｿｽｿｽ`ｿｽvｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽs */
      if (GFS_IS_DDS() == FALSE) {
          return;
      }
  
!     /* ｿｽ}ｿｽVｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
      initSaturn();
  
!     /* CDｿｽﾌソｿｽtｿｽgｿｽｿｽｿｽZｿｽbｿｽg */
      if (resetCd() != OK) {
          return;
      }
  
!     /* IPｿｽｿｽｿｽ[ｿｽhｿｽﾌ開ｿｽn */
      ret = SYS_IPLGAMECD(0);
      if (ret != OK) {
          return;
      }
  
!     /* IPｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
      execIpChkRun();
  }
  
  
! /* ｿｽ}ｿｽVｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  static void initSaturn(void)
  {
!     /* SMPCｿｽﾌ終ｿｽｿｽｿｽﾒゑｿｽｿｽｿｽｿｽXｿｽｿｽｿｽ[ｿｽuCPUｿｽﾌ抵ｿｽｿｽ~ */
      PER_SMPC_SSH_OFF();
  
!     /* 26MHzｿｽﾉクｿｽｿｽｿｽbｿｽNｿｽ`ｿｽFｿｽｿｽｿｽW */
      SYS_CHGSYSCK(0);
  }
  
  
! /* CDｿｽﾌソｿｽtｿｽgｿｽｿｽｿｽZｿｽbｿｽg */
  static Sint32 resetCd(void)
  {
!     /* ｿｽ\ｿｽtｿｽgｿｽｿｽｿｽZｿｽbｿｽgｿｽｿｽｿｽIｿｽｿｽｿｽﾒゑｿｽ */
      if (CDC_CdInit(1, 0, 0, 0) != CDC_ERR_OK) {
          return NG;
      }
***************
*** 162,175 ****
          return NG;
      }
  
!     /* 形式的なルートディレクトリへの移動処理 */
      chgDirRootDummy();
  
      return OK;
  }
  
  
! /* 割り込み要因レジスタのビットが1になるまで待つ */
  static Sint32 waitHirq(Sint32 flag)
  {
      Sint32  i;
--- 162,175 ----
          return NG;
      }
  
!     /* ｿｽ`ｿｽｿｽｿｽIｿｽﾈｿｽｿｽ[ｿｽgｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽﾖの移難ｿｽｿｽｿｽｿｽｿｽ */
      chgDirRootDummy();
  
      return OK;
  }
  
  
! /* ｿｽｿｽｿｽ闕橸ｿｽﾝ要ｿｽｿｽｿｽｿｽｿｽWｿｽXｿｽ^ｿｽﾌビｿｽbｿｽgｿｽｿｽ1ｿｽﾉなゑｿｽｿｽﾜで待ゑｿｽ */
  static Sint32 waitHirq(Sint32 flag)
  {
      Sint32  i;
***************
*** 183,189 ****
  }
  
  
! /* 形式的なルートディレクトリへの移動処理 */
  static void chgDirRootDummy(void)
  {
      CDC_ChgDir(FLT_DUMMY, CDC_NUL_FID);
--- 183,189 ----
  }
  
  
! /* ｿｽ`ｿｽｿｽｿｽIｿｽﾈｿｽｿｽ[ｿｽgｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽﾖの移難ｿｽｿｽｿｽｿｽｿｽ */
  static void chgDirRootDummy(void)
  {
      CDC_ChgDir(FLT_DUMMY, CDC_NUL_FID);
***************
*** 194,210 ****
  }
  
  
! /* IPチェック＆ラン処理 */
! /* （決してリターンしない関数） */
  static void execIpChkRun(void)
  {
!     /* スタックポインタの保存 */
      static Sint32   savesp;
  
      register Sint32 timer;
      register Sint32 ret;
  
!     /* スタックの設定 */
      savesp = setStackptr(STACKPTR);
  
      timer = 0;
--- 194,210 ----
  }
  
  
! /* IPｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
! /* ｿｽiｿｽｿｽｿｽｿｽｿｽﾄｿｽｿｽ^ｿｽ[ｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽﾖ撰ｿｽｿｽj */
  static void execIpChkRun(void)
  {
!     /* ｿｽXｿｽ^ｿｽbｿｽNｿｽ|ｿｽCｿｽｿｽｿｽ^ｿｽﾌ保托ｿｽ */
      static Sint32   savesp;
  
      register Sint32 timer;
      register Sint32 ret;
  
!     /* ｿｽXｿｽ^ｿｽbｿｽNｿｽﾌ設抵ｿｽ */
      savesp = setStackptr(STACKPTR);
  
      timer = 0;
***************
*** 218,247 ****
          }
      }
  
!     /* スタックを戻す（不要であるが念のため） */
      setStackptr(savesp);
  
!     /* マルチプレーヤの起動 */
      SYS_EXECDMP();
  }
  
  
  /*
!  * スタックの設定
!  * [入力]
!  *      addr : 設定するスタックポインタ
!  * [関数値]
!  *      設定変更前のスタックポインタの値を返す
   */
  /*	1995-10-02	N.K	*/
  #ifdef	__GNUC__
  
  static Sint32 setStackptr(Sint32 addr)
  {
! 	asm("
!           mov       r15, r0
!           mov       r4, r15
! 	");
  }
  
  #else
--- 218,245 ----
          }
      }
  
!     /* ｿｽXｿｽ^ｿｽbｿｽNｿｽｿｽｿｽﾟゑｿｽｿｽiｿｽsｿｽvｿｽﾅゑｿｽｿｽ驍ｪｿｽOｿｽﾌゑｿｽｿｽﾟ） */
      setStackptr(savesp);
  
!     /* ｿｽ}ｿｽｿｽｿｽ`ｿｽvｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ起ｿｽｿｽ */
      SYS_EXECDMP();
  }
  
  
  /*
!  * ｿｽXｿｽ^ｿｽbｿｽNｿｽﾌ設抵ｿｽ
!  * [ｿｽｿｽｿｽｿｽ]
!  *      addr : ｿｽﾝ定すｿｽｿｽｿｽXｿｽ^ｿｽbｿｽNｿｽ|ｿｽCｿｽｿｽｿｽ^
!  * [ｿｽﾖ撰ｿｽｿｽl]
!  *      ｿｽﾝ抵ｿｽｿｽﾏ更ｿｽOｿｽﾌスｿｽ^ｿｽbｿｽNｿｽ|ｿｽCｿｽｿｽｿｽ^ｿｽﾌ値ｿｽｿｽｿｽﾔゑｿｽ
   */
  /*	1995-10-02	N.K	*/
  #ifdef	__GNUC__
  
  static Sint32 setStackptr(Sint32 addr)
  {
! 	asm("mov       r15, r0\n"
!       "mov       r4, r15");
  }
  
  #else
***************
*** 256,259 ****
  #endif
  
  /* end of file */
- 
\ No newline at end of file
--- 254,256 ----
diff -crBN --binary sbl6/segasmp/fld/smpfld01/smpfld01.c sbl6_patch/segasmp/fld/smpfld01/smpfld01.c
*** sbl6/segasmp/fld/smpfld01/smpfld01.c	1996-02-08 05:28:36.000000000 -0500
--- sbl6_patch/segasmp/fld/smpfld01/smpfld01.c	2024-08-01 15:45:36.000000000 -0400
***************
*** 1,80 ****
  /*****************************************************************************
!  *      ソフトウェアライブラリ
!  *
!  *      Copyright (c) 1994 SEGA
!  *
!  * Library: ファイルローダ
!  * Module : サンプル１
!  * File   : smpfld01.c
!  * Date   : 1995-10-02
!  * Version: 1.00
!  * Auther : N.K
!  *
!  *      ゲームの単純な起動。
!  *
!  *****************************************************************************/
  
! /*****************************************************************************
!  *      インクルードファイル
!  *****************************************************************************/
  #include <sega_gfs.h>
  #include <fld_load.h>
  
  /*****************************************************************************
!  *      定数マクロ
!  *****************************************************************************/
! /* 同時にオープンするファイルの数 */
! #define MAX_OPEN        2
  
! /* ルートディレクトリにあるファイル数 */
! #define MAX_DIR         10
  
! /* アクセスするファイル名 */
! #define FNAME           "SAMP_IP.BIN"
  
  /*****************************************************************************
!  *      関数の宣言
!  *****************************************************************************/
  extern	void	exit(Sint32);
  /*****************************************************************************
!  *      変数の定義
!  *****************************************************************************/
! /* ライブラリ作業領域 */
  Uint32 lib_work[GFS_WORK_SIZE(MAX_OPEN) / sizeof(Uint32)];
  
! /* ディレクトリ情報管理領域 */
! GfsDirTbl dirtbl; 
  
! /* ディレクトリ情報格納領域 */
  GfsDirName dirname[MAX_DIR];
  
  /*****************************************************************************
!  *      関数の定義
!  *****************************************************************************/
! Sint32 main()
  {
!     Sint32 ret;
! 	Sint32 tno = 2;				/* ＣＤ−ＤＡの先頭トラック番号 */
! 
!     /* ディレクトリ情報管理領域のsetup */
! 	*((Uint32 *)GFS_DDS_ADDR) = 0x20202020;
!     GFS_DIRTBL_TYPE(&dirtbl) = GFS_DIR_NAME;
!     GFS_DIRTBL_DIRNAME(&dirtbl) = dirname;
!     GFS_DIRTBL_NDIR(&dirtbl) = MAX_DIR;
! 
!     /* ファイルシステムの初期化 */
!     ret = GFS_Init(MAX_OPEN, lib_work, &dirtbl);
!     if (ret <= 0) {
! 		/*	失敗すると、自分自身を起動する */
! 		exit(0);
      }
  
-     /* ゲームを起動する */
- 	ret = FLD_ExecGame(FNAME,tno);
- 	if (ret == NG) {
- 		/*	失敗すると、マルチプレイヤーに戻る */
- 		exit(1);
- 	}
      return 0;
! }
! 
\ No newline at end of file
--- 1,142 ----
  /*****************************************************************************
! *      ｿｽ\ｿｽtｿｽgｿｽEｿｽFｿｽAｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ
! *
! *      Copyright (c) 1994 SEGA
! *
! * Library: ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽ[ｿｽ_
! * Module : ｿｽTｿｽｿｽｿｽvｿｽｿｽｿｽP
! * File   : smpfld01.c
! * Date   : 1995-10-02
! * Version: 1.00
! * Auther : N.K
! *
! *      ｿｽQｿｽ[ｿｽｿｽｿｽﾌ単ｿｽｿｽｿｽﾈ起ｿｽｿｽｿｽB
! *
! *****************************************************************************/
! 
! /*****************************************************************************
! *      ｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽtｿｽ@ｿｽCｿｽｿｽ
! *****************************************************************************/
! #include <stdio.h>
  
! #include <machine.h>
  #include <sega_gfs.h>
  #include <fld_load.h>
+ #include <sega_int.h>
+ #include <sega_scl.h>
+ 
+ #define BITMAP_PIXEL_WIDTH  352
+ #define BITMAP_PIXEL_HEIGHT 240
+ #define	NBG1_VDP2_VRAM_BASE_ADDR	SCL_VDP2_VRAM_B0
+ #define GAME_BY_PAGE 7
+ 
+ void	ClrVram(volatile Uint8 *buff)
+ {
+ 	Uint32	i;
+ 
+ 	for(i=0;i<(512 * 512);i++)	buff[i]=0x00;
+ }
  
  /*****************************************************************************
! *      ｿｽ關費ｿｽ}ｿｽNｿｽｿｽ
! *****************************************************************************/
! /* ｿｽｿｽｿｽｿｽｿｽﾉオｿｽ[ｿｽvｿｽｿｽｿｽｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ撰ｿｽ */
! #define MAX_OPEN        4
! 
! /* ｿｽｿｽｿｽ[ｿｽgｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽﾉゑｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽ */
! #define MAX_DIR         20
! 
! 
! //--------------------------------------------------------------------------------------------------------------
! void VDP2_InitVRAM(void)
! {
! 	/* Variables. */
! 
! 	Uint32	loop;
! 	Uint32	maxloop;
! 
! 	/* Code. */
! 
! 	/* Fascist clear of all VDP2 VRAM */
  
! 	loop = 0;
! 	maxloop = 512*1024;
  
! 	while (loop < maxloop)
! 	{
! 		*((Uint32 *) (SCL_VDP2_VRAM_A0 + loop)) = 0;
! 
! 		loop += 4;
! 	}
! 
! 	/* Now set layer NBG1 to be a nice blue colour */
! 
! 	loop = 0;
! 	maxloop = BITMAP_PIXEL_WIDTH * BITMAP_PIXEL_HEIGHT;
! 
! 	while (loop < maxloop)
! 	{
! 		*((Uint8 *) (NBG1_VDP2_VRAM_BASE_ADDR + loop)) = 1;
! 
! 		loop += 1;
! 	}
! 
! }
  
  /*****************************************************************************
! *      ｿｽﾖ撰ｿｽｿｽﾌ宣言
! *****************************************************************************/
  extern	void	exit(Sint32);
  /*****************************************************************************
! *      ｿｽﾏ撰ｿｽｿｽﾌ抵ｿｽｿｽ`
! *****************************************************************************/
! /* ｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾆ領茨ｿｽ */
  Uint32 lib_work[GFS_WORK_SIZE(MAX_OPEN) / sizeof(Uint32)];
  
! /* ｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾌ茨ｿｽ */
! GfsDirTbl dirtbl;
  
! /* ｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽiｿｽ[ｿｽﾌ茨ｿｽ */
  GfsDirName dirname[MAX_DIR];
  
  /*****************************************************************************
! *      ｿｽﾖ撰ｿｽｿｽﾌ抵ｿｽｿｽ`
! *****************************************************************************/
! int main()
  {
!   Sint32 ret;
!   Sint32 tno = 2;				/* ｿｽbｿｽcｿｽ|ｿｽcｿｽ`ｿｽﾌ先頭ｿｽgｿｽｿｽｿｽbｿｽNｿｽﾔ搾ｿｽ */
!   char FOLDERNAME[20], FNAME[20];
! 
!   /* ｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾌ茨ｿｽｿｽｿｽsetup */
!   *((Uint32 *)GFS_DDS_ADDR) = 0x20202020;
!   GFS_DIRTBL_TYPE(&dirtbl) = GFS_DIR_NAME;
!   GFS_DIRTBL_DIRNAME(&dirtbl) = dirname;
!   GFS_DIRTBL_NDIR(&dirtbl) = MAX_DIR;
! 
!   /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
!   ret = GFS_Init(MAX_OPEN, lib_work, &dirtbl);
!   if (ret <= 0) {
!      while(1);
!     /*	ｿｽｿｽｿｽsｿｽｿｽｿｽｿｽｿｽﾆ、ｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽｿｽｿｽNｿｽｿｽｿｽｿｽｿｽｿｽ */
!     exit(0);
!   }
! 
!   sprintf(FOLDERNAME,"TEST");
!   sprintf(FNAME,"TEST.BIN");
! 
!   INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT  |INT_MSK_PAD);
! 
!   /* ｿｽQｿｽ[ｿｽｿｽｿｽｿｽｿｽNｿｽｿｽｿｽｿｽｿｽｿｽ */
!   ret = FLD_ExecGame(	FNAME,
!                       FOLDERNAME,
!                       tno);
!     if (ret == NG) {
!        while(1);
!       /*	ｿｽｿｽｿｽsｿｽｿｽｿｽｿｽｿｽﾆ、ｿｽ}ｿｽｿｽｿｽ`ｿｽvｿｽｿｽｿｽCｿｽｿｽｿｽ[ｿｽﾉ戻ゑｿｽ */
!       exit(1);
      }
  
      return 0;
!   }
!   
diff -crBN --binary sbl6/segasmp/game/act.c sbl6_patch/segasmp/game/act.c
*** sbl6/segasmp/game/act.c	1996-02-08 05:28:38.000000000 -0500
--- sbl6_patch/segasmp/game/act.c	2022-09-24 09:08:36.000000000 -0400
***************
*** 1,365 ****
  /*----------------------------------------------------------------------*/
  /*	ＳＢＬ６サンプルゲームだよーん										*/
  /*----------------------------------------------------------------------*/
! 
! #include	"act.h"
! #include	"sega_scl.h"
! #include	"sega_dbg.h"
! #include	"sample.h"
! #include	"game.h"
! 
! 
! Uint16	endtimer=0,endflg=0;
! 
! extern	trigger_t	pltrigger[];
! extern	Uint16	fadetimer;
! 
! /*FIGHTER	*p1,*p2;*/
! FIGHTER	f[2];
! BULLET	b[2][_BULLETS];
! ONEPLANE	p[6];
! FIGHTER	*pt[] = { &f[1],&f[0] };
! PDATA	PDcube[2];
! PDATA	*PDlist[] = { &PD_CUBE1 , &PD_CUBE2 };
! PDATA	* const _PDplane[] = {
! 			&PD_BREAK1,
! 			&PD_BREAK2,
! 			&PD_BREAK3,
! 			&PD_BREAK4,
! 			&PD_BREAK5,
! 			&PD_BREAK6
! 		};
! 
! const short	spdtbl[6][XYZ]	= {
! 				{  0 , -2 ,  1 },
! 				{ -1 ,  0 ,  0 },
! 				{  0 , -2 , -1 },
! 				{  1 ,  0 ,  0 },
! 				{  0 , -1 ,  0 },
! 				{  0 ,  1 ,  0 }
! 			};
! const ANGLE	rottbl[6][XYZ]	={
! 				{DEGtoANG(-10.0 ),DEGtoANG(-10.0 ),DEGtoANG(  0.0 )},
! 				{DEGtoANG(  0.0 ),DEGtoANG( 10.0 ),DEGtoANG(-10.0 )},
! 				{DEGtoANG( 10.0 ),DEGtoANG( 10.0 ),DEGtoANG(  0.0 )},
! 				{DEGtoANG(  0.0 ),DEGtoANG( 10.0 ),DEGtoANG( 10.0 )},
! 				{DEGtoANG( 10.0 ),DEGtoANG(  0.0 ),DEGtoANG( 10.0 )},
! 				{DEGtoANG(-10.0 ),DEGtoANG(  0.0 ),DEGtoANG(-10.0 )}
! 			};
! 
! unsigned short	flash_color[] = {	/* Flashの色	*/
! 			C_RGB(25,28,30),
! 			C_RGB(25,25,30),
! 			C_RGB(25,28,30),
! 			C_RGB(25,25,30),
! 			C_RGB(30,30,25),
! 			C_RGB(30,30,25)
! 			};
! unsigned short	org_color[] = {	/* 元の色	*/
! 			C_RGB( 6,16,25),
! 			C_RGB( 6, 6,25),
! 			C_RGB( 6,16,25),
! 			C_RGB( 6, 6,25),
! 			C_RGB(20,20,10),
! 			C_RGB(20,20,10)
! 			};
! 
! 
! #define	TRG_FIRE	(TRG_A|TRG_B)
! 
! #define	resetplayer( sts )	\
! 	do{						\
! 		sts->shotwait = 0;	\
! 		sts->collision = 0;	\
! 		sts->hitpoint = 3;	\
! 		endtimer = 0;		\
! 		endflg = 0;			\
! 	}while(0)
! 
! 
! 
! void	player(	FIGHTER	*sts ){
! 	int	i,j;
! 	trigger_t	myswitch = pltrigger[sts->id];
! 
! 	if(( myswitch & TRG_C) != 0 ){
! 		resetplayer( sts );
! 	}
! 
! 	if( sts->hitpoint != 0 ){					/* 生きている */
! 		if( sts->shotwait == 0 ){				/* 攻撃 */
! 			if( ( myswitch & TRG_FIRE ) != 0 ){
! 				for( i = 0 ; i < _BULLETS ; i++ ){
! 					if( sts->myb[i]->busy == 0 ){
! 						FIXED	speed = _BULLETSPEED;
! 						ANGLE	rotate = _BULLETROT;
! 						for( j = X ; j < XYZ ; j++){
! 							sts->myb[i]->pos[j] = sts->pos[j];
! 						}
! 						sts->myb[i]->busy = 1;
! 						sts->myb[i]->target = pt[sts->id];
! 						if( sts->pos[X] > 0 ){
! 							speed *= -1;
! 							rotate *= -1;
! 						}
! 						sts->myb[i]->spd[X] = speed;
! 						sts->myb[i]->rot[Z] = rotate;
! 						sts->shotwait = _SHOTINTERVAL;
! 						break;
! 					}
! 				}
! 			}
! 		}
! 		else{
! 			if( --sts->shotwait < 0 )
! 				sts->shotwait = 0;
! 		}
! 
! 		if( sts->collision == 0 ){				/* 被弾 */
! 			if( sts->hit != 0){
! 				sts->collision = _NODAMAGE;
! 				if( --sts->hitpoint == 0 )
! 					break_init( sts->ang,sts->pos );
! 			}
! 		}
! 		else{	/*無敵*/
! 			if( --sts->collision < 0 )
! 				sts->collision = 0;
! 			else{
! 				unsigned short	*pCOLOR;
! 				if( sts->collision & 0x01 )
! 					pCOLOR = flash_color;
! 				else
! 					pCOLOR = org_color;
! 				for( i = 0 ; i < 6 ; i++ )
! 					sts->pd->attbl[i].colno = pCOLOR[i];
! 			}
! 		}
! 		sts->hit = 0;
! 
  		slPushMatrix();							/* 表示 */
! 		spr_move( myswitch,sts->pos,sts->ang);
  		set_poly(sts->ang , sts->pos);
  		slPutPolygon( sts->pd );
  		slPopMatrix();
! 
! 	}
! 	else{	/* 死んでる */
! 		spr_break();	/* 爆発 */
! 	}
! }
! 
! 
! 
! void _obje1_act(void){
! 	player( &f[0] );
! }
! 
! void _obje2_act(void){
! 	player( &f[1] );
! }
! 
! 
! void	bullet( BULLET	*sts ){
! 	if( sts->busy != 0 ){
! 		FIXED	distance;
! 		if( ( distance = sts->pos[X] ) < 0 )
! 			distance *= -1;
! 
! 		if( toFIXED( 280.0 ) > distance ){
! 			sts->pos[X] += sts->spd[X];
! 			sts->ang[Z] += sts->rot[Z];
! 
  			slPushMatrix();
  			set_poly( sts->ang, sts->pos );
  			slPutPolygon( sts->pd );
  			slPopMatrix();
! 		}
! 		else{
! 			sts->busy = 0;
! 			return;
! 		}
! 		if( sts->target->hitpoint != 0 ){
! 			if( spr_col( sts->pos , sts->target->pos ) ){
! 				sts->target->hit++;
! 				/*	sts->busy = 0;	*/
! 			}
! 		}
! 	}
! }
! 
! 
! void _shot1_1_act(void){
! 	int	i;
! 	for( i = 0 ; i < _BULLETS ; i++)
! 		bullet( &b[0][i] );
! }
! void _shot1_2_act(void){
! 	;
! }
! void _shot2_1_act(void){
! 	int	i;
! 	for( i = 0 ; i < _BULLETS ; i++)
! 		bullet( &b[1][i] );
! }
! void _shot2_2_act(void){
! 	;
! }
! 
! void	rot_player( int	idnum ){
! 	/* 自転	*/
! 	f[idnum].ang[Y] += DEGtoANG( 12.0 );
! 	f[idnum].ang[Z] += DEGtoANG(  2.0 );
  	slPushMatrix();
  	set_poly( f[idnum].ang , f[idnum].pos );
  	slPutPolygon( f[idnum].pd );
  	slPopMatrix();
! }
! 
! void _obje1_demo(void){
! 	rot_player( 0 );
! }
! 
! void _obje2_demo(void){
! 	rot_player( 1 );
! }
! 
! 
! 
! void	init_objects( void ){
! 	int	i,j;
! 	endtimer = 0;
! 	endflg = 0;
! 
  	/* 自機オブジェの初期ポジション	*/
  	f[0].ang[X] = f[1].ang[X] = DEGtoANG( 0.0 );
  	f[0].ang[Y] = f[1].ang[Y] = DEGtoANG( 0.0 );
  	f[0].ang[Z] = f[1].ang[Z] = DEGtoANG( 0.0 );
! 
  	f[0].id = 0;
  	f[1].id = 1;
! 
! 	f[0].shotwait  = f[1].shotwait = 0;
! 	f[0].collision = f[1].collision = 0;
! 	f[0].hitpoint  = f[1].hitpoint = 3;
! 
  	f[0].pos[X] = toFIXED(-130.0 );
  	f[0].pos[Y] = toFIXED(   0.0 );
  	f[0].pos[Z] = toFIXED( 240.0 );
! 
  	f[1].pos[X] = toFIXED( 130.0);
  	f[1].pos[Y] = toFIXED(   0.0);
  	f[1].pos[Z] = toFIXED( 240.0);
! 
! 	for( i = 0 ; i < 2 ; i++ ){
! 		unsigned char	*src,*dst;
! 		src = ( unsigned char * )PDlist[i];
! 		dst = ( unsigned char * )&PDcube[i];
! 		f[i].pd = &PDcube[i];
! 		for( j = 0 ; j < ( int )sizeof( PDATA ) ; j++ )
! 			*dst++ = *src++;
! 		for( j = 0 ; j < _BULLETS ; j++ )
! 			f[i].myb[j] = &b[i][j];
! 	}
! 
! 
! 	/* ショット弾の初期ポジション	*/
! 	for( i = 0 ; i < 2 ; i++ ){
! 		for( j = 0 ; j < _BULLETS ; j++ ){
  			b[i][j].ang[X] = b[i][j].ang[Y] = b[i][j].ang[Z] = DEGtoANG( 0.0 );
  			b[i][j].pos[X] = b[i][j].pos[Y] = b[i][j].pos[Z] = toFIXED( 0.0 );
  			b[i][j].busy = 0;
  			b[i][j].pd = &PD_PLANE1;
! 			b[i][j].id = ( i << 12 ) + ( j << 8 ) + i*_BULLETS + j;
! 		}
! 	}
! 
! 	/* 飛び散るポリゴンの初期ポジション	*/
! 	for( i = 0 ; i < 6 ; i++ ){
! 		p[i].ang[X] = p[i].ang[Y] = p[i].ang[Z] = DEGtoANG( 0.0);
! 		p[i].pos[X] = p[i].pos[Y] = p[i].pos[Z] = toFIXED( 0.0);
! 		p[i].pd = _PDplane[i];
! 		for( j = X ; j < XYZ ; j++ ){
! 			p[i].spd[j] = spdtbl[i][j];
! 			p[i].rot[j] = rottbl[i][j];
! 		}
! 	}
! }
! 
! 
! 
! /* 破壊後の初期化	*/
  void break_init(ANGLE ang[XYZ],FIXED pos[XYZ]){
! 	int	i,j;
! 	for( i = 0 ; i < 6 ; i++ ){
! 		for( j = X ; j < XYZ ; j++ ){
! 			p[i].ang[j] = ang[j];
! 			p[i].pos[j] = pos[j];
! 		}
! 	}
! }
! 
! /* ポリゴンが飛び散る	*/
! void spr_break(void){
! 	static Uint16 c1,c2,c3,c4,c5;
! 	FIXED	x = toFIXED( fadetimer )/6;
! 	int	i,j;
! 	for( i = 0 ; i < 6 ; i++ ){
! 		for( j = X ; j < XYZ ; j ++ ){
! 			switch( abs( p[i].spd[j] ) ){
! 				case 0:
! 					break;
! 				case 1:
! 					p[i].pos[j] +=  x *  p[i].spd[j];
! 					break;
! 				case 2:
! 					p[i].pos[j] +=  p[i].spd[j];
! 					break;
! 				default:
! 					break;
! 			}
! 			p[i].ang[j] += p[i].rot[j];
! 
! 		}
  	 	slPushMatrix();
  		set_poly( p[i].ang,p[i].pos );
  		slPutPolygon( p[i].pd );
  		slPopMatrix();
! 	}
! 
! 	if( ++endtimer == 90 )
! 		endflg=1;					/* ゲーム終了	*/
! 
! 	if(fadetimer >0)
! 		fadetimer--;
! 
! 	c1 =  6 * fadetimer/60;
! 	c2 = 25 * fadetimer/60;
! 	c3 = 16 * fadetimer/60;
! 	c4 = 10 * fadetimer/60;
! 	c5 = 20 * fadetimer/60;
! 	attribute_BREAK[0].colno=C_RGB(c1,c1,c2);
! 	attribute_BREAK[1].colno=C_RGB(c1,c3,c2);
! 	attribute_BREAK[2].colno=C_RGB(c5,c5,c4);
! }
! 
! void	_pause_act( void ){
! 	int	i,j;
! 	for( i = 0 ; i < 2 ; i++){
  		slPushMatrix();							/* 表示 */
  		set_poly( f[i].ang , f[i].pos );
  		slPutPolygon( f[i].pd );
  		slPopMatrix();
! 	}
! 	for( i = 0 ; i < 2 ; i++){
! 		for( j = 0 ; j < _BULLETS ; j++ ){
! 			if( b[i][j].busy != 0 ){
  				slPushMatrix();							/* 表示 */
  				set_poly( b[i][j].ang , b[i][j].pos );
  				slPutPolygon( &PD_PLANE1 );
! 				slPopMatrix();
  			}
! 		}
! 	}
! }
! 
\ No newline at end of file
--- 1,366 ----
  /*----------------------------------------------------------------------*/
  /*	ＳＢＬ６サンプルゲームだよーん										*/
  /*----------------------------------------------------------------------*/
! 
! #include	"act.h"
! #include	"sega_scl.h"
! #include	"sega_dbg.h"
! #include	"sample.h"
! #include	"game.h"
! 
! #include 	<stdlib.h>
! 
! Uint16	endtimer=0,endflg=0;
! 
! extern	trigger_t	pltrigger[];
! extern	Uint16	fadetimer;
! 
! /*FIGHTER	*p1,*p2;*/
! FIGHTER	f[2];
! BULLET	b[2][_BULLETS];
! ONEPLANE	p[6];
! FIGHTER	*pt[] = { &f[1],&f[0] };
! PDATA	PDcube[2];
! PDATA	*PDlist[] = { &PD_CUBE1 , &PD_CUBE2 };
! PDATA	* const _PDplane[] = {
! 			&PD_BREAK1,
! 			&PD_BREAK2,
! 			&PD_BREAK3,
! 			&PD_BREAK4,
! 			&PD_BREAK5,
! 			&PD_BREAK6
! 		};
! 
! const short	spdtbl[6][XYZ]	= {
! 				{  0 , -2 ,  1 },
! 				{ -1 ,  0 ,  0 },
! 				{  0 , -2 , -1 },
! 				{  1 ,  0 ,  0 },
! 				{  0 , -1 ,  0 },
! 				{  0 ,  1 ,  0 }
! 			};
! const ANGLE	rottbl[6][XYZ]	={
! 				{DEGtoANG(-10.0 ),DEGtoANG(-10.0 ),DEGtoANG(  0.0 )},
! 				{DEGtoANG(  0.0 ),DEGtoANG( 10.0 ),DEGtoANG(-10.0 )},
! 				{DEGtoANG( 10.0 ),DEGtoANG( 10.0 ),DEGtoANG(  0.0 )},
! 				{DEGtoANG(  0.0 ),DEGtoANG( 10.0 ),DEGtoANG( 10.0 )},
! 				{DEGtoANG( 10.0 ),DEGtoANG(  0.0 ),DEGtoANG( 10.0 )},
! 				{DEGtoANG(-10.0 ),DEGtoANG(  0.0 ),DEGtoANG(-10.0 )}
! 			};
! 
! unsigned short	flash_color[] = {	/* Flashの色	*/
! 			C_RGB(25,28,30),
! 			C_RGB(25,25,30),
! 			C_RGB(25,28,30),
! 			C_RGB(25,25,30),
! 			C_RGB(30,30,25),
! 			C_RGB(30,30,25)
! 			};
! unsigned short	org_color[] = {	/* 元の色	*/
! 			C_RGB( 6,16,25),
! 			C_RGB( 6, 6,25),
! 			C_RGB( 6,16,25),
! 			C_RGB( 6, 6,25),
! 			C_RGB(20,20,10),
! 			C_RGB(20,20,10)
! 			};
! 
! 
! #define	TRG_FIRE	(TRG_A|TRG_B)
! 
! #define	resetplayer( sts )	\
! 	do{						\
! 		sts->shotwait = 0;	\
! 		sts->collision = 0;	\
! 		sts->hitpoint = 3;	\
! 		endtimer = 0;		\
! 		endflg = 0;			\
! 	}while(0)
! 
! 
! 
! void	player(	FIGHTER	*sts ){
! 	int	i,j;
! 	trigger_t	myswitch = pltrigger[sts->id];
! 
! 	if(( myswitch & TRG_C) != 0 ){
! 		resetplayer( sts );
! 	}
! 
! 	if( sts->hitpoint != 0 ){					/* 生きている */
! 		if( sts->shotwait == 0 ){				/* 攻撃 */
! 			if( ( myswitch & TRG_FIRE ) != 0 ){
! 				for( i = 0 ; i < _BULLETS ; i++ ){
! 					if( sts->myb[i]->busy == 0 ){
! 						FIXED	speed = _BULLETSPEED;
! 						ANGLE	rotate = _BULLETROT;
! 						for( j = X ; j < XYZ ; j++){
! 							sts->myb[i]->pos[j] = sts->pos[j];
! 						}
! 						sts->myb[i]->busy = 1;
! 						sts->myb[i]->target = pt[sts->id];
! 						if( sts->pos[X] > 0 ){
! 							speed *= -1;
! 							rotate *= -1;
! 						}
! 						sts->myb[i]->spd[X] = speed;
! 						sts->myb[i]->rot[Z] = rotate;
! 						sts->shotwait = _SHOTINTERVAL;
! 						break;
! 					}
! 				}
! 			}
! 		}
! 		else{
! 			if( --sts->shotwait < 0 )
! 				sts->shotwait = 0;
! 		}
! 
! 		if( sts->collision == 0 ){				/* 被弾 */
! 			if( sts->hit != 0){
! 				sts->collision = _NODAMAGE;
! 				if( --sts->hitpoint == 0 )
! 					break_init( sts->ang,sts->pos );
! 			}
! 		}
! 		else{	/*無敵*/
! 			if( --sts->collision < 0 )
! 				sts->collision = 0;
! 			else{
! 				unsigned short	*pCOLOR;
! 				if( sts->collision & 0x01 )
! 					pCOLOR = flash_color;
! 				else
! 					pCOLOR = org_color;
! 				for( i = 0 ; i < 6 ; i++ )
! 					sts->pd->attbl[i].colno = pCOLOR[i];
! 			}
! 		}
! 		sts->hit = 0;
! 
  		slPushMatrix();							/* 表示 */
! 		spr_move( myswitch,sts->pos,sts->ang);
  		set_poly(sts->ang , sts->pos);
  		slPutPolygon( sts->pd );
  		slPopMatrix();
! 
! 	}
! 	else{	/* 死んでる */
! 		spr_break();	/* 爆発 */
! 	}
! }
! 
! 
! 
! void _obje1_act(void){
! 	player( &f[0] );
! }
! 
! void _obje2_act(void){
! 	player( &f[1] );
! }
! 
! 
! void	bullet( BULLET	*sts ){
! 	if( sts->busy != 0 ){
! 		FIXED	distance;
! 		if( ( distance = sts->pos[X] ) < 0 )
! 			distance *= -1;
! 
! 		if( toFIXED( 280.0 ) > distance ){
! 			sts->pos[X] += sts->spd[X];
! 			sts->ang[Z] += sts->rot[Z];
! 
  			slPushMatrix();
  			set_poly( sts->ang, sts->pos );
  			slPutPolygon( sts->pd );
  			slPopMatrix();
! 		}
! 		else{
! 			sts->busy = 0;
! 			return;
! 		}
! 		if( sts->target->hitpoint != 0 ){
! 			if( spr_col( sts->pos , sts->target->pos ) ){
! 				sts->target->hit++;
! 				/*	sts->busy = 0;	*/
! 			}
! 		}
! 	}
! }
! 
! 
! void _shot1_1_act(void){
! 	int	i;
! 	for( i = 0 ; i < _BULLETS ; i++)
! 		bullet( &b[0][i] );
! }
! void _shot1_2_act(void){
! 	;
! }
! void _shot2_1_act(void){
! 	int	i;
! 	for( i = 0 ; i < _BULLETS ; i++)
! 		bullet( &b[1][i] );
! }
! void _shot2_2_act(void){
! 	;
! }
! 
! void	rot_player( int	idnum ){
! 	/* 自転	*/
! 	f[idnum].ang[Y] += DEGtoANG( 12.0 );
! 	f[idnum].ang[Z] += DEGtoANG(  2.0 );
  	slPushMatrix();
  	set_poly( f[idnum].ang , f[idnum].pos );
  	slPutPolygon( f[idnum].pd );
  	slPopMatrix();
! }
! 
! void _obje1_demo(void){
! 	rot_player( 0 );
! }
! 
! void _obje2_demo(void){
! 	rot_player( 1 );
! }
! 
! 
! 
! void	init_objects( void ){
! 	int	i,j;
! 	endtimer = 0;
! 	endflg = 0;
! 
  	/* 自機オブジェの初期ポジション	*/
  	f[0].ang[X] = f[1].ang[X] = DEGtoANG( 0.0 );
  	f[0].ang[Y] = f[1].ang[Y] = DEGtoANG( 0.0 );
  	f[0].ang[Z] = f[1].ang[Z] = DEGtoANG( 0.0 );
! 
  	f[0].id = 0;
  	f[1].id = 1;
! 
! 	f[0].shotwait  = f[1].shotwait = 0;
! 	f[0].collision = f[1].collision = 0;
! 	f[0].hitpoint  = f[1].hitpoint = 3;
! 
  	f[0].pos[X] = toFIXED(-130.0 );
  	f[0].pos[Y] = toFIXED(   0.0 );
  	f[0].pos[Z] = toFIXED( 240.0 );
! 
  	f[1].pos[X] = toFIXED( 130.0);
  	f[1].pos[Y] = toFIXED(   0.0);
  	f[1].pos[Z] = toFIXED( 240.0);
! 
! 	for( i = 0 ; i < 2 ; i++ ){
! 		unsigned char	*src,*dst;
! 		src = ( unsigned char * )PDlist[i];
! 		dst = ( unsigned char * )&PDcube[i];
! 		f[i].pd = &PDcube[i];
! 		for( j = 0 ; j < ( int )sizeof( PDATA ) ; j++ )
! 			*dst++ = *src++;
! 		for( j = 0 ; j < _BULLETS ; j++ )
! 			f[i].myb[j] = &b[i][j];
! 	}
! 
! 
! 	/* ショット弾の初期ポジション	*/
! 	for( i = 0 ; i < 2 ; i++ ){
! 		for( j = 0 ; j < _BULLETS ; j++ ){
  			b[i][j].ang[X] = b[i][j].ang[Y] = b[i][j].ang[Z] = DEGtoANG( 0.0 );
  			b[i][j].pos[X] = b[i][j].pos[Y] = b[i][j].pos[Z] = toFIXED( 0.0 );
  			b[i][j].busy = 0;
  			b[i][j].pd = &PD_PLANE1;
! 			b[i][j].id = ( i << 12 ) + ( j << 8 ) + i*_BULLETS + j;
! 		}
! 	}
! 
! 	/* 飛び散るポリゴンの初期ポジション	*/
! 	for( i = 0 ; i < 6 ; i++ ){
! 		p[i].ang[X] = p[i].ang[Y] = p[i].ang[Z] = DEGtoANG( 0.0);
! 		p[i].pos[X] = p[i].pos[Y] = p[i].pos[Z] = toFIXED( 0.0);
! 		p[i].pd = _PDplane[i];
! 		for( j = X ; j < XYZ ; j++ ){
! 			p[i].spd[j] = spdtbl[i][j];
! 			p[i].rot[j] = rottbl[i][j];
! 		}
! 	}
! }
! 
! 
! 
! /* 破壊後の初期化	*/
  void break_init(ANGLE ang[XYZ],FIXED pos[XYZ]){
! 	int	i,j;
! 	for( i = 0 ; i < 6 ; i++ ){
! 		for( j = X ; j < XYZ ; j++ ){
! 			p[i].ang[j] = ang[j];
! 			p[i].pos[j] = pos[j];
! 		}
! 	}
! }
! 
! /* ポリゴンが飛び散る	*/
! void spr_break(void){
! 	static Uint16 c1,c2,c3,c4,c5;
! 	FIXED	x = toFIXED( fadetimer )/6;
! 	int	i,j;
! 	for( i = 0 ; i < 6 ; i++ ){
! 		for( j = X ; j < XYZ ; j ++ ){
! 			switch( abs( p[i].spd[j] ) ){
! 				case 0:
! 					break;
! 				case 1:
! 					p[i].pos[j] +=  x *  p[i].spd[j];
! 					break;
! 				case 2:
! 					p[i].pos[j] +=  p[i].spd[j];
! 					break;
! 				default:
! 					break;
! 			}
! 			p[i].ang[j] += p[i].rot[j];
! 
! 		}
  	 	slPushMatrix();
  		set_poly( p[i].ang,p[i].pos );
  		slPutPolygon( p[i].pd );
  		slPopMatrix();
! 	}
! 
! 	if( ++endtimer == 90 )
! 		endflg=1;					/* ゲーム終了	*/
! 
! 	if(fadetimer >0)
! 		fadetimer--;
! 
! 	c1 =  6 * fadetimer/60;
! 	c2 = 25 * fadetimer/60;
! 	c3 = 16 * fadetimer/60;
! 	c4 = 10 * fadetimer/60;
! 	c5 = 20 * fadetimer/60;
! 	attribute_BREAK[0].colno=C_RGB(c1,c1,c2);
! 	attribute_BREAK[1].colno=C_RGB(c1,c3,c2);
! 	attribute_BREAK[2].colno=C_RGB(c5,c5,c4);
! }
! 
! void	_pause_act( void ){
! 	int	i,j;
! 	for( i = 0 ; i < 2 ; i++){
  		slPushMatrix();							/* 表示 */
  		set_poly( f[i].ang , f[i].pos );
  		slPutPolygon( f[i].pd );
  		slPopMatrix();
! 	}
! 	for( i = 0 ; i < 2 ; i++){
! 		for( j = 0 ; j < _BULLETS ; j++ ){
! 			if( b[i][j].busy != 0 ){
  				slPushMatrix();							/* 表示 */
  				set_poly( b[i][j].ang , b[i][j].pos );
  				slPutPolygon( &PD_PLANE1 );
! 				slPopMatrix();
  			}
! 		}
! 	}
! }
! 
diff -crBN --binary sbl6/segasmp/game/sequence.c sbl6_patch/segasmp/game/sequence.c
*** sbl6/segasmp/game/sequence.c	1996-02-08 05:28:42.000000000 -0500
--- sbl6_patch/segasmp/game/sequence.c	2023-01-07 14:28:34.000000000 -0500
***************
*** 5,11 ****
  /****************************************
  *			include files				*
  ****************************************/
! #include	"sgl.h"
  #include	"sega_int.h"
  #include	"sega_scl.h"
  #include	"sega_dbg.h"
--- 5,11 ----
  /****************************************
  *			include files				*
  ****************************************/
! #include	"sgl.h"
  #include	"sega_int.h"
  #include	"sega_scl.h"
  #include	"sega_dbg.h"
***************
*** 25,37 ****
  *		declare private objects			*
  ****************************************/
  void	init(void){
! 	slInitSystem(TV_320x224,NULL,1);
  	SetVblank();
  /*	level[0]=SQ_TITLE;	*/
  	level[0]=SQ_LOGO;
  }
  
! void	main( void ){
  	level[0] = SQ_INIT;
  	level[1] = 0;
  	timer = 0;
--- 25,37 ----
  *		declare private objects			*
  ****************************************/
  void	init(void){
! 	slInitSystem(TV_320x224,NULL,1);
  	SetVblank();
  /*	level[0]=SQ_TITLE;	*/
  	level[0]=SQ_LOGO;
  }
  
! int	main( void ){
  	level[0] = SQ_INIT;
  	level[1] = 0;
  	timer = 0;
***************
*** 68,74 ****
  		}
  		
  		/* Ｖブランク待ち	*/
! 		slSynch();
  	}
  }
! 
\ No newline at end of file
--- 68,75 ----
  		}
  		
  		/* Ｖブランク待ち	*/
! 		slSynch();
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/game_cd/act.c sbl6_patch/segasmp/game_cd/act.c
*** sbl6/segasmp/game_cd/act.c	1996-02-08 05:28:46.000000000 -0500
--- sbl6_patch/segasmp/game_cd/act.c	2024-07-31 18:10:14.000000000 -0400
***************
*** 1,6 ****
  /*----------------------------------------------------------------------*/
! /*	ＳＢＬ６サンプルゲームだよーん										*/
  /*----------------------------------------------------------------------*/
  
  #include	"act.h"
  #include	"sega_scl.h"
--- 1,8 ----
  /*----------------------------------------------------------------------*/
! /*	ｿｽrｿｽaｿｽkｿｽUｿｽTｿｽｿｽｿｽvｿｽｿｽｿｽQｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽ										*/
  /*----------------------------------------------------------------------*/
+ #include <math.h>
+ #include <stdlib.h>
  
  #include	"act.h"
  #include	"sega_scl.h"
***************
*** 47,53 ****
  				{DEGtoANG(-10.0 ),DEGtoANG(  0.0 ),DEGtoANG(-10.0 )}
  			};
  
! unsigned short	flash_color[] = {	/* Flashの色	*/
  			C_RGB(25,28,30),
  			C_RGB(25,25,30),
  			C_RGB(25,28,30),
--- 49,55 ----
  				{DEGtoANG(-10.0 ),DEGtoANG(  0.0 ),DEGtoANG(-10.0 )}
  			};
  
! unsigned short	flash_color[] = {	/* Flashｿｽﾌ色	*/
  			C_RGB(25,28,30),
  			C_RGB(25,25,30),
  			C_RGB(25,28,30),
***************
*** 55,61 ****
  			C_RGB(30,30,25),
  			C_RGB(30,30,25)
  			};
! unsigned short	org_color[] = {	/* 元の色	*/
  			C_RGB( 6,16,25),
  			C_RGB( 6, 6,25),
  			C_RGB( 6,16,25),
--- 57,63 ----
  			C_RGB(30,30,25),
  			C_RGB(30,30,25)
  			};
! unsigned short	org_color[] = {	/* ｿｽｿｽｿｽﾌ色	*/
  			C_RGB( 6,16,25),
  			C_RGB( 6, 6,25),
  			C_RGB( 6,16,25),
***************
*** 86,93 ****
  		resetplayer( sts );
  	}
  
! 	if( sts->hitpoint != 0 ){					/* 生きている */
! 		if( sts->shotwait == 0 ){				/* 攻撃 */
  			if( ( myswitch & TRG_FIRE ) != 0 ){
  				for( i = 0 ; i < _BULLETS ; i++ ){
  					if( sts->myb[i]->busy == 0 ){
--- 88,95 ----
  		resetplayer( sts );
  	}
  
! 	if( sts->hitpoint != 0 ){					/* ｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽ */
! 		if( sts->shotwait == 0 ){				/* ｿｽUｿｽｿｽ */
  			if( ( myswitch & TRG_FIRE ) != 0 ){
  				for( i = 0 ; i < _BULLETS ; i++ ){
  					if( sts->myb[i]->busy == 0 ){
***************
*** 115,128 ****
  				sts->shotwait = 0;
  		}
  
! 		if( sts->collision == 0 ){				/* 被弾 */
  			if( sts->hit != 0){
  				sts->collision = _NODAMAGE;
  				if( --sts->hitpoint == 0 )
  					break_init( sts->ang,sts->pos );
  			}
  		}
! 		else{	/*無敵*/
  			if( --sts->collision < 0 )
  				sts->collision = 0;
  			else{
--- 117,130 ----
  				sts->shotwait = 0;
  		}
  
! 		if( sts->collision == 0 ){				/* ｿｽｿｽｿｽe */
  			if( sts->hit != 0){
  				sts->collision = _NODAMAGE;
  				if( --sts->hitpoint == 0 )
  					break_init( sts->ang,sts->pos );
  			}
  		}
! 		else{	/*ｿｽｿｽｿｽG*/
  			if( --sts->collision < 0 )
  				sts->collision = 0;
  			else{
***************
*** 137,151 ****
  		}
  		sts->hit = 0;
  
! 		slPushMatrix();							/* 表示 */
  		spr_move( myswitch,sts->pos,sts->ang);
  		set_poly(sts->ang , sts->pos);
  		slPutPolygon( sts->pd );
  		slPopMatrix();
  
  	}
! 	else{	/* 死んでる */
! 		spr_break();	/* 爆発 */
  	}
  }
  
--- 139,153 ----
  		}
  		sts->hit = 0;
  
! 		slPushMatrix();							/* ｿｽ\ｿｽｿｽ */
  		spr_move( myswitch,sts->pos,sts->ang);
  		set_poly(sts->ang , sts->pos);
  		slPutPolygon( sts->pd );
  		slPopMatrix();
  
  	}
! 	else{	/* ｿｽｿｽｿｽｿｽｿｽﾅゑｿｽ */
! 		spr_break();	/* ｿｽｿｽｿｽｿｽ */
  	}
  }
  
***************
*** 207,213 ****
  }
  
  void	rot_player( int	idnum ){
! 	/* 自転	*/
  	f[idnum].ang[Y] += DEGtoANG( 12.0 );
  	f[idnum].ang[Z] += DEGtoANG(  2.0 );
  	slPushMatrix();
--- 209,215 ----
  }
  
  void	rot_player( int	idnum ){
! 	/* ｿｽｿｽｿｽ]	*/
  	f[idnum].ang[Y] += DEGtoANG( 12.0 );
  	f[idnum].ang[Z] += DEGtoANG(  2.0 );
  	slPushMatrix();
***************
*** 231,237 ****
  	endtimer = 0;
  	endflg = 0;
  
! 	/* 自機オブジェの初期ポジション	*/
  	f[0].ang[X] = f[1].ang[X] = DEGtoANG( 0.0 );
  	f[0].ang[Y] = f[1].ang[Y] = DEGtoANG( 0.0 );
  	f[0].ang[Z] = f[1].ang[Z] = DEGtoANG( 0.0 );
--- 233,239 ----
  	endtimer = 0;
  	endflg = 0;
  
! 	/* ｿｽｿｽｿｽ@ｿｽIｿｽuｿｽWｿｽFｿｽﾌ擾ｿｽｿｽｿｽｿｽ|ｿｽWｿｽVｿｽｿｽｿｽｿｽ	*/
  	f[0].ang[X] = f[1].ang[X] = DEGtoANG( 0.0 );
  	f[0].ang[Y] = f[1].ang[Y] = DEGtoANG( 0.0 );
  	f[0].ang[Z] = f[1].ang[Z] = DEGtoANG( 0.0 );
***************
*** 263,269 ****
  	}
  
  
! 	/* ショット弾の初期ポジション	*/
  	for( i = 0 ; i < 2 ; i++ ){
  		for( j = 0 ; j < _BULLETS ; j++ ){
  			b[i][j].ang[X] = b[i][j].ang[Y] = b[i][j].ang[Z] = DEGtoANG( 0.0 );
--- 265,271 ----
  	}
  
  
! 	/* ｿｽVｿｽｿｽｿｽbｿｽgｿｽeｿｽﾌ擾ｿｽｿｽｿｽｿｽ|ｿｽWｿｽVｿｽｿｽｿｽｿｽ	*/
  	for( i = 0 ; i < 2 ; i++ ){
  		for( j = 0 ; j < _BULLETS ; j++ ){
  			b[i][j].ang[X] = b[i][j].ang[Y] = b[i][j].ang[Z] = DEGtoANG( 0.0 );
***************
*** 274,280 ****
  		}
  	}
  
! 	/* 飛び散るポリゴンの初期ポジション	*/
  	for( i = 0 ; i < 6 ; i++ ){
  		p[i].ang[X] = p[i].ang[Y] = p[i].ang[Z] = DEGtoANG( 0.0);
  		p[i].pos[X] = p[i].pos[Y] = p[i].pos[Z] = toFIXED( 0.0);
--- 276,282 ----
  		}
  	}
  
! 	/* ｿｽｿｽｿｽﾑ散ｿｽｿｽｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽ|ｿｽWｿｽVｿｽｿｽｿｽｿｽ	*/
  	for( i = 0 ; i < 6 ; i++ ){
  		p[i].ang[X] = p[i].ang[Y] = p[i].ang[Z] = DEGtoANG( 0.0);
  		p[i].pos[X] = p[i].pos[Y] = p[i].pos[Z] = toFIXED( 0.0);
***************
*** 288,294 ****
  
  
  
! /* 破壊後の初期化	*/
  void break_init(ANGLE ang[XYZ],FIXED pos[XYZ]){
  	int	i,j;
  	for( i = 0 ; i < 6 ; i++ ){
--- 290,296 ----
  
  
  
! /* ｿｽjｿｽｿｽｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ	*/
  void break_init(ANGLE ang[XYZ],FIXED pos[XYZ]){
  	int	i,j;
  	for( i = 0 ; i < 6 ; i++ ){
***************
*** 299,305 ****
  	}
  }
  
! /* ポリゴンが飛び散る	*/
  void spr_break(void){
  	static Uint16 c1,c2,c3,c4,c5;
  	FIXED	x = toFIXED( fadetimer )/6;
--- 301,307 ----
  	}
  }
  
! /* ｿｽ|ｿｽｿｽｿｽSｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾑ散ｿｽｿｽ	*/
  void spr_break(void){
  	static Uint16 c1,c2,c3,c4,c5;
  	FIXED	x = toFIXED( fadetimer )/6;
***************
*** 328,334 ****
  	}
  
  	if( ++endtimer == 90 )
! 		endflg=1;					/* ゲーム終了	*/
  
  	if(fadetimer >0)
  		fadetimer--;
--- 330,336 ----
  	}
  
  	if( ++endtimer == 90 )
! 		endflg=1;					/* ｿｽQｿｽ[ｿｽｿｽｿｽIｿｽｿｽ	*/
  
  	if(fadetimer >0)
  		fadetimer--;
***************
*** 346,352 ****
  void	_pause_act( void ){
  	int	i,j;
  	for( i = 0 ; i < 2 ; i++){
! 		slPushMatrix();							/* 表示 */
  		set_poly( f[i].ang , f[i].pos );
  		slPutPolygon( f[i].pd );
  		slPopMatrix();
--- 348,354 ----
  void	_pause_act( void ){
  	int	i,j;
  	for( i = 0 ; i < 2 ; i++){
! 		slPushMatrix();							/* ｿｽ\ｿｽｿｽ */
  		set_poly( f[i].ang , f[i].pos );
  		slPutPolygon( f[i].pd );
  		slPopMatrix();
***************
*** 354,360 ****
  	for( i = 0 ; i < 2 ; i++){
  		for( j = 0 ; j < _BULLETS ; j++ ){
  			if( b[i][j].busy != 0 ){
! 				slPushMatrix();							/* 表示 */
  				set_poly( b[i][j].ang , b[i][j].pos );
  				slPutPolygon( &PD_PLANE1 );
  				slPopMatrix();
--- 356,362 ----
  	for( i = 0 ; i < 2 ; i++){
  		for( j = 0 ; j < _BULLETS ; j++ ){
  			if( b[i][j].busy != 0 ){
! 				slPushMatrix();							/* ｿｽ\ｿｽｿｽ */
  				set_poly( b[i][j].ang , b[i][j].pos );
  				slPutPolygon( &PD_PLANE1 );
  				slPopMatrix();
***************
*** 362,365 ****
  		}
  	}
  }
! 
\ No newline at end of file
--- 364,367 ----
  		}
  	}
  }
! 
diff -crBN --binary sbl6/segasmp/game_cd/sequence.c sbl6_patch/segasmp/game_cd/sequence.c
*** sbl6/segasmp/game_cd/sequence.c	1996-02-08 05:29:16.000000000 -0500
--- sbl6_patch/segasmp/game_cd/sequence.c	2023-01-07 14:30:04.000000000 -0500
***************
*** 5,11 ****
  /****************************************
  *			include files				*
  ****************************************/
! #include	"sgl.h"
  #include	"sega_int.h"
  #include	"sega_scl.h"
  #include	"sega_dbg.h"
--- 5,11 ----
  /****************************************
  *			include files				*
  ****************************************/
! #include	"sgl.h"
  #include	"sega_int.h"
  #include	"sega_scl.h"
  #include	"sega_dbg.h"
***************
*** 26,39 ****
  *		declare private objects			*
  ****************************************/
  void	init(void){
! 	slInitSystem(TV_320x224,NULL,1);
  	SetVblank();
  /*	level[0]=SQ_TITLE;	*/
  	level[0]=SQ_LOGO;
  	InitCDBlock();
  }
  
! void	main( void ){
  	level[0] = SQ_INIT;
  	level[1] = 0;
  	timer = 0;
--- 26,39 ----
  *		declare private objects			*
  ****************************************/
  void	init(void){
! 	slInitSystem(TV_320x224,NULL,1);
  	SetVblank();
  /*	level[0]=SQ_TITLE;	*/
  	level[0]=SQ_LOGO;
  	InitCDBlock();
  }
  
! int	main( void ){
  	level[0] = SQ_INIT;
  	level[1] = 0;
  	timer = 0;
***************
*** 71,77 ****
  
  		/* Ｖブランク待ち	*/
  		slSynch();
! 		CheckCDOpen();
  	}
  }
! 
\ No newline at end of file
--- 71,78 ----
  
  		/* Ｖブランク待ち	*/
  		slSynch();
! 		CheckCDOpen();
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/gfs/smpgfs1a/smpgfs1a.c sbl6_patch/segasmp/gfs/smpgfs1a/smpgfs1a.c
*** sbl6/segasmp/gfs/smpgfs1a/smpgfs1a.c	1996-02-08 05:29:38.000000000 -0500
--- sbl6_patch/segasmp/gfs/smpgfs1a/smpgfs1a.c	2023-01-07 14:30:46.000000000 -0500
***************
*** 70,76 ****
  /*****************************************************************************
   *      関数の定義
   *****************************************************************************/
! Sint32 main()
  {
      Sint32 ret;
      GfsHn gfs;                  /* ファイルハンドル */
--- 70,76 ----
  /*****************************************************************************
   *      関数の定義
   *****************************************************************************/
! int main()
  {
      Sint32 ret;
      GfsHn gfs;                  /* ファイルハンドル */
***************
*** 126,129 ****
  
  
  
! 
\ No newline at end of file
--- 126,129 ----
  
  
  
! 
diff -crBN --binary sbl6/segasmp/gfs/smpgfs1b/smpgfs1b.c sbl6_patch/segasmp/gfs/smpgfs1b/smpgfs1b.c
*** sbl6/segasmp/gfs/smpgfs1b/smpgfs1b.c	1996-02-08 05:29:42.000000000 -0500
--- sbl6_patch/segasmp/gfs/smpgfs1b/smpgfs1b.c	2023-01-07 14:31:04.000000000 -0500
***************
*** 70,76 ****
  /*****************************************************************************
   *      関数の定義
   *****************************************************************************/
! Sint32 main()
  {
      Sint32 ret;
      GfsHn gfs;                  /* ファイルハンドル */
--- 70,76 ----
  /*****************************************************************************
   *      関数の定義
   *****************************************************************************/
! int main()
  {
      Sint32 ret;
      GfsHn gfs;                  /* ファイルハンドル */
***************
*** 126,129 ****
  
  
  
! 
\ No newline at end of file
--- 126,129 ----
  
  
  
! 
diff -crBN --binary sbl6/segasmp/gfs/smpgfs2/smpgfs02.c sbl6_patch/segasmp/gfs/smpgfs2/smpgfs02.c
*** sbl6/segasmp/gfs/smpgfs2/smpgfs02.c	1996-02-08 05:29:46.000000000 -0500
--- sbl6_patch/segasmp/gfs/smpgfs2/smpgfs02.c	2023-01-07 14:31:28.000000000 -0500
***************
*** 66,72 ****
   *      関数の定義
   *****************************************************************************/
  
! Sint32 main()
  {
      GfsHn gfs1;                 /* ファイルハンドル1 */
      GfsHn gfs2;                 /* ファイルハンドル2 */
--- 66,72 ----
   *      関数の定義
   *****************************************************************************/
  
! int main()
  {
      GfsHn gfs1;                 /* ファイルハンドル1 */
      GfsHn gfs2;                 /* ファイルハンドル2 */
***************
*** 131,134 ****
      /* ファイル読み込みと並行して行ないたい処理を記述する */
      /* このサンプルでは何も行なわない */
  }
! 
\ No newline at end of file
--- 131,134 ----
      /* ファイル読み込みと並行して行ないたい処理を記述する */
      /* このサンプルでは何も行なわない */
  }
! 
diff -crBN --binary sbl6/segasmp/mem/smpmem0/smpmem0.c sbl6_patch/segasmp/mem/smpmem0/smpmem0.c
*** sbl6/segasmp/mem/smpmem0/smpmem0.c	1996-02-08 05:30:02.000000000 -0500
--- sbl6_patch/segasmp/mem/smpmem0/smpmem0.c	2022-01-06 18:30:14.000000000 -0500
***************
*** 79,85 ****
  #define	SZ_HEAP	0x10000
  static unsigned long	__heap[SZ_HEAP];
  
! void main(void)
  {
  
      /** BEGIN ****************************************************************/
--- 79,85 ----
  #define	SZ_HEAP	0x10000
  static unsigned long	__heap[SZ_HEAP];
  
! int main(void)
  {
  
      /** BEGIN ****************************************************************/
***************
*** 114,118 ****
  
      MEM_Free(malloc_2);
      MEM_Free(malloc_3);
  }
! 
\ No newline at end of file
--- 114,120 ----
  
      MEM_Free(malloc_2);
      MEM_Free(malloc_3);
+     
+     return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/mem/smpmem1/smpmem1.c sbl6_patch/segasmp/mem/smpmem1/smpmem1.c
*** sbl6/segasmp/mem/smpmem1/smpmem1.c	1996-02-08 05:30:04.000000000 -0500
--- sbl6_patch/segasmp/mem/smpmem1/smpmem1.c	2022-01-06 18:30:32.000000000 -0500
***************
*** 80,86 ****
  static unsigned char	__heap[SZ_HEAP];
  char	sega[] = "SEGA";
  
! void main(void){
  	Uint32	biggest,ui;
  	void	*ptr,*tmp;
  	int	i,maxcell[32];
--- 80,86 ----
  static unsigned char	__heap[SZ_HEAP];
  char	sega[] = "SEGA";
  
! int main(void){
  	Uint32	biggest,ui;
  	void	*ptr,*tmp;
  	int	i,maxcell[32];
***************
*** 150,154 ****
  	/* ここまでくれば終了 */
  	for(;;)
  		;
  }
! 
\ No newline at end of file
--- 150,156 ----
  	/* ここまでくれば終了 */
  	for(;;)
  		;
+ 	
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/pcm/smppcm13/smppcm13.c sbl6_patch/segasmp/pcm/smppcm13/smppcm13.c
*** sbl6/segasmp/pcm/smppcm13/smppcm13.c	1996-02-08 05:30:12.000000000 -0500
--- sbl6_patch/segasmp/pcm/smppcm13/smppcm13.c	2022-01-22 12:33:56.000000000 -0500
***************
*** 314,320 ****
  	}
  }
  
! void main(void)
  {
  	/* Ｖブランクの設定 */
  	vblInit();
--- 314,320 ----
  	}
  }
  
! int main(void)
  {
  	/* Ｖブランクの設定 */
  	vblInit();
***************
*** 329,335 ****
  	PCM_Init();
  
  	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	PCM_DeclareUseAdpcm();
  
  	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
--- 329,335 ----
  	PCM_Init();
  
  	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	//PCM_DeclareUseAdpcm();
  
  	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
***************
*** 341,345 ****
  		smp_RestartPlay();
  #endif
  	}
  }
! 
\ No newline at end of file
--- 341,347 ----
  		smp_RestartPlay();
  #endif
  	}
+ 	
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/pcm/smppcm2/smppcm2.c sbl6_patch/segasmp/pcm/smppcm2/smppcm2.c
*** sbl6/segasmp/pcm/smppcm2/smppcm2.c	1996-02-08 05:30:16.000000000 -0500
--- sbl6_patch/segasmp/pcm/smppcm2/smppcm2.c	2022-01-22 11:58:56.000000000 -0500
***************
*** 259,265 ****
  	STM_Close(fp);
  }
  
! void main(void)
  {
  	PcmHn 			pcm;
  	StmHn			stm;
--- 259,265 ----
  	STM_Close(fp);
  }
  
! int main(void)
  {
  	PcmHn 			pcm;
  	StmHn			stm;
***************
*** 279,285 ****
  	PCM_Init();
  
  	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	PCM_DeclareUseAdpcm();
  
  	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
--- 279,285 ----
  	PCM_Init();
  
  	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	//PCM_DeclareUseAdpcm();
  
  	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
***************
*** 293,299 ****
  		if (restart) {
  			/* ストリームオープン */
  			if ((stm = stmOpen(filename)) == NULL) {
! 				return;
  			}
  
  			/* 取り出し領域のリセット
--- 293,299 ----
  		if (restart) {
  			/* ストリームオープン */
  			if ((stm = stmOpen(filename)) == NULL) {
! 				return 1;
  			}
  
  			/* 取り出し領域のリセット
***************
*** 310,316 ****
  			PCM_PARA_PCM_SIZE(&para) = PCM_SIZE;
  			pcm = PCM_CreateStmHandle(&para, stm);
  			if (pcm == NULL) {
! 				return;
  			}
  
  			/* データの転送方式の設定（ＣＤブロック→リングバッファ） */
--- 310,316 ----
  			PCM_PARA_PCM_SIZE(&para) = PCM_SIZE;
  			pcm = PCM_CreateStmHandle(&para, stm);
  			if (pcm == NULL) {
! 				return 1;
  			}
  
  			/* データの転送方式の設定（ＣＤブロック→リングバッファ） */
***************
*** 340,344 ****
  			restart = 1;
  		}
  	}
  }
! 
\ No newline at end of file
--- 340,345 ----
  			restart = 1;
  		}
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/pcm/smppcm3/smppcm3.c sbl6_patch/segasmp/pcm/smppcm3/smppcm3.c
*** sbl6/segasmp/pcm/smppcm3/smppcm3.c	1996-02-08 05:30:18.000000000 -0500
--- sbl6_patch/segasmp/pcm/smppcm3/smppcm3.c	2024-08-01 16:16:10.000000000 -0400
***************
*** 1,9 ****
  /******************************************************************************
!  *	ソフトウェアライブラリ
   *
   *	Copyright (c) 1994,1995 SEGA
   *
!  * Library	:ＰＣＭ・ＡＤＰＣＭ再生ライブラリ
   * Module 	:sample program of MEMORY PLAY MODE
   * File		:smppcm3.c
   * Date		:1995-03-31
--- 1,9 ----
  /******************************************************************************
!  *	ｿｽ\ｿｽtｿｽgｿｽEｿｽFｿｽAｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ
   *
   *	Copyright (c) 1994,1995 SEGA
   *
!  * Library	:ｿｽoｿｽbｿｽlｿｽEｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ
   * Module 	:sample program of MEMORY PLAY MODE
   * File		:smppcm3.c
   * Date		:1995-03-31
***************
*** 11,31 ****
   * Auther	:Y.T
   *
   * Comment	:
!  *	メモリ上にあるファイルを再生するサンプル。
!  *	ファイルは 0x4000000 番地にロードしておくこと。
!  *	再生できるファイルサイズは１６ＭＢまで。
   *
   ****************************************************************************/
  
! /*------------------------- 《プログラム選択》 -------------------------*/
  
! /* VTV, MON を使用したデバッグの時に定義する。 */
  /* #define SMPPCM_DEBUG */
  
! /* リングバッファ機能のテスト */
  /* #define RING_BUF_TEST */
  
! /*------------------------- 《インクルード》 -------------------------*/
  #include <machine.h>
  #define _SH
  #include "sega_xpt.h"
--- 11,31 ----
   * Auther	:Y.T
   *
   * Comment	:
!  *	ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾉゑｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽﾄ撰ｿｽｿｽｿｽｿｽｿｽｿｽTｿｽｿｽｿｽvｿｽｿｽｿｽB
!  *	ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽ 0x4000000 ｿｽﾔ地ｿｽﾉｿｽｿｽ[ｿｽhｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽｿｽｿｽﾆ。
!  *	ｿｽﾄ撰ｿｽｿｽﾅゑｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽTｿｽCｿｽYｿｽﾍ１ｿｽUｿｽlｿｽaｿｽﾜで。
   *
   ****************************************************************************/
  
! /*------------------------- ｿｽsｿｽvｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽIｿｽｿｽｿｽt -------------------------*/
  
! /* VTV, MON ｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽfｿｽoｿｽbｿｽOｿｽﾌ趣ｿｽｿｽﾉ抵ｿｽｿｽ`ｿｽｿｽｿｽｿｽｿｽB */
  /* #define SMPPCM_DEBUG */
  
! /* ｿｽｿｽｿｽｿｽｿｽOｿｽoｿｽbｿｽtｿｽ@ｿｽ@ｿｽ\ｿｽﾌテｿｽXｿｽg */
  /* #define RING_BUF_TEST */
  
! /*------------------------- ｿｽsｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽt -------------------------*/
  #include <machine.h>
  #define _SH
  #include "sega_xpt.h"
***************
*** 40,47 ****
  
  #if	1
  	/*
! 	**■1995-07-28	高橋智延
! 	**	SCL_VblankStart(), SCL_VBlankEnd() を使っているので追加
  	*/
  	#include	"sega_scl.h"
  #endif
--- 40,47 ----
  
  #if	1
  	/*
! 	**ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! 	**	SCL_VblankStart(), SCL_VBlankEnd() ｿｽｿｽｿｽgｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽﾌで追会ｿｽ
  	*/
  	#include	"sega_scl.h"
  #endif
***************
*** 53,91 ****
  	#define SMPPCMD_MON_Reset			smppcmd_MON_Reset
  	#define SMPPCMD_PCM_Task			smppcmd_PCM_Task
  #else
! 	#define SMPPCMD_VblIn()				
! 	#define SMPPCMD_Init(a)				
! 	#define SMPPCMD_MON_Reset()			
  	#define SMPPCMD_PCM_Task			PCM_Task
! 	#define VTV_Printf(a)				
! 	#define VTV_PRINTF(a)				
! 	#define _VTV_Printf(a)				
! 	#define _VTV_PRINTF(a)				
  #endif
  
  
! /*--------------------------- 《関数宣言》 ---------------------------*/
  
  static void smpVblIn(void);
  static void smpVblOut(void);
  
  
! /*---------------------------- 《定数》 ----------------------------*/
  
! /* ウェーブＲＡＭの転送アドレスとサンプル数 */
  #define	PCM_ADDR	((void*)0x25a20000)
  #define	PCM_SIZE	(4096L*2)				/* 2.. */
  
! /* リングバッファのサイズ */
  #define	RING_BUF_SIZE	(1024L*1024L*16)
  
  
! /*----------------------- 《グローバル変数》 -----------------------*/
  
! /* ワーク */
  static PcmWork g_movie_work;
  
! /* リングバッファ */
  static Sint8 *g_movie_buf = (Sint8 *)0x04000000;
  
  
--- 53,91 ----
  	#define SMPPCMD_MON_Reset			smppcmd_MON_Reset
  	#define SMPPCMD_PCM_Task			smppcmd_PCM_Task
  #else
! 	#define SMPPCMD_VblIn()
! 	#define SMPPCMD_Init(a)
! 	#define SMPPCMD_MON_Reset()
  	#define SMPPCMD_PCM_Task			PCM_Task
! 	#define VTV_Printf(a)
! 	#define VTV_PRINTF(a)
! 	#define _VTV_Printf(a)
! 	#define _VTV_PRINTF(a)
  #endif
  
  
! /*--------------------------- ｿｽsｿｽﾖ撰ｿｽｿｽ骭ｾｿｽt ---------------------------*/
  
  static void smpVblIn(void);
  static void smpVblOut(void);
  
  
! /*---------------------------- ｿｽsｿｽ關費ｿｽt ----------------------------*/
  
! /* ｿｽEｿｽFｿｽ[ｿｽuｿｽqｿｽ`ｿｽlｿｽﾌ転ｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽXｿｽﾆサｿｽｿｽｿｽvｿｽｿｽｿｽｿｽ */
  #define	PCM_ADDR	((void*)0x25a20000)
  #define	PCM_SIZE	(4096L*2)				/* 2.. */
  
! /* ｿｽｿｽｿｽｿｽｿｽOｿｽoｿｽbｿｽtｿｽ@ｿｽﾌサｿｽCｿｽY */
  #define	RING_BUF_SIZE	(1024L*1024L*16)
  
  
! /*----------------------- ｿｽsｿｽOｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽﾏ撰ｿｽｿｽt -----------------------*/
  
! /* ｿｽｿｽｿｽ[ｿｽN */
  static PcmWork g_movie_work;
  
! /* ｿｽｿｽｿｽｿｽｿｽOｿｽoｿｽbｿｽtｿｽ@ */
  static Sint8 *g_movie_buf = (Sint8 *)0x04000000;
  
  
***************
*** 97,103 ****
  	Uint32 ring_buf[SIZE_RING_BUF / 4];
  #endif
  
! /*---------------------------- 《関数》 ----------------------------*/
  
  void errGfsFunc(void *obj, Sint32 ec)
  {
--- 97,103 ----
  	Uint32 ring_buf[SIZE_RING_BUF / 4];
  #endif
  
! /*---------------------------- ｿｽsｿｽﾖ撰ｿｽｿｽt ----------------------------*/
  
  void errGfsFunc(void *obj, Sint32 ec)
  {
***************
*** 110,122 ****
  }
  
  
! /*====================== Ｖブランクの処理 ===========================*/
  
  static void vblInit(void)
  {
      set_imask(0);
  
! 	/* Ｖブランクの設定 */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  	INT_SetScuFunc(INT_SCU_VBLK_IN, smpVblIn);
  	INT_SetScuFunc(INT_SCU_VBLK_OUT, smpVblOut);
--- 110,122 ----
  }
  
  
! /*====================== ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
  
  static void vblInit(void)
  {
      set_imask(0);
  
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ設抵ｿｽ */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  	INT_SetScuFunc(INT_SCU_VBLK_IN, smpVblIn);
  	INT_SetScuFunc(INT_SCU_VBLK_OUT, smpVblOut);
***************
*** 125,145 ****
  
  static void smpVblIn(void)
  {
! 	/* ＰＣＭライブラリの VblIn ルーチンをコール */
  	PCM_VblIn();
  
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
  	SCL_VblankStart();
  }
  
  static void smpVblOut(void)
  {
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
  	SCL_VblankEnd();
  }
  
  
! /*====================== サウンドの処理 ===========================*/
  #define SDDRVS_TSK_SIZE			(0x6000)
  #define BOOTSND_MAP_SIZE		(0x0100)
  Sint32 sddrvs_tsk[SDDRVS_TSK_SIZE / 4];
--- 125,145 ----
  
  static void smpVblIn(void)
  {
! 	/* ｿｽoｿｽbｿｽlｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽ VblIn ｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽｿｽｿｽRｿｽ[ｿｽｿｽ */
  	PCM_VblIn();
  
! 	/* ｿｽOｿｽｿｽｿｽtｿｽBｿｽbｿｽNｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽﾗには趣ｿｽｿｽsｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾎなゑｿｽｿｽﾈゑｿｽ */
  	SCL_VblankStart();
  }
  
  static void smpVblOut(void)
  {
! 	/* ｿｽOｿｽｿｽｿｽtｿｽBｿｽbｿｽNｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽﾗには趣ｿｽｿｽsｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾎなゑｿｽｿｽﾈゑｿｽ */
  	SCL_VblankEnd();
  }
  
  
! /*====================== ｿｽTｿｽEｿｽｿｽｿｽhｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
  #define SDDRVS_TSK_SIZE			(0x6000)
  #define BOOTSND_MAP_SIZE		(0x0100)
  Sint32 sddrvs_tsk[SDDRVS_TSK_SIZE / 4];
***************
*** 178,220 ****
  }
  
  
! /*====================== ファイルの処理 ===========================*/
! /* ルートディレクトリにあるファイルの最大数 */
  #define MAX_DIR		100
  
! /* 同時に開くファイルの最大数 */
  #define OPEN_MAX	5
  
! /* ディレクトリ情報管理領域 */
  static GfsDirTbl	dir_tbl;
  
! /* ファイル名を含んだ情報 */
  static GfsDirName dir_name[MAX_DIR];
  
! /* ＧＦＳの作業領域 */
  static Uint8 gfs_work[GFS_WORK_SIZE(OPEN_MAX)];
  
  static void fileInit(void)
  {
  	Sint32 file_num;
  
! 	/* GFSの初期化 */
  	GFS_DIRTBL_TYPE(&dir_tbl) = GFS_DIR_NAME;
  	GFS_DIRTBL_DIRNAME(&dir_tbl) = dir_name;
  	GFS_DIRTBL_NDIR(&dir_tbl) = MAX_DIR;
  
!     /* ファイルシステムの初期化 */
      file_num = GFS_Init(OPEN_MAX, gfs_work, &dir_tbl);
  	if (file_num < 0) {
  		return;
  	}
  
! 	/* エラー関数の設定 */
  	GFS_SetErrFunc(errGfsFunc, NULL);
  }
  
  
! void main(void)
  {
  	PcmHn 			pcm;
  	Uint32			restart;
--- 178,220 ----
  }
  
  
! /*====================== ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
! /* ｿｽｿｽｿｽ[ｿｽgｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽﾉゑｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ最大数 */
  #define MAX_DIR		100
  
! /* ｿｽｿｽｿｽｿｽｿｽﾉ開ｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ最大数 */
  #define OPEN_MAX	5
  
! /* ｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾌ茨ｿｽ */
  static GfsDirTbl	dir_tbl;
  
! /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾜんだ擾ｿｽｿｽｿｽ */
  static GfsDirName dir_name[MAX_DIR];
  
! /* ｿｽfｿｽeｿｽrｿｽﾌ搾ｿｽｿｽﾆ領茨ｿｽ */
  static Uint8 gfs_work[GFS_WORK_SIZE(OPEN_MAX)];
  
  static void fileInit(void)
  {
  	Sint32 file_num;
  
! 	/* GFSｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	GFS_DIRTBL_TYPE(&dir_tbl) = GFS_DIR_NAME;
  	GFS_DIRTBL_DIRNAME(&dir_tbl) = dir_name;
  	GFS_DIRTBL_NDIR(&dir_tbl) = MAX_DIR;
  
!     /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
      file_num = GFS_Init(OPEN_MAX, gfs_work, &dir_tbl);
  	if (file_num < 0) {
  		return;
  	}
  
! 	/* ｿｽGｿｽｿｽｿｽ[ｿｽﾖ撰ｿｽｿｽﾌ設抵ｿｽ */
  	GFS_SetErrFunc(errGfsFunc, NULL);
  }
  
  
! int main(void)
  {
  	PcmHn 			pcm;
  	Uint32			restart;
***************
*** 225,246 ****
  #endif
  
  
! 	/* Ｖブランクの設定 */
  	vblInit();
  
! 	/* ファイル初期化 */
  	fileInit();
  
! 	/* サウンドの設定 */
  	sndInit();
  
! 	/* ＰＣＭライブラリの初期化 */
  	PCM_Init();
  
! 	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	PCM_DeclareUseAdpcm();
  
! 	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
  
  	restart = 1;
--- 225,246 ----
  #endif
  
  
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ設抵ｿｽ */
  	vblInit();
  
! 	/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  	fileInit();
  
! 	/* ｿｽTｿｽEｿｽｿｽｿｽhｿｽﾌ設抵ｿｽ */
  	sndInit();
  
! 	/* ｿｽoｿｽbｿｽlｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	PCM_Init();
  
! 	/* ｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽgｿｽpｿｽ骭ｾ (ADPCMｿｽLｿｽｿｽﾗｲｿｽｿｽｿｽﾘゑｿｽｿｽﾝｸｿｽｿｽｿｽｿｽｿｽﾜゑｿｽ) */
! 	//PCM_DeclareUseAdpcm();
  
! 	/* ｿｽoｿｽbｿｽlｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌエｿｽｿｽｿｽ[ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ設抵ｿｽ */
  	PCM_SetErrFunc(errPcmFunc, NULL);
  
  	restart = 1;
***************
*** 248,254 ****
  	for (;;) {
  		if (restart) {
  
! 			/* ハンドルの作成 */
  			PCM_PARA_WORK(&para) = (struct PcmWork *)&g_movie_work;
  			PCM_PARA_RING_ADDR(&para) = g_movie_buf;
  			PCM_PARA_RING_SIZE(&para) = RING_BUF_SIZE;
--- 248,254 ----
  	for (;;) {
  		if (restart) {
  
! 			/* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ作成 */
  			PCM_PARA_WORK(&para) = (struct PcmWork *)&g_movie_work;
  			PCM_PARA_RING_ADDR(&para) = g_movie_buf;
  			PCM_PARA_RING_SIZE(&para) = RING_BUF_SIZE;
***************
*** 261,275 ****
  #endif
  			pcm = PCM_CreateMemHandle(&para);
  			if (pcm == NULL) {
! 				return;
  			}
  
  #ifndef RING_BUF_TEST
! 			/* メモリ上のファイルのサイズを設定 */
  			PCM_NotifyWriteSize(pcm, RING_BUF_SIZE);
  #endif
  
! 			/* 開始 */
  			PCM_Start(pcm);
  
  			restart = 0;
--- 261,275 ----
  #endif
  			pcm = PCM_CreateMemHandle(&para);
  			if (pcm == NULL) {
! 				return 1;
  			}
  
  #ifndef RING_BUF_TEST
! 			/* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽﾌサｿｽCｿｽYｿｽｿｽｿｽﾝ抵ｿｽ */
  			PCM_NotifyWriteSize(pcm, RING_BUF_SIZE);
  #endif
  
! 			/* ｿｽJｿｽn */
  			PCM_Start(pcm);
  
  			restart = 0;
***************
*** 293,315 ****
  				debug_write_data((Uint32)addr_data1);
  				debug_write_data((Uint32)size_copy);
  			#endif
! 			
  			PCM_NotifyWriteSize(pcm, size_copy);
  			addr_data1 += size_copy;
  		}
  #endif
  
! 		/* 再生タスク */
  		PCM_Task(pcm);
  
! 		/* 終了判定 */
  		if (PCM_GetPlayStatus(pcm) == PCM_STAT_PLAY_END) {
  
! 			/* ハンドルの消去 */
  			PCM_DestroyMemHandle(pcm);
  
  			restart = 1;
  		}
  	}
  }
! 
\ No newline at end of file
--- 293,316 ----
  				debug_write_data((Uint32)addr_data1);
  				debug_write_data((Uint32)size_copy);
  			#endif
! 
  			PCM_NotifyWriteSize(pcm, size_copy);
  			addr_data1 += size_copy;
  		}
  #endif
  
! 		/* ｿｽﾄ撰ｿｽｿｽ^ｿｽXｿｽN */
  		PCM_Task(pcm);
  
! 		/* ｿｽIｿｽｿｽｿｽｿｽｿｽｿｽ */
  		if (PCM_GetPlayStatus(pcm) == PCM_STAT_PLAY_END) {
  
! 			/* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽ */
  			PCM_DestroyMemHandle(pcm);
  
  			restart = 1;
  		}
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/pcm/smppcm4/smppcm4.c sbl6_patch/segasmp/pcm/smppcm4/smppcm4.c
*** sbl6/segasmp/pcm/smppcm4/smppcm4.c	1996-02-08 05:30:22.000000000 -0500
--- sbl6_patch/segasmp/pcm/smppcm4/smppcm4.c	2023-01-08 13:54:18.000000000 -0500
***************
*** 732,738 ****
  	}
  }
  
! void main(void)
  {
  
  #ifdef USE_VDP
--- 732,738 ----
  	}
  }
  
! int main(void)
  {
  
  #ifdef USE_VDP
***************
*** 755,761 ****
  	PCM_Init();
  
  	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	PCM_DeclareUseAdpcm();
  
  	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
--- 755,761 ----
  	PCM_Init();
  
  	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	//PCM_DeclareUseAdpcm();
  
  	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
***************
*** 767,771 ****
  		smp_RestartPlay();
  #endif
  	}
  }
! 
\ No newline at end of file
--- 767,772 ----
  		smp_RestartPlay();
  #endif
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/pcm/smppcm5/smppcm5.c sbl6_patch/segasmp/pcm/smppcm5/smppcm5.c
*** sbl6/segasmp/pcm/smppcm5/smppcm5.c	1996-02-08 05:30:26.000000000 -0500
--- sbl6_patch/segasmp/pcm/smppcm5/smppcm5.c	2024-08-01 16:19:34.000000000 -0400
***************
*** 1,9 ****
  /******************************************************************************
!  *	ソフトウェアライブラリ
   *
   *	Copyright (c) 1994,1995 SEGA
   *
!  * Library	:ＰＣＭ・ＡＤＰＣＭ再生ライブラリ
   * Module 	:sample program of STREAM PLAY MODE & SEAMLESS BRANCH
   * File		:smppcm5.c
   * Date		:1995-03-31
--- 1,9 ----
  /******************************************************************************
!  *	ｿｽ\ｿｽtｿｽgｿｽEｿｽFｿｽAｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ
   *
   *	Copyright (c) 1994,1995 SEGA
   *
!  * Library	:ｿｽoｿｽbｿｽlｿｽEｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ
   * Module 	:sample program of STREAM PLAY MODE & SEAMLESS BRANCH
   * File		:smppcm5.c
   * Date		:1995-03-31
***************
*** 11,54 ****
   * Auther	:Y.T
   *
   * Comment	:
!  *		ストリームシステムを使ってＣＤ上のファイルをスムーズに連続再生する。
!  *		ＣＤ上で、後半のファイルは、前半のファイルの終了位置より後ろに配置
!  *		されている必要があります。
!  *		このサンプルプログラムは、CD-ROM XA Audio の再生もできます。プログ
!  *		ラム中の、次の宣言を有効にしてコンパイルして下さい。
   *			#define CD_ROM_XA_AUDIO
-  *		
-  * ファイル名：
-  *		 				通常のﾌｧｲﾙの再生	CD-ROM XA Audio 再生
-  *		 前半のファイル　\SAMPLE1.AIF		\PHOTO_CD\ADPCM\SEQ00002.PCD
-  *		 後半のファイル　\SAMPLE2.AIF		\PHOTO_CD\ADPCM\SEQ00030.PCD
   *
!  * パッド操作方法：
!  *　[Ａ]
!  *		前半のファイルを再生中にＡボタンを押すと、強制的に後半のファイルに
!  *		切り替えて再生を開始します。
!  *		Ａボタンを押さなければ、前半のファイルの終了後スムーズに後半のファ
!  *		イルの再生を開始します。
!  *		後半のファイルを再生中にＡボタンを押すと、そのファイルの再生を中断
!  * 		し、最初に戻ります。
   *	[START]
!  *		 一度目はポーズ、もう一度押すとポーズ解除。
   *	[UP], [DOWN]
!  *		ボリュームの設定。０〜７。初期値は７。
   *	[LEFT], [RIGHT]
!  *		パンの設定。初期値は、左も、右も最大。
!  *		パンの設定は、モノラルの再生の場合だけ有効です。
   ****************************************************************************/
  
! /*------------------------- 《プログラム選択》 -------------------------*/
  
! /* VTV, MON を使用したデバッグの時に定義する。 */
  /* #define SMPPCM_DEBUG */
  
  /* DISC type */
  /* #define CD_ROM_XA_AUDIO */
  
! /* 画面表示を行う */
  /*	#define USE_VDP	*/
  
  /* DISC */
--- 11,54 ----
   * Auther	:Y.T
   *
   * Comment	:
!  *		ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽｿｽｿｽgｿｽｿｽｿｽﾄＣｿｽcｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽXｿｽｿｽｿｽ[ｿｽYｿｽﾉ連ｿｽｿｽｿｽﾄ撰ｿｽｿｽｿｽｿｽｿｽｿｽB
!  *		ｿｽbｿｽcｿｽｿｽｿｽﾅ、ｿｽ續ｼｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽﾍ、ｿｽOｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽﾌ終ｿｽｿｽｿｽﾊ置ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾉ配ｿｽu
!  *		ｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽKｿｽvｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾜゑｿｽｿｽB
!  *		ｿｽｿｽｿｽﾌサｿｽｿｽｿｽvｿｽｿｽｿｽvｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽﾍ、CD-ROM XA Audio ｿｽﾌ再撰ｿｽｿｽｿｽｿｽﾅゑｿｽｿｽﾜゑｿｽｿｽBｿｽvｿｽｿｽｿｽO
!  *		ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ、ｿｽｿｽｿｽﾌ宣言ｿｽｿｽｿｽLｿｽｿｽｿｽﾉゑｿｽｿｽﾄコｿｽｿｽｿｽpｿｽCｿｽｿｽｿｽｿｽｿｽﾄ会ｿｽｿｽｿｽｿｽｿｽｿｽB
   *			#define CD_ROM_XA_AUDIO
   *
!  * ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽF
!  *		 				ｿｽﾊ擾ｿｽｿｽｿｽﾌｧｿｽﾙの再撰ｿｽ	CD-ROM XA Audio ｿｽﾄ撰ｿｽ
!  *		 ｿｽOｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽ@\SAMPLE1.AIF		\PHOTO_CD\ADPCM\SEQ00002.PCD
!  *		 ｿｽ續ｼｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽ@\SAMPLE2.AIF		\PHOTO_CD\ADPCM\SEQ00030.PCD
!  *
!  * ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽｿｽｿｽ@ｿｽF
!  *ｿｽ@[ｿｽ`]
!  *		ｿｽOｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽﾄ撰ｿｽｿｽｿｽｿｽﾉＡｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾆ、ｿｽｿｽｿｽｿｽｿｽIｿｽﾉ後半ｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽｿｽ
!  *		ｿｽﾘゑｿｽｿｽﾖゑｿｽｿｽﾄ再撰ｿｽｿｽｿｽｿｽJｿｽnｿｽｿｽｿｽﾜゑｿｽｿｽB
!  *		ｿｽ`ｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾎ、ｿｽOｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽﾌ終ｿｽｿｽｿｽｿｽｿｽXｿｽｿｽｿｽ[ｿｽYｿｽﾉ後半ｿｽﾌフｿｽ@
!  *		ｿｽCｿｽｿｽｿｽﾌ再撰ｿｽｿｽｿｽｿｽJｿｽnｿｽｿｽｿｽﾜゑｿｽｿｽB
!  *		ｿｽ續ｼｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽﾄ撰ｿｽｿｽｿｽｿｽﾉＡｿｽ{ｿｽ^ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾆ、ｿｽｿｽｿｽﾌフｿｽ@ｿｽCｿｽｿｽｿｽﾌ再撰ｿｽｿｽ中断
!  * 		ｿｽｿｽｿｽAｿｽﾅ擾ｿｽｿｽﾉ戻ゑｿｽｿｽﾜゑｿｽｿｽB
   *	[START]
!  *		 ｿｽｿｽｿｽxｿｽﾚはポｿｽ[ｿｽYｿｽAｿｽｿｽｿｽｿｽｿｽｿｽｿｽxｿｽｿｽｿｽｿｽｿｽﾆポｿｽ[ｿｽYｿｽｿｽｿｽｿｽｿｽB
   *	[UP], [DOWN]
!  *		ｿｽ{ｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ設抵ｿｽｿｽBｿｽOｿｽ`ｿｽVｿｽBｿｽｿｽｿｽｿｽｿｽlｿｽﾍ７ｿｽB
   *	[LEFT], [RIGHT]
!  *		ｿｽpｿｽｿｽｿｽﾌ設抵ｿｽｿｽBｿｽｿｽｿｽｿｽｿｽlｿｽﾍ、ｿｽｿｽｿｽｿｽｿｽAｿｽEｿｽｿｽｿｽﾅ托ｿｽｿｽB
!  *		ｿｽpｿｽｿｽｿｽﾌ設抵ｿｽｿｽﾍ、ｿｽｿｽｿｽmｿｽｿｽｿｽｿｽｿｽﾌ再撰ｿｽｿｽﾌ場合ｿｽｿｽｿｽｿｽｿｽLｿｽｿｽｿｽﾅゑｿｽｿｽB
   ****************************************************************************/
  
! /*------------------------- ｿｽsｿｽvｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽIｿｽｿｽｿｽt -------------------------*/
  
! /* VTV, MON ｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽfｿｽoｿｽbｿｽOｿｽﾌ趣ｿｽｿｽﾉ抵ｿｽｿｽ`ｿｽｿｽｿｽｿｽｿｽB */
  /* #define SMPPCM_DEBUG */
  
  /* DISC type */
  /* #define CD_ROM_XA_AUDIO */
  
! /* ｿｽｿｽｿｽﾊ表ｿｽｿｽｿｽｿｽｿｽsｿｽｿｽ */
  /*	#define USE_VDP	*/
  
  /* DISC */
***************
*** 57,67 ****
  /*	#define DISC_SEIMEI_HANDAN */
  #endif
  
! /* いつも STM_ExecServer を使用する */
  #define ALLWAYS_STM_EXECSERVER
  
  
! /*------------------------- 《インクルード》 -------------------------*/
  #include <stdio.h>
  #include <machine.h>
  #include <string.h>
--- 57,67 ----
  /*	#define DISC_SEIMEI_HANDAN */
  #endif
  
! /* ｿｽｿｽｿｽﾂゑｿｽ STM_ExecServer ｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽ */
  #define ALLWAYS_STM_EXECSERVER
  
  
! /*------------------------- ｿｽsｿｽCｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽhｿｽt -------------------------*/
  #include <stdio.h>
  #include <machine.h>
  #include <string.h>
***************
*** 70,76 ****
  #include "sega_sys.h"
  #include "sega_def.h"
  #include "sega_mth.h"
! #include "sega_scl.h" 
  #include "sega_int.h"
  #define  _SPR2_
  #include "sega_spr.h"
--- 70,76 ----
  #include "sega_sys.h"
  #include "sega_def.h"
  #include "sega_mth.h"
! #include "sega_scl.h"
  #include "sega_int.h"
  #define  _SPR2_
  #include "sega_spr.h"
***************
*** 84,91 ****
  
  #if	1
  /*
! **■1995-10-02	高橋智延
! **	ペリフェラルライブラリの古いＩ／Ｆ関数を削除したので。
  */
  	#include	"per_x.h"
  #endif
--- 84,91 ----
  
  #if	1
  /*
! **ｿｽｿｽ1995-10-02	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ古ゑｿｽｿｽhｿｽ^ｿｽeｿｽﾖ撰ｿｽｿｽｿｽｿｽ除ｿｽｿｽｿｽｿｽｿｽﾌで。
  */
  	#include	"per_x.h"
  #endif
***************
*** 97,200 ****
  	#define SMPPCMD_MON_Reset			smppcmd_MON_Reset
  	#define SMPPCMD_PCM_Task			smppcmd_PCM_Task
  #else
! 	#define SMPPCMD_VblIn()				
! 	#define SMPPCMD_Init(a)				
! 	#define SMPPCMD_MON_Reset()			
  	#define SMPPCMD_PCM_Task			PCM_Task
! 	#define VTV_Printf(a)				
! 	#define VTV_PRINTF(a)				
! 	#define _VTV_Printf(a)				
! 	#define _VTV_PRINTF(a)				
  #endif
  
  
! /*--------------------------- 《関数宣言》 ---------------------------*/
  
  static void smpVblIn(void);
  static void smpVblOut(void);
  #ifdef	USE_VDP
  /*
! **■1995-07-28	高橋智延
! **	今は使ってないので削除
  */
  static void smpSprEnd(void);
  #endif
  
  
! /*------------------------- 《マクロ定数》 -------------------------*/
  
! /* スプライト面のＶＲＡＭのアドレス */
  #define ADDR_VDP1 				(0x25C00000)
  
! /* ＶＲＡＭの転送先のアドレス */
  #define ADDR_VRAM_PCM 			(0x25C08000)
  
! /* ウェーブＲＡＭの転送アドレスとサンプル数 */
  #define	PCM_ADDR	((void*)0x25a20000)
  #define	PCM_SIZE	(4096L*2)				/* 2.. */
  
! /* サイズ */
  #ifdef CD_ROM_XA_AUDIO
  	#define	SECTOR_SIZE		(2324L)
  #else
  	#define	SECTOR_SIZE		(2048L)
  #endif
  
! /* リングバッファのサイズ */
  #define	RING_BUF_SIZE	(SECTOR_SIZE * 100)		/* 10.. */
  
! /* ポーズ処理用ワークのサイズ */
  #define PWORK_SIZE		(2 * 4096)
  
! /* ＴＶ画面のサイズ */
  #define DISP_XSIZE		(320)
  #define DISP_YSIZE		(224)
  
! /* 再生するファイルの数 */
  #define	FILE_NUM		2
  
! /* ボリュームの最小値，最大値 */
  #define LEVEL_MIN	(0)
  #define LEVEL_MAX	(7)
  
! /* パンの最小値，最大値，中央値 */
! #define PAN_MIN		(0)					/* 左端：左は最大、右はゼロ */
! #define PAN_MAX		(31)				/* 右端：右は最大、左はゼロ */
! #define PAN_CENTER	((PAN_MAX + 1) / 2)	/* 中央：左も、右も最大 	*/
  
! /* STM_ExecServer をコールするＶブランク周期 */
  #define VBL_RATE_STM_EXEC_SERVER		(1)
  
! /* 最大転送セクタ数 */
  #define SMP_LOAD_NUM			(10)
  
! /* １回のタスクで処理する量の上限の設定 [sample/1ch] */
  /* #define SMP_1TASK_SAMPLE		(512) */
! /* #define SMP_1TASK_SAMPLE		(600) */	/* CD-ROM XA Bmode の限界 */
! #define SMP_1TASK_SAMPLE		(1024) 
  /* #define SMP_1TASK_SAMPLE		(2048) */
  
! /* データの転送方式 (ＣＤブロック→リングバッファ)				*/
  /*		PCM_TRMODE_CPU or PCM_TRMODE_SDMA or PCM_TRMODE_SCU		*/
  #define SMP_TR_MODE_CD			(PCM_TRMODE_SDMA)
  
! /*----------------------- 《グローバル変数》 -----------------------*/
  
! /* ワークバッファ */
  static PcmWork g_movie_work[FILE_NUM];
  
! /* リングバッファ */
  static Uint32 g_movie_buf[FILE_NUM][RING_BUF_SIZE / sizeof(Uint32)];
  
! /* ポーズ処理用ワーク */
  static Sint32 pwork_addr[PWORK_SIZE / 4];
  
! /* 再生するファイル名 */
  #ifdef DISC_PHOTO_CD
  	static char *filename[] = {"SEQ00002.PCD", "SEQ00030.PCD"};
  /*	static char *filename[] = {"SEQ00002.PCD", "SEQ00005.PCD"}; */
  #else
! 	 static char *filename[] = {"SAMPLE1.AIF", "SAMPLE2.AIF"}; 
  	/* static char *filename[] = {"SAMPLE1M.AIF", "SAMPLE2M.AIF"}; */
  	/* static char *filename[] = {"F44K16S.ADP", "F44K16S2.ADP"}; */
  	/* static char *filename[] = {"F44K16M.ADP", "F44K16M2.ADP"}; */
--- 97,200 ----
  	#define SMPPCMD_MON_Reset			smppcmd_MON_Reset
  	#define SMPPCMD_PCM_Task			smppcmd_PCM_Task
  #else
! 	#define SMPPCMD_VblIn()
! 	#define SMPPCMD_Init(a)
! 	#define SMPPCMD_MON_Reset()
  	#define SMPPCMD_PCM_Task			PCM_Task
! 	#define VTV_Printf(a)
! 	#define VTV_PRINTF(a)
! 	#define _VTV_Printf(a)
! 	#define _VTV_PRINTF(a)
  #endif
  
  
! /*--------------------------- ｿｽsｿｽﾖ撰ｿｽｿｽ骭ｾｿｽt ---------------------------*/
  
  static void smpVblIn(void);
  static void smpVblOut(void);
  #ifdef	USE_VDP
  /*
! **ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽｿｽｿｽﾍ使ｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  */
  static void smpSprEnd(void);
  #endif
  
  
! /*------------------------- ｿｽsｿｽ}ｿｽNｿｽｿｽｿｽ關費ｿｽt -------------------------*/
  
! /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾊのＶｿｽqｿｽ`ｿｽlｿｽﾌアｿｽhｿｽｿｽｿｽX */
  #define ADDR_VDP1 				(0x25C00000)
  
! /* ｿｽuｿｽqｿｽ`ｿｽlｿｽﾌ転ｿｽｿｽｿｽｿｽｿｽﾌアｿｽhｿｽｿｽｿｽX */
  #define ADDR_VRAM_PCM 			(0x25C08000)
  
! /* ｿｽEｿｽFｿｽ[ｿｽuｿｽqｿｽ`ｿｽlｿｽﾌ転ｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽXｿｽﾆサｿｽｿｽｿｽvｿｽｿｽｿｽｿｽ */
  #define	PCM_ADDR	((void*)0x25a20000)
  #define	PCM_SIZE	(4096L*2)				/* 2.. */
  
! /* ｿｽTｿｽCｿｽY */
  #ifdef CD_ROM_XA_AUDIO
  	#define	SECTOR_SIZE		(2324L)
  #else
  	#define	SECTOR_SIZE		(2048L)
  #endif
  
! /* ｿｽｿｽｿｽｿｽｿｽOｿｽoｿｽbｿｽtｿｽ@ｿｽﾌサｿｽCｿｽY */
  #define	RING_BUF_SIZE	(SECTOR_SIZE * 100)		/* 10.. */
  
! /* ｿｽ|ｿｽ[ｿｽYｿｽｿｽｿｽｿｽｿｽpｿｽｿｽｿｽ[ｿｽNｿｽﾌサｿｽCｿｽY */
  #define PWORK_SIZE		(2 * 4096)
  
! /* ｿｽsｿｽuｿｽｿｽｿｽﾊのサｿｽCｿｽY */
  #define DISP_XSIZE		(320)
  #define DISP_YSIZE		(224)
  
! /* ｿｽﾄ撰ｿｽｿｽｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ撰ｿｽ */
  #define	FILE_NUM		2
  
! /* ｿｽ{ｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ最擾ｿｽｿｽlｿｽCｿｽﾅ托ｿｽｿｽl */
  #define LEVEL_MIN	(0)
  #define LEVEL_MAX	(7)
  
! /* ｿｽpｿｽｿｽｿｽﾌ最擾ｿｽｿｽlｿｽCｿｽﾅ托ｿｽｿｽlｿｽCｿｽｿｽｿｽｿｽｿｽl */
! #define PAN_MIN		(0)					/* ｿｽｿｽｿｽ[ｿｽFｿｽｿｽｿｽﾍ最托ｿｽｿｽAｿｽEｿｽﾍゼｿｽｿｽ */
! #define PAN_MAX		(31)				/* ｿｽEｿｽ[ｿｽFｿｽEｿｽﾍ最托ｿｽｿｽAｿｽｿｽｿｽﾍゼｿｽｿｽ */
! #define PAN_CENTER	((PAN_MAX + 1) / 2)	/* ｿｽｿｽｿｽｿｽｿｽFｿｽｿｽｿｽｿｽｿｽAｿｽEｿｽｿｽｿｽﾅ托ｿｽ 	*/
  
! /* STM_ExecServer ｿｽｿｽｿｽRｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽｿｽｿｽｿｽ */
  #define VBL_RATE_STM_EXEC_SERVER		(1)
  
! /* ｿｽﾅ托ｿｽｿｽ]ｿｽｿｽｿｽZｿｽNｿｽ^ｿｽｿｽ */
  #define SMP_LOAD_NUM			(10)
  
! /* ｿｽPｿｽｿｽｿｽﾌタｿｽXｿｽNｿｽﾅ擾ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾊの擾ｿｽｿｽｿｽｿｽﾌ設抵ｿｽ [sample/1ch] */
  /* #define SMP_1TASK_SAMPLE		(512) */
! /* #define SMP_1TASK_SAMPLE		(600) */	/* CD-ROM XA Bmode ｿｽﾌ鯉ｿｽｿｽE */
! #define SMP_1TASK_SAMPLE		(1024)
  /* #define SMP_1TASK_SAMPLE		(2048) */
  
! /* ｿｽfｿｽ[ｿｽ^ｿｽﾌ転ｿｽｿｽｿｽｿｽｿｽｿｽ (ｿｽbｿｽcｿｽuｿｽｿｽｿｽbｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽOｿｽoｿｽbｿｽtｿｽ@)				*/
  /*		PCM_TRMODE_CPU or PCM_TRMODE_SDMA or PCM_TRMODE_SCU		*/
  #define SMP_TR_MODE_CD			(PCM_TRMODE_SDMA)
  
! /*----------------------- ｿｽsｿｽOｿｽｿｽｿｽ[ｿｽoｿｽｿｽｿｽﾏ撰ｿｽｿｽt -----------------------*/
  
! /* ｿｽｿｽｿｽ[ｿｽNｿｽoｿｽbｿｽtｿｽ@ */
  static PcmWork g_movie_work[FILE_NUM];
  
! /* ｿｽｿｽｿｽｿｽｿｽOｿｽoｿｽbｿｽtｿｽ@ */
  static Uint32 g_movie_buf[FILE_NUM][RING_BUF_SIZE / sizeof(Uint32)];
  
! /* ｿｽ|ｿｽ[ｿｽYｿｽｿｽｿｽｿｽｿｽpｿｽｿｽｿｽ[ｿｽN */
  static Sint32 pwork_addr[PWORK_SIZE / 4];
  
! /* ｿｽﾄ撰ｿｽｿｽｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽ */
  #ifdef DISC_PHOTO_CD
  	static char *filename[] = {"SEQ00002.PCD", "SEQ00030.PCD"};
  /*	static char *filename[] = {"SEQ00002.PCD", "SEQ00005.PCD"}; */
  #else
! 	 static char *filename[] = {"SAMPLE1.AIF", "SAMPLE2.AIF"};
  	/* static char *filename[] = {"SAMPLE1M.AIF", "SAMPLE2M.AIF"}; */
  	/* static char *filename[] = {"F44K16S.ADP", "F44K16S2.ADP"}; */
  	/* static char *filename[] = {"F44K16M.ADP", "F44K16M2.ADP"}; */
***************
*** 204,214 ****
  #endif
  
  
! /* パッド情報 */
  #if	0
  /*
! **■1995-10-02	高橋智延
! **	ペリフェラルライブラリの古いＩ／Ｆ関数を削除したので。
  */
  static Uint32	PadWorkArea[7];
  static	Uint16	PadData1  = 0x0000;
--- 204,214 ----
  #endif
  
  
! /* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽ */
  #if	0
  /*
! **ｿｽｿｽ1995-10-02	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ古ゑｿｽｿｽhｿｽ^ｿｽeｿｽﾖ撰ｿｽｿｽｿｽｿｽ除ｿｽｿｽｿｽｿｽｿｽﾌで。
  */
  static Uint32	PadWorkArea[7];
  static	Uint16	PadData1  = 0x0000;
***************
*** 223,259 ****
  static volatile trigger_t	PadData2E = 0x0000;
  #endif
  
! /* ハンドルの強制切り替えフラグ */
  static Bool		g_change_flag;
  
! /* ポーズの状態 */
  static Bool		g_pause_at_once;
  
! /* ボリュームの値 */
  Sint32 g_level = LEVEL_MAX;
  
! /* パンの値：左右を 0..31 で表現する値 */
  Sint32 g_pan = PAN_CENTER;
  
! /* パンの値：引数に指定する値 */
  Sint32 g_pan_tbl[PAN_MAX + 1] = {
! 	0x1f, 0x1e, 0x1d, 0x1c, 0x1b, 0x1a, 0x19, 0x18, 
! 	0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 
! 	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
  	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
  };
  
! /* スプライト描画終了判定フラグ   TRUE : 描画終了 */
  static Bool g_spr_end;
  
! /* VblInカウンタ */
  Sint32 cnt_vbl_in = 0;
  
! /* STM_ExecServer をコールした時刻[vbl/vbl_rate]を保持 */
  Sint32 call_stm_exec_server;
  
  
! /*---------------------------- 《関数》 ----------------------------*/
  
  void errGfsFunc(void *obj, Sint32 ec)
  {
--- 223,259 ----
  static volatile trigger_t	PadData2E = 0x0000;
  #endif
  
! /* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ具ｿｽｿｽｿｽｿｽﾘゑｿｽｿｽﾖゑｿｽｿｽtｿｽｿｽｿｽO */
  static Bool		g_change_flag;
  
! /* ｿｽ|ｿｽ[ｿｽYｿｽﾌ擾ｿｽｿｽｿｽ */
  static Bool		g_pause_at_once;
  
! /* ｿｽ{ｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ値 */
  Sint32 g_level = LEVEL_MAX;
  
! /* ｿｽpｿｽｿｽｿｽﾌ値ｿｽFｿｽｿｽｿｽEｿｽｿｽ 0..31 ｿｽﾅ表ｿｽｿｽｿｽｿｽｿｽｿｽｿｽl */
  Sint32 g_pan = PAN_CENTER;
  
! /* ｿｽpｿｽｿｽｿｽﾌ値ｿｽFｿｽｿｽｿｽｿｽｿｽﾉ指ｿｽ閧ｷｿｽｿｽｿｽl */
  Sint32 g_pan_tbl[PAN_MAX + 1] = {
! 	0x1f, 0x1e, 0x1d, 0x1c, 0x1b, 0x1a, 0x19, 0x18,
! 	0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10,
! 	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  	0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
  };
  
! /* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ`ｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽｿｽｿｽtｿｽｿｽｿｽO   TRUE : ｿｽ`ｿｽｿｽｿｽIｿｽｿｽ */
  static Bool g_spr_end;
  
! /* VblInｿｽJｿｽEｿｽｿｽｿｽ^ */
  Sint32 cnt_vbl_in = 0;
  
! /* STM_ExecServer ｿｽｿｽｿｽRｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[vbl/vbl_rate]ｿｽｿｽｿｽﾛ趣ｿｽ */
  Sint32 call_stm_exec_server;
  
  
! /*---------------------------- ｿｽsｿｽﾖ撰ｿｽｿｽt ----------------------------*/
  
  void errGfsFunc(void *obj, Sint32 ec)
  {
***************
*** 272,296 ****
  
  
  
! /*====================== 画面表示の処理 ===========================*/
  
! /* フレームバッファの切り替えと、描画終了待ち。何せず単純にウエイト。 */
  void displayFrameWait(void)
  {
! 	/* フレームバッファの切り替え */
  	SCL_DisplayFrame();
  
! 	/* ＶＲＡＭからフレームバッファへの描画終了待ち */
  	g_spr_end = FALSE;
  	while (g_spr_end == FALSE) ;
  }
! /* フレームバッファの切り替えと、描画終了待ち。切り替え中にCPUは働く。 */
  void waitDisplayFrame(void)
  {
! 	/* ＶＲＡＭからフレームバッファへの(前回の)描画終了待ち */
  	while (g_spr_end == FALSE) ;
  
! 	/* フレームバッファの切り替え */
  	SCL_DisplayFrame();
  
  	g_spr_end = FALSE;
--- 272,296 ----
  
  
  
! /*====================== ｿｽｿｽｿｽﾊ表ｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
  
! /* ｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾌ切ゑｿｽｿｽﾖゑｿｽｿｽﾆ、ｿｽ`ｿｽｿｽｿｽIｿｽｿｽｿｽﾒゑｿｽｿｽBｿｽｿｽｿｽｿｽｿｽｿｽｿｽPｿｽｿｽｿｽﾉウｿｽGｿｽCｿｽgｿｽB */
  void displayFrameWait(void)
  {
! 	/* ｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾌ切ゑｿｽｿｽﾖゑｿｽ */
  	SCL_DisplayFrame();
  
! 	/* ｿｽuｿｽqｿｽ`ｿｽlｿｽｿｽｿｽｿｽｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾖの描ｿｽｿｽｿｽIｿｽｿｽｿｽﾒゑｿｽ */
  	g_spr_end = FALSE;
  	while (g_spr_end == FALSE) ;
  }
! /* ｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾌ切ゑｿｽｿｽﾖゑｿｽｿｽﾆ、ｿｽ`ｿｽｿｽｿｽIｿｽｿｽｿｽﾒゑｿｽｿｽBｿｽﾘゑｿｽｿｽﾖゑｿｽｿｽｿｽｿｽｿｽCPUｿｽﾍ難ｿｽｿｽｿｽｿｽB */
  void waitDisplayFrame(void)
  {
! 	/* ｿｽuｿｽqｿｽ`ｿｽlｿｽｿｽｿｽｿｽｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾖゑｿｽ(ｿｽOｿｽｿｽｿｽｿｽ)ｿｽ`ｿｽｿｽｿｽIｿｽｿｽｿｽﾒゑｿｽ */
  	while (g_spr_end == FALSE) ;
  
! 	/* ｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾌ切ゑｿｽｿｽﾖゑｿｽ */
  	SCL_DisplayFrame();
  
  	g_spr_end = FALSE;
***************
*** 298,312 ****
  
  #ifdef	USE_VDP
  /*
! **■1995-07-28	高橋智延
! **	今は使ってないので削除
  */
  static void dispInit(void)
  {
  #if	0
  /*
! **■1995-07-28	高橋智延
! **	使ってないので削除
  */
      Uint8  			*VRAM;
      Uint8  			val;
--- 298,312 ----
  
  #ifdef	USE_VDP
  /*
! **ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽｿｽｿｽﾍ使ｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  */
  static void dispInit(void)
  {
  #if	0
  /*
! **ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽgｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  */
      Uint8  			*VRAM;
      Uint8  			val;
***************
*** 323,333 ****
                      SCL_SP4|SCL_SP5|SCL_SP6|SCL_SP7,7);
      SCL_SetSpriteMode(SCL_TYPE1,SCL_MIX,SCL_SP_WINDOW);
  
! 	/* Ｖブランクの設定 */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  
! 	/* V_Blank Out 割り込みを待つ */
! 	(*((volatile Uint32 *)0x25fe00a4)) &= 0xfffffffc;	/* まずクリア */
  	while( !((*((volatile Uint32 *)0x25fe00a4)) & 2) );
  	PER_Init(PER_KD_PERTIM,2,PER_ID_DGT,PER_SIZE_DGT,PadWorkArea,0);
  
--- 323,333 ----
                      SCL_SP4|SCL_SP5|SCL_SP6|SCL_SP7,7);
      SCL_SetSpriteMode(SCL_TYPE1,SCL_MIX,SCL_SP_WINDOW);
  
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ設抵ｿｽ */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  
! 	/* V_Blank Out ｿｽｿｽｿｽ闕橸ｿｽﾝゑｿｽｿｽﾒゑｿｽ */
! 	(*((volatile Uint32 *)0x25fe00a4)) &= 0xfffffffc;	/* ｿｽﾜゑｿｽｿｽNｿｽｿｽｿｽA */
  	while( !((*((volatile Uint32 *)0x25fe00a4)) & 2) );
  	PER_Init(PER_KD_PERTIM,2,PER_ID_DGT,PER_SIZE_DGT,PadWorkArea,0);
  
***************
*** 335,341 ****
  	INT_SetScuFunc(INT_SCU_VBLK_OUT, smpVblOut);
  	INT_ChgMsk(INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT,INT_MSK_NULL);
  
! 	/* スプライト描画終了割り込みの設定 */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_SPR);
  	INT_SetScuFunc(INT_SCU_SPR, smpSprEnd);
  	INT_ChgMsk(INT_MSK_SPR, INT_MSK_NULL);
--- 335,341 ----
  	INT_SetScuFunc(INT_SCU_VBLK_OUT, smpVblOut);
  	INT_ChgMsk(INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT,INT_MSK_NULL);
  
! 	/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽ`ｿｽｿｽｿｽIｿｽｿｽｿｽｿｽｿｽ闕橸ｿｽﾝの設抵ｿｽ */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_SPR);
  	INT_SetScuFunc(INT_SCU_SPR, smpSprEnd);
  	INT_ChgMsk(INT_MSK_SPR, INT_MSK_NULL);
***************
*** 353,374 ****
  #endif
  
  
! /*====================== Ｖブランクの処理 ===========================*/
  
  #if	0
  /*
! **■1995-10-02	高橋智延
! **	ペリフェラルライブラリの古いＩ／Ｆ関数を削除したので。
  */
  static void vblInit(void)
  {
      set_imask(0);
  
! 	/* Ｖブランクの設定 */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  
! 	/* V_Blank Out 割り込みを待つ */
! 	(*((volatile Uint32 *)0x25fe00a4)) &= 0xfffffffc;	/* まずクリア */
  	while( !((*((volatile Uint32 *)0x25fe00a4)) & 2) );
  	PER_Init(PER_KD_PERTIM,2,PER_ID_DGT,PER_SIZE_DGT,PadWorkArea,0);
  
--- 353,374 ----
  #endif
  
  
! /*====================== ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
  
  #if	0
  /*
! **ｿｽｿｽ1995-10-02	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽyｿｽｿｽｿｽtｿｽFｿｽｿｽｿｽｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ古ゑｿｽｿｽhｿｽ^ｿｽeｿｽﾖ撰ｿｽｿｽｿｽｿｽ除ｿｽｿｽｿｽｿｽｿｽﾌで。
  */
  static void vblInit(void)
  {
      set_imask(0);
  
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ設抵ｿｽ */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  
! 	/* V_Blank Out ｿｽｿｽｿｽ闕橸ｿｽﾝゑｿｽｿｽﾒゑｿｽ */
! 	(*((volatile Uint32 *)0x25fe00a4)) &= 0xfffffffc;	/* ｿｽﾜゑｿｽｿｽNｿｽｿｽｿｽA */
  	while( !((*((volatile Uint32 *)0x25fe00a4)) & 2) );
  	PER_Init(PER_KD_PERTIM,2,PER_ID_DGT,PER_SIZE_DGT,PadWorkArea,0);
  
***************
*** 381,391 ****
  {
  	cnt_vbl_in++;
  
! 	/* ＰＣＭの VblIn 割り込み処理 */
  	PCM_VblIn();
  
  #ifdef USE_VDP
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
  	SCL_VblankStart();
  #endif
  
--- 381,391 ----
  {
  	cnt_vbl_in++;
  
! 	/* ｿｽoｿｽbｿｽlｿｽｿｽ VblIn ｿｽｿｽｿｽ闕橸ｿｽﾝ擾ｿｽｿｽｿｽ */
  	PCM_VblIn();
  
  #ifdef USE_VDP
! 	/* ｿｽOｿｽｿｽｿｽtｿｽBｿｽbｿｽNｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽﾗには趣ｿｽｿｽsｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾎなゑｿｽｿｽﾈゑｿｽ */
  	SCL_VblankStart();
  #endif
  
***************
*** 403,419 ****
  	PadData2E |= pad[1].push ^ 0xffff;
  
  #ifdef USE_VDP
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
  	SCL_VblankEnd();
  #endif
  
  }
  #else
  static void	vblInit( void ){
! 	
  	__port = PER_OpenPort();
! 	
! 	/* V-Blank割り込みルーチンの登録 */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  	INT_SetScuFunc(INT_SCU_VBLK_IN,smpVblIn);
  	INT_SetScuFunc(INT_SCU_VBLK_OUT,smpVblOut);
--- 403,419 ----
  	PadData2E |= pad[1].push ^ 0xffff;
  
  #ifdef USE_VDP
! 	/* ｿｽOｿｽｿｽｿｽtｿｽBｿｽbｿｽNｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽﾗには趣ｿｽｿｽsｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾎなゑｿｽｿｽﾈゑｿｽ */
  	SCL_VblankEnd();
  #endif
  
  }
  #else
  static void	vblInit( void ){
! 
  	__port = PER_OpenPort();
! 
! 	/* V-Blankｿｽｿｽｿｽ闕橸ｿｽﾝｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽﾌ登ｿｽ^ */
  	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
  	INT_SetScuFunc(INT_SCU_VBLK_IN,smpVblIn);
  	INT_SetScuFunc(INT_SCU_VBLK_OUT,smpVblOut);
***************
*** 421,468 ****
  }
  static void	smpVblIn( void ){
  	cnt_vbl_in++;
! 	
! 	/* ＰＣＭライブラリの VblIn ルーチンをコール */
  	PCM_VblIn();
! 	
  #if	defined( USE_VDP )
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
  	SCL_VblankStart();
  #endif
! 	
  	SMPPCMD_VblIn();
  }
  static void	smpVblOut( void ){
  #if	defined( USE_VDP )
  	SCL_VblankEnd();
  #endif
! 	
  	if( __port != NULL ){
  		SysDevice	*device;
! 		
  		if(( device = PER_GetDeviceR( &__port[0], 0 )) != NULL ){
  			trigger_t	prev = PadData1;
  			trigger_t	current = PER_GetTrigger( device );
! 			
  			PadData1  = current;
  			PadData1E = PER_GetPressEdge( prev, current );
  		}
  		if(( device = PER_GetDeviceR( &__port[1], 0 )) != NULL ){
  			trigger_t	prev = PadData2;
  			trigger_t	current = PER_GetTrigger( device );
! 			
  			PadData2  = current;
  			PadData2E = PER_GetPressEdge( prev, current );
  		}
! 		
  		PER_GetPort( __port );
  	}
  }
  #endif
  #ifdef	USE_VDP
  /*
! **■1995-07-28	高橋智延
! **	今は使ってないので削除
  */
  static void smpSprEnd(void)
  {
--- 421,468 ----
  }
  static void	smpVblIn( void ){
  	cnt_vbl_in++;
! 
! 	/* ｿｽoｿｽbｿｽlｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽ VblIn ｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽｿｽｿｽRｿｽ[ｿｽｿｽ */
  	PCM_VblIn();
! 
  #if	defined( USE_VDP )
! 	/* ｿｽOｿｽｿｽｿｽtｿｽBｿｽbｿｽNｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽｿｽﾗには趣ｿｽｿｽsｿｽｿｽｿｽﾈゑｿｽｿｽｿｽｿｽﾎなゑｿｽｿｽﾈゑｿｽ */
  	SCL_VblankStart();
  #endif
! 
  	SMPPCMD_VblIn();
  }
  static void	smpVblOut( void ){
  #if	defined( USE_VDP )
  	SCL_VblankEnd();
  #endif
! 
  	if( __port != NULL ){
  		SysDevice	*device;
! 
  		if(( device = PER_GetDeviceR( &__port[0], 0 )) != NULL ){
  			trigger_t	prev = PadData1;
  			trigger_t	current = PER_GetTrigger( device );
! 
  			PadData1  = current;
  			PadData1E = PER_GetPressEdge( prev, current );
  		}
  		if(( device = PER_GetDeviceR( &__port[1], 0 )) != NULL ){
  			trigger_t	prev = PadData2;
  			trigger_t	current = PER_GetTrigger( device );
! 
  			PadData2  = current;
  			PadData2E = PER_GetPressEdge( prev, current );
  		}
! 
  		PER_GetPort( __port );
  	}
  }
  #endif
  #ifdef	USE_VDP
  /*
! **ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽｿｽｿｽﾍ使ｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  */
  static void smpSprEnd(void)
  {
***************
*** 470,476 ****
  }
  #endif
  
! /*====================== サウンドの処理 ===========================*/
  #define SDDRVS_TSK_SIZE			(0x6000)
  #define BOOTSND_MAP_SIZE		(0x0100)
  Sint32 sddrvs_tsk[SDDRVS_TSK_SIZE / 4];
--- 470,476 ----
  }
  #endif
  
! /*====================== ｿｽTｿｽEｿｽｿｽｿｽhｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
  #define SDDRVS_TSK_SIZE			(0x6000)
  #define BOOTSND_MAP_SIZE		(0x0100)
  Sint32 sddrvs_tsk[SDDRVS_TSK_SIZE / 4];
***************
*** 509,534 ****
  }
  
  
! /*====================== ファイルの処理 ===========================*/
  
! /* ルートディレクトリにあるファイルの最大数 */
  #define MAX_DIR		100
  
! /* 同時に開くファイルの最大数 */
  #define OPEN_MAX	FILE_NUM
  
! /* ストリームグループのＩＤ */
  static StmGrpHn grp_hd;
  
  #ifdef	DISC_PHOTO_CD
  /*
! **■1995-07-28	高橋智延
! **	今は使ってないので削除
  */
! /* ディレクトリ情報管理領域 */
  static GfsDirTbl	dir_tbl, dir_tbl_1, dir_tbl_2;
  
! /* ファイル名を含んだ情報 */
  static GfsDirName dir_name[MAX_DIR];
  static GfsDirName dir_name_1[MAX_DIR];
  static GfsDirName dir_name_2[MAX_DIR];
--- 509,534 ----
  }
  
  
! /*====================== ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽ ===========================*/
  
! /* ｿｽｿｽｿｽ[ｿｽgｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽﾉゑｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ最大数 */
  #define MAX_DIR		100
  
! /* ｿｽｿｽｿｽｿｽｿｽﾉ開ｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽﾌ最大数 */
  #define OPEN_MAX	FILE_NUM
  
! /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌＩｿｽc */
  static StmGrpHn grp_hd;
  
  #ifdef	DISC_PHOTO_CD
  /*
! **ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽｿｽｿｽﾍ使ｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  */
! /* ｿｽfｿｽBｿｽｿｽｿｽNｿｽgｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾌ茨ｿｽ */
  static GfsDirTbl	dir_tbl, dir_tbl_1, dir_tbl_2;
  
! /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾜんだ擾ｿｽｿｽｿｽ */
  static GfsDirName dir_name[MAX_DIR];
  static GfsDirName dir_name_1[MAX_DIR];
  static GfsDirName dir_name_2[MAX_DIR];
***************
*** 537,551 ****
  static GfsDirName	dir_name[MAX_DIR];
  #endif
  
! /* ＧＦＳの作業領域 */
  static Uint8 g_gfs_work[GFS_WORK_SIZE(OPEN_MAX)];
  
  static Uint8 g_stm_work[STM_WORK_SIZE(12, 24)];
  
  #ifdef	DISC_PHOTO_CD
  /*
! **■1995-07-28	高橋智延
! **	今は使ってないので削除
  */
  static void changeDir(char *fname, GfsDirTbl *dir_tbl, GfsDirName *dir_name)
  {
--- 537,551 ----
  static GfsDirName	dir_name[MAX_DIR];
  #endif
  
! /* ｿｽfｿｽeｿｽrｿｽﾌ搾ｿｽｿｽﾆ領茨ｿｽ */
  static Uint8 g_gfs_work[GFS_WORK_SIZE(OPEN_MAX)];
  
  static Uint8 g_stm_work[STM_WORK_SIZE(12, 24)];
  
  #ifdef	DISC_PHOTO_CD
  /*
! **ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! **	ｿｽｿｽｿｽﾍ使ｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  */
  static void changeDir(char *fname, GfsDirTbl *dir_tbl, GfsDirName *dir_name)
  {
***************
*** 574,608 ****
  {
  	Sint32 file_num;
  
! 	/* GFSの初期化 */
  	GFS_DIRTBL_TYPE(&dir_tbl) = GFS_DIR_NAME;
  	GFS_DIRTBL_DIRNAME(&dir_tbl) = dir_name;
  	GFS_DIRTBL_NDIR(&dir_tbl) = MAX_DIR;
  
!     /* ファイルシステムの初期化 */
      file_num = GFS_Init(OPEN_MAX, g_gfs_work, &dir_tbl);
  	if (file_num < 0) {
  		return;
  	}
  
! 	/* エラー関数の設定 */
  	GFS_SetErrFunc(errGfsFunc, NULL);
  }
  
  static void stmInit(void)
  {
  #ifdef DISC_PHOTO_CD
! 	changeDir("PHOTO_CD", &dir_tbl_1, dir_name_1); 
  	changeDir("ADPCM", &dir_tbl_2, dir_name_2);
  #endif
  
! 	/* ストリームシステムの初期化 */
  	STM_Init(12, 24, g_stm_work);
  
! 	/* エラー関数の設定 */
  	STM_SetErrFunc(errStmFunc, NULL);
  
! 	/* ストリームグループのオープン */
  	grp_hd = STM_OpenGrp();
  	if (grp_hd == NULL) {
  		return;
--- 574,608 ----
  {
  	Sint32 file_num;
  
! 	/* GFSｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	GFS_DIRTBL_TYPE(&dir_tbl) = GFS_DIR_NAME;
  	GFS_DIRTBL_DIRNAME(&dir_tbl) = dir_name;
  	GFS_DIRTBL_NDIR(&dir_tbl) = MAX_DIR;
  
!     /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
      file_num = GFS_Init(OPEN_MAX, g_gfs_work, &dir_tbl);
  	if (file_num < 0) {
  		return;
  	}
  
! 	/* ｿｽGｿｽｿｽｿｽ[ｿｽﾖ撰ｿｽｿｽﾌ設抵ｿｽ */
  	GFS_SetErrFunc(errGfsFunc, NULL);
  }
  
  static void stmInit(void)
  {
  #ifdef DISC_PHOTO_CD
! 	changeDir("PHOTO_CD", &dir_tbl_1, dir_name_1);
  	changeDir("ADPCM", &dir_tbl_2, dir_name_2);
  #endif
  
! 	/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	STM_Init(12, 24, g_stm_work);
  
! 	/* ｿｽGｿｽｿｽｿｽ[ｿｽﾖ撰ｿｽｿｽﾌ設抵ｿｽ */
  	STM_SetErrFunc(errStmFunc, NULL);
  
! 	/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽOｿｽｿｽｿｽ[ｿｽvｿｽﾌオｿｽ[ｿｽvｿｽｿｽ */
  	grp_hd = STM_OpenGrp();
  	if (grp_hd == NULL) {
  		return;
***************
*** 617,632 ****
  	StmKey key;
  #if	0
  	/*
! 	**■1995-07-28	高橋智延
! 	**	使ってないので削除
  	*/
  	Sint32 fad;
  	Sint32 i;
  #endif
  
!     /* ファイル名からファイル識別子を求める */
      fid = GFS_NameToId((Sint8 *)fname);
! 	STM_KEY_FN(&key) = STM_KEY_CN(&key) = STM_KEY_SMMSK(&key) = 
  		STM_KEY_SMVAL(&key) = STM_KEY_CIMSK(&key) = STM_KEY_CIVAL(&key) =
  		STM_KEY_NONE;
  
--- 617,632 ----
  	StmKey key;
  #if	0
  	/*
! 	**ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! 	**	ｿｽgｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  	*/
  	Sint32 fad;
  	Sint32 i;
  #endif
  
!     /* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽﾊ子ｿｽｿｽｿｽｿｽｿｽﾟゑｿｽ */
      fid = GFS_NameToId((Sint8 *)fname);
! 	STM_KEY_FN(&key) = STM_KEY_CN(&key) = STM_KEY_SMMSK(&key) =
  		STM_KEY_SMVAL(&key) = STM_KEY_CIMSK(&key) = STM_KEY_CIVAL(&key) =
  		STM_KEY_NONE;
  
***************
*** 636,646 ****
  #endif
  
  #ifdef DISC_PHOTO_CD
! 	/* Stream system (Ver1.13) can't get correct file size, that file was 
! 	 * intreleaveed in Photo CD disc. 
  	 */
  
! 	/* fidとオフセット(==0)からフレームアドレスを取得する */
  	fad = GFS_GetFad(fid, 0);
  
  	/* search dir_name table */
--- 636,646 ----
  #endif
  
  #ifdef DISC_PHOTO_CD
! 	/* Stream system (Ver1.13) can't get correct file size, that file was
! 	 * intreleaveed in Photo CD disc.
  	 */
  
! 	/* fidｿｽﾆオｿｽtｿｽZｿｽbｿｽg(==0)ｿｽｿｽｿｽｿｽｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽXｿｽｿｽｿｽ謫ｾｿｽｿｽｿｽｿｽ */
  	fad = GFS_GetFad(fid, 0);
  
  	/* search dir_name table */
***************
*** 671,684 ****
  	Sint32		bn;
  	StmKey		stmkey;
  
! 	/* ストリームの再生範囲を取得する */
  	STM_GetInfo(stm, &fid, &frange, &bn, &stmkey);
  
! 	/* 再生中のＦＡＤの位置を取得する */
  	STM_GetExecStat(grp_hd, &fad);
! 	
  	if (fad < STM_FRANGE_SFAD(&frange)) {
! 		/* ピックアップの移動 */
  		STM_MovePickup(stm, 0);
  		return TRUE;
  	} else {
--- 671,684 ----
  	Sint32		bn;
  	StmKey		stmkey;
  
! 	/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌ再撰ｿｽｿｽﾍ囲ゑｿｽｿｽ謫ｾｿｽｿｽｿｽｿｽ */
  	STM_GetInfo(stm, &fid, &frange, &bn, &stmkey);
  
! 	/* ｿｽﾄ撰ｿｽｿｽｿｽｿｽﾌＦｿｽ`ｿｽcｿｽﾌ位置ｿｽｿｽｿｽ謫ｾｿｽｿｽｿｽｿｽ */
  	STM_GetExecStat(grp_hd, &fad);
! 
  	if (fad < STM_FRANGE_SFAD(&frange)) {
! 		/* ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽﾌ移難ｿｽ */
  		STM_MovePickup(stm, 0);
  		return TRUE;
  	} else {
***************
*** 693,699 ****
  	Sint32		bn;
  	StmKey		stmkey;
  
! 	/* ストリーム情報の取得			*/
  	STM_GetInfo(stm, &fid, &frange, &bn, &stmkey);
  
  	if (fad >= STM_FRANGE_SFAD(&frange) &&
--- 693,699 ----
  	Sint32		bn;
  	StmKey		stmkey;
  
! 	/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾌ取得			*/
  	STM_GetInfo(stm, &fid, &frange, &bn, &stmkey);
  
  	if (fad >= STM_FRANGE_SFAD(&frange) &&
***************
*** 704,716 ****
  	}
  }
  
! /* ストリームシステムサーバの実行 */
  static void smpStmTask(StmHn stm[])
  {
  #if	0
  	/*
! 	**■1995-07-28	高橋智延
! 	**	使ってないので削除
  	*/
  	Sint32 		stat, fad, flag_stm_exec_trans;
  #endif
--- 704,716 ----
  	}
  }
  
! /* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽTｿｽ[ｿｽoｿｽﾌ趣ｿｽｿｽs */
  static void smpStmTask(StmHn stm[])
  {
  #if	0
  	/*
! 	**ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! 	**	ｿｽgｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  	*/
  	Sint32 		stat, fad, flag_stm_exec_trans;
  #endif
***************
*** 728,734 ****
  			STM_ExecServer();
  		} else {
  
! 			/* 必要な場合だけ STM_ExecServer をコールする */
  			flag_stm_exec_trans = 0;
  			if (STM_GetNumCdbuf(stm[0]) > 0) {
  				STM_ExecTrans(stm[0]);
--- 728,734 ----
  			STM_ExecServer();
  		} else {
  
! 			/* ｿｽKｿｽvｿｽﾈ場合ｿｽｿｽｿｽｿｽ STM_ExecServer ｿｽｿｽｿｽRｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽ */
  			flag_stm_exec_trans = 0;
  			if (STM_GetNumCdbuf(stm[0]) > 0) {
  				STM_ExecTrans(stm[0]);
***************
*** 756,771 ****
  	}
  }
  
! /* ＰＣＭ・ＡＤＰＣＭ再生ライブラリの初期化 */
  void smpPcmInit(void)
  {
! 	/* ＰＣＭ・ＡＤＰＣＭ再生ライブラリの初期化 */
  	PCM_Init();
  
! 	/* ＡＤＰＣＭ使用宣言 (ADPCM伸張ﾗｲﾌﾞﾗﾘがﾘﾝｸされます) */
! 	PCM_DeclareUseAdpcm();
  
! 	/* ＰＣＭライブラリのエラーハンドルの設定 */
  	PCM_SetErrFunc(errPcmFunc, NULL);
  }
  
--- 756,771 ----
  	}
  }
  
! /* ｿｽoｿｽbｿｽlｿｽEｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  void smpPcmInit(void)
  {
! 	/* ｿｽoｿｽbｿｽlｿｽEｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	PCM_Init();
  
! 	/* ｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽgｿｽpｿｽ骭ｾ (ADPCMｿｽLｿｽｿｽﾗｲｿｽｿｽｿｽﾘゑｿｽｿｽﾝｸｿｽｿｽｿｽｿｽｿｽﾜゑｿｽ) */
! 	//PCM_DeclareUseAdpcm();
  
! 	/* ｿｽoｿｽbｿｽlｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌエｿｽｿｽｿｽ[ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ設抵ｿｽ */
  	PCM_SetErrFunc(errPcmFunc, NULL);
  }
  
***************
*** 774,788 ****
  {
  #if	0
  	/*
! 	**■1995-07-28	高橋智延
! 	**	使ってないので削除
  	*/
  	static Uint32 movie_x, movie_y;
  #endif
  	PcmCreatePara	para;
  	PcmHn			pcm;
  
! 	/* ハンドルの作成 */
  	PCM_PARA_WORK(&para) = (struct PcmWork *)&g_movie_work[file_no];
  	PCM_PARA_RING_ADDR(&para) = (Sint8 *)g_movie_buf[file_no];
  	PCM_PARA_RING_SIZE(&para) = RING_BUF_SIZE;
--- 774,788 ----
  {
  #if	0
  	/*
! 	**ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! 	**	ｿｽgｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  	*/
  	static Uint32 movie_x, movie_y;
  #endif
  	PcmCreatePara	para;
  	PcmHn			pcm;
  
! 	/* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ作成 */
  	PCM_PARA_WORK(&para) = (struct PcmWork *)&g_movie_work[file_no];
  	PCM_PARA_RING_ADDR(&para) = (Sint8 *)g_movie_buf[file_no];
  	PCM_PARA_RING_SIZE(&para) = RING_BUF_SIZE;
***************
*** 794,800 ****
  	}
  
  	if (file_no == 0) {
! 		/* ピックアップの移動 */
  		STM_MovePickup(stm, 0);
  	}
  
--- 794,800 ----
  	}
  
  	if (file_no == 0) {
! 		/* ｿｽsｿｽbｿｽNｿｽAｿｽbｿｽvｿｽﾌ移難ｿｽ */
  		STM_MovePickup(stm, 0);
  	}
  
***************
*** 807,846 ****
  {
  	int		i;
  
! 	/* ストリームシステムサーバの実行 */
  	smpStmTask(stm);
  
! 	/* 再生タスク */
  	SMPPCMD_PCM_Task(pcm[0]);
  
  	for (i = 1; i < FILE_NUM; i++) {
! 		/* 再生タスク */
  		PCM_Task(pcm[i]);
  	}
  }
  
  
  /********************************************************************/
! /* パッド制御														*/
  /********************************************************************/
  
! /* パッド制御：再生ライブラリ */
  void smp_PadCtrlPcm(PcmHn pcm[], StmHn stm[], Uint16 PadData1EW, Uint16 PadData1W)
  {
  	int		i;
  
! 	/* ポーズ */
  	if (PadData1EW & PER_DGT_S) {
  		PadData1EW = 0;
  		if (g_pause_at_once == FALSE) {
! 			/* 開始 */
  			g_pause_at_once = TRUE;
  			for (i = 0; i < FILE_NUM; i++) {
  				PCM_SetPauseWork(pwork_addr, PWORK_SIZE);
  				PCM_Pause(pcm[i], PCM_PAUSE_ON_AT_ONCE);
  			}
  		} else {
! 			/* 解除 */
  			g_pause_at_once = FALSE;
  			for (i = 0; i < FILE_NUM; i++) {
  				PCM_Pause(pcm[i], PCM_PAUSE_OFF);
--- 807,846 ----
  {
  	int		i;
  
! 	/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽTｿｽ[ｿｽoｿｽﾌ趣ｿｽｿｽs */
  	smpStmTask(stm);
  
! 	/* ｿｽﾄ撰ｿｽｿｽ^ｿｽXｿｽN */
  	SMPPCMD_PCM_Task(pcm[0]);
  
  	for (i = 1; i < FILE_NUM; i++) {
! 		/* ｿｽﾄ撰ｿｽｿｽ^ｿｽXｿｽN */
  		PCM_Task(pcm[i]);
  	}
  }
  
  
  /********************************************************************/
! /* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽ														*/
  /********************************************************************/
  
! /* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽFｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ */
  void smp_PadCtrlPcm(PcmHn pcm[], StmHn stm[], Uint16 PadData1EW, Uint16 PadData1W)
  {
  	int		i;
  
! 	/* ｿｽ|ｿｽ[ｿｽY */
  	if (PadData1EW & PER_DGT_S) {
  		PadData1EW = 0;
  		if (g_pause_at_once == FALSE) {
! 			/* ｿｽJｿｽn */
  			g_pause_at_once = TRUE;
  			for (i = 0; i < FILE_NUM; i++) {
  				PCM_SetPauseWork(pwork_addr, PWORK_SIZE);
  				PCM_Pause(pcm[i], PCM_PAUSE_ON_AT_ONCE);
  			}
  		} else {
! 			/* ｿｽｿｽｿｽｿｽ */
  			g_pause_at_once = FALSE;
  			for (i = 0; i < FILE_NUM; i++) {
  				PCM_Pause(pcm[i], PCM_PAUSE_OFF);
***************
*** 848,854 ****
  		}
  	}
  
! 	/* ストップ */
  	if (PCM_GetPlayStatus(pcm[FILE_NUM - 2]) == PCM_STAT_PLAY_END) {
  		if (PadData1EW & PER_DGT_A) {
  			PadData1EW = 0;
--- 848,854 ----
  		}
  	}
  
! 	/* ｿｽXｿｽgｿｽbｿｽv */
  	if (PCM_GetPlayStatus(pcm[FILE_NUM - 2]) == PCM_STAT_PLAY_END) {
  		if (PadData1EW & PER_DGT_A) {
  			PadData1EW = 0;
***************
*** 856,869 ****
  		}
  	}
  
! 	/* チェンジ */
  	if ((g_change_flag == FALSE) && (PadData1EW & PER_DGT_A)) {
  		PadData1EW = 0;
  		if (goNextStm(stm[1])) {
  			g_change_flag = TRUE;
  		}
  	}
! 	/* ハンドルの強制切り替え */
  	if (g_change_flag == TRUE) {
  		if (PCM_CheckChange() == PCM_CHANGE_OK_AT_ONCE) {
  			PCM_Change();
--- 856,869 ----
  		}
  	}
  
! 	/* ｿｽ`ｿｽFｿｽｿｽｿｽW */
  	if ((g_change_flag == FALSE) && (PadData1EW & PER_DGT_A)) {
  		PadData1EW = 0;
  		if (goNextStm(stm[1])) {
  			g_change_flag = TRUE;
  		}
  	}
! 	/* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ具ｿｽｿｽｿｽｿｽﾘゑｿｽｿｽﾖゑｿｽ */
  	if (g_change_flag == TRUE) {
  		if (PCM_CheckChange() == PCM_CHANGE_OK_AT_ONCE) {
  			PCM_Change();
***************
*** 871,877 ****
  		}
  	}
  
! 	/* ボリューム・アップ */
  	if (PadData1EW & PER_DGT_U) {
  		PadData1EW = 0;
  		g_level = MIN(g_level + 1, LEVEL_MAX);
--- 871,877 ----
  		}
  	}
  
! 	/* ｿｽ{ｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽEｿｽAｿｽbｿｽv */
  	if (PadData1EW & PER_DGT_U) {
  		PadData1EW = 0;
  		g_level = MIN(g_level + 1, LEVEL_MAX);
***************
*** 880,886 ****
  			PCM_ChangePcmPara(pcm[i]);
  		}
  	}
! 	/* ボリューム・ダウン */
  	if (PadData1EW & PER_DGT_D) {
  		PadData1EW = 0;
  		g_level = MAX(g_level - 1, LEVEL_MIN);
--- 880,886 ----
  			PCM_ChangePcmPara(pcm[i]);
  		}
  	}
! 	/* ｿｽ{ｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽEｿｽ_ｿｽEｿｽｿｽ */
  	if (PadData1EW & PER_DGT_D) {
  		PadData1EW = 0;
  		g_level = MAX(g_level - 1, LEVEL_MIN);
***************
*** 890,896 ****
  		}
  	}
  
! 	/* パン・右より（右最大、左を徐々に弱く） */
  	if (PadData1EW & PER_DGT_R) {
  		PadData1EW = 0;
  		g_pan = MIN(g_pan + 1, PAN_MAX);
--- 890,896 ----
  		}
  	}
  
! 	/* ｿｽpｿｽｿｽｿｽEｿｽEｿｽｿｽｿｽｿｽｿｽiｿｽEｿｽﾅ托ｿｽｿｽAｿｽｿｽｿｽｿｽｿｽｿｽｿｽXｿｽﾉ弱くｿｽj */
  	if (PadData1EW & PER_DGT_R) {
  		PadData1EW = 0;
  		g_pan = MIN(g_pan + 1, PAN_MAX);
***************
*** 899,905 ****
  			PCM_ChangePcmPara(pcm[i]);
  		}
  	}
! 	/* パン・左より（左最大、右を徐々に弱く） */
  	if (PadData1EW & PER_DGT_L) {
  		PadData1EW = 0;
  		g_pan = MAX(g_pan - 1, PAN_MIN);
--- 899,905 ----
  			PCM_ChangePcmPara(pcm[i]);
  		}
  	}
! 	/* ｿｽpｿｽｿｽｿｽEｿｽｿｽｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽﾅ托ｿｽｿｽAｿｽEｿｽｿｽｿｽｿｽｿｽXｿｽﾉ弱くｿｽj */
  	if (PadData1EW & PER_DGT_L) {
  		PadData1EW = 0;
  		g_pan = MAX(g_pan - 1, PAN_MIN);
***************
*** 917,923 ****
  #endif
  Sint32 smp_pad_mode = 0;
  
! /* パッド制御 */
  void smp_PadCtrl(PcmHn pcm[], StmHn stm[])
  {
  	Uint16   PadData1EW;
--- 917,923 ----
  #endif
  Sint32 smp_pad_mode = 0;
  
! /* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽ */
  void smp_PadCtrl(PcmHn pcm[], StmHn stm[])
  {
  	Uint16   PadData1EW;
***************
*** 928,934 ****
  	PadData1W = PadData1;
  	PadData1 = 0;
  
! 	/* パッド処理対象の切り替え */
  	if (PadData1EW & PER_DGT_TL) {
  		PadData1EW = 0;
  		smp_pad_mode++;
--- 928,934 ----
  	PadData1W = PadData1;
  	PadData1 = 0;
  
! 	/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽﾎ象の切ゑｿｽｿｽﾖゑｿｽ */
  	if (PadData1EW & PER_DGT_TL) {
  		PadData1EW = 0;
  		smp_pad_mode++;
***************
*** 936,969 ****
  
  	switch (smp_pad_mode % SMP_PAD_MODE_NUM) {
  	case 0:
! 		/* パッド制御：再生ライブラリ */
  		smp_PadCtrlPcm(pcm, stm, PadData1EW, PadData1W);
  		break;
  #ifdef VTV
  	case 1:
! 		/* パッド制御：一般出力用の VTV */
  		smp_PadCtrlVtv0(PadData1EW, PadData1W);
  		break;
  #endif
  #ifdef MONITOR_TASK
  	case 2:
! 		/* パッド制御：モニタ用の VTV */
  		smp_PadCtrlVtv1(PadData1EW, PadData1W);
  		break;
  	case 3:
! 		/* パッド制御：モニタ用 */
  		smp_PadCtrlMon(PadData1EW, PadData1W);
  		break;
  #endif
  	}
  }
  
! void main(void)
  {
  #if	0
  	/*
! 	**■1995-07-28	高橋智延
! 	**	使ってないので削除
  	*/
  	PcmHn 			pcm[FILE_NUM];
  	StmHn			stm[FILE_NUM];
--- 936,969 ----
  
  	switch (smp_pad_mode % SMP_PAD_MODE_NUM) {
  	case 0:
! 		/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽFｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽ */
  		smp_PadCtrlPcm(pcm, stm, PadData1EW, PadData1W);
  		break;
  #ifdef VTV
  	case 1:
! 		/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽFｿｽｿｽｿｽﾊ出ｿｽﾍ用ｿｽｿｽ VTV */
  		smp_PadCtrlVtv0(PadData1EW, PadData1W);
  		break;
  #endif
  #ifdef MONITOR_TASK
  	case 2:
! 		/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽFｿｽｿｽｿｽjｿｽ^ｿｽpｿｽｿｽ VTV */
  		smp_PadCtrlVtv1(PadData1EW, PadData1W);
  		break;
  	case 3:
! 		/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽｿｽFｿｽｿｽｿｽjｿｽ^ｿｽp */
  		smp_PadCtrlMon(PadData1EW, PadData1W);
  		break;
  #endif
  	}
  }
  
! int main(void)
  {
  #if	0
  	/*
! 	**ｿｽｿｽ1995-07-28	ｿｽｿｽｿｽｿｽｿｽqｿｽｿｽ
! 	**	ｿｽgｿｽｿｽｿｽﾄなゑｿｽｿｽﾌで削除
  	*/
  	PcmHn 			pcm[FILE_NUM];
  	StmHn			stm[FILE_NUM];
***************
*** 977,1008 ****
  	int		i;
  #endif
  
! 	/* 変数の初期化 */
  /*	g_spr_end = FALSE; */
  	g_spr_end = TRUE;
  	g_change_flag = FALSE;
  	g_pause_at_once = FALSE;
  
! 	/* ＰＣＭ・ＡＤＰＣＭ再生ライブラリの初期化 */
  	smpPcmInit();
  
  #ifdef USE_VDP
! 	/* スプライトの設定 */
  	dispInit();
  #else
! 	/* Ｖブランクの設定 */
  	vblInit();
  #endif
  
  	SMPPCMD_Init(0);
  
! 	/* ファイル初期化 */
  	fileInit();
  
! 	/* サウンドの設定 */
  	sndInit();
  
! 	/* ストリームシステムの初期化 */
  	stmInit();
  
  	restart = 1;
--- 977,1008 ----
  	int		i;
  #endif
  
! 	/* ｿｽﾏ撰ｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  /*	g_spr_end = FALSE; */
  	g_spr_end = TRUE;
  	g_change_flag = FALSE;
  	g_pause_at_once = FALSE;
  
! 	/* ｿｽoｿｽbｿｽlｿｽEｿｽ`ｿｽcｿｽoｿｽbｿｽlｿｽﾄ撰ｿｽｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	smpPcmInit();
  
  #ifdef USE_VDP
! 	/* ｿｽXｿｽvｿｽｿｽｿｽCｿｽgｿｽﾌ設抵ｿｽ */
  	dispInit();
  #else
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽﾌ設抵ｿｽ */
  	vblInit();
  #endif
  
  	SMPPCMD_Init(0);
  
! 	/* ｿｽtｿｽ@ｿｽCｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  	fileInit();
  
! 	/* ｿｽTｿｽEｿｽｿｽｿｽhｿｽﾌ設抵ｿｽ */
  	sndInit();
  
! 	/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  	stmInit();
  
  	restart = 1;
***************
*** 1010,1032 ****
  	for (;;) {
  		if (restart) {
  
! 			/* ストリームオープン */
  			for (i = 0; i < FILE_NUM; i++) {
  				if ((stm[i] = stmOpen(filename[i])) == NULL) {
! 					return;
  				}
! 				/* 取り出し領域のリセット
! 				 *	ストリームシステムの仕様が...
! 				 *	最初の転送を STM_ExecServer で行うなら、これは不要。
  				*/
  				STM_ResetTrBuf(stm[i]);
  
! 				/* ハンドルの作成 */
  				if ((pcm[i] = createHandle(stm[i], i)) == NULL) {
! 					return;
  				}
  #ifdef CD_ROM_XA_AUDIO
! 				/* 再生情報の設定(CD-ROM XA Audio sector の場合) */
  				PCM_INFO_FILE_TYPE(&info) = PCM_FILE_TYPE_NO_HEADER;
  				PCM_INFO_DATA_TYPE(&info) = PCM_DATA_TYPE_ADPCM_SCT;
  				PCM_SetInfo(pcm[i], &info);
--- 1010,1032 ----
  	for (;;) {
  		if (restart) {
  
! 			/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽIｿｽ[ｿｽvｿｽｿｽ */
  			for (i = 0; i < FILE_NUM; i++) {
  				if ((stm[i] = stmOpen(filename[i])) == NULL) {
! 					return 1;
  				}
! 				/* ｿｽｿｽｿｽｿｽｿｽoｿｽｿｽｿｽﾌ茨ｿｽｿｽﾌｿｽｿｽZｿｽbｿｽg
! 				 *	ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽVｿｽXｿｽeｿｽｿｽｿｽﾌ仕ｿｽlｿｽｿｽ...
! 				 *	ｿｽﾅ擾ｿｽｿｽﾌ転ｿｽｿｽｿｽｿｽ STM_ExecServer ｿｽﾅ行ｿｽｿｽｿｽﾈゑｿｽｿｽAｿｽｿｽｿｽｿｽｿｽﾍ不ｿｽvｿｽB
  				*/
  				STM_ResetTrBuf(stm[i]);
  
! 				/* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ作成 */
  				if ((pcm[i] = createHandle(stm[i], i)) == NULL) {
! 					return 1;
  				}
  #ifdef CD_ROM_XA_AUDIO
! 				/* ｿｽﾄ撰ｿｽｿｽｿｽｿｽｿｽｿｽﾌ設抵ｿｽ(CD-ROM XA Audio sector ｿｽﾌ場合) */
  				PCM_INFO_FILE_TYPE(&info) = PCM_FILE_TYPE_NO_HEADER;
  				PCM_INFO_DATA_TYPE(&info) = PCM_DATA_TYPE_ADPCM_SCT;
  				PCM_SetInfo(pcm[i], &info);
***************
*** 1036,1048 ****
  				PCM_Set1TaskSample(pcm[i], SMP_1TASK_SAMPLE);
  			}
  
! 			/* 開始 */
  			PCM_Start(pcm[0]);
  
! 			/* 次に再生するハンドルの登録 */
  			PCM_EntryNext(pcm[1]);
  
! 			/* 最初に STM_ExecServer をコールさせる */
  			call_stm_exec_server = -1;
  
  			restart = 0;
--- 1036,1048 ----
  				PCM_Set1TaskSample(pcm[i], SMP_1TASK_SAMPLE);
  			}
  
! 			/* ｿｽJｿｽn */
  			PCM_Start(pcm[0]);
  
! 			/* ｿｽｿｽｿｽﾉ再撰ｿｽｿｽｿｽｿｽｿｽｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ登ｿｽ^ */
  			PCM_EntryNext(pcm[1]);
  
! 			/* ｿｽﾅ擾ｿｽｿｽｿｽ STM_ExecServer ｿｽｿｽｿｽRｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ */
  			call_stm_exec_server = -1;
  
  			restart = 0;
***************
*** 1050,1059 ****
  			VTV_PRINTF((VTV_s, "S:Restart %X\n", pcm[0]));
  		}
  
! 		/* 再生タスク */
  		pcmTask(pcm, stm);
  
! 		/* パッド制御 */
  		smp_PadCtrl(pcm, stm);
  
  #ifdef USE_VDP
--- 1050,1059 ----
  			VTV_PRINTF((VTV_s, "S:Restart %X\n", pcm[0]));
  		}
  
! 		/* ｿｽﾄ撰ｿｽｿｽ^ｿｽXｿｽN */
  		pcmTask(pcm, stm);
  
! 		/* ｿｽpｿｽbｿｽhｿｽｿｽｿｽｿｽ */
  		smp_PadCtrl(pcm, stm);
  
  #ifdef USE_VDP
***************
*** 1061,1067 ****
  			MON_UnitStart(smpmon_hn, smpmon_uhn[3]);
  		#endif
  
! 		/* フレームバッファの切り替えと、描画終了待ち */
  		waitDisplayFrame();
  
  		#ifdef MONITOR_TASK
--- 1061,1067 ----
  			MON_UnitStart(smpmon_hn, smpmon_uhn[3]);
  		#endif
  
! 		/* ｿｽtｿｽｿｽｿｽ[ｿｽｿｽｿｽoｿｽbｿｽtｿｽ@ｿｽﾌ切ゑｿｽｿｽﾖゑｿｽｿｽﾆ、ｿｽ`ｿｽｿｽｿｽIｿｽｿｽｿｽﾒゑｿｽ */
  		waitDisplayFrame();
  
  		#ifdef MONITOR_TASK
***************
*** 1069,1082 ****
  		#endif
  #endif
  
! 		/* 終了判定 */
  		if (PCM_GetPlayStatus(pcm[FILE_NUM-1]) == PCM_STAT_PLAY_END) {
  
  			for (i = 0; i < FILE_NUM; i++) {
! 				/* ハンドルの消去 */
  				PCM_DestroyStmHandle(pcm[i]);
  
! 				/* ストリームのクローズ*/
  				stmClose(stm[i]);
  			}
  
--- 1069,1082 ----
  		#endif
  #endif
  
! 		/* ｿｽIｿｽｿｽｿｽｿｽｿｽｿｽ */
  		if (PCM_GetPlayStatus(pcm[FILE_NUM-1]) == PCM_STAT_PLAY_END) {
  
  			for (i = 0; i < FILE_NUM; i++) {
! 				/* ｿｽnｿｽｿｽｿｽhｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽ */
  				PCM_DestroyStmHandle(pcm[i]);
  
! 				/* ｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌクｿｽｿｽｿｽ[ｿｽY*/
  				stmClose(stm[i]);
  			}
  
***************
*** 1085,1089 ****
  			restart = 1;
  		}
  	}
  }
! 
\ No newline at end of file
--- 1085,1090 ----
  			restart = 1;
  		}
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/per/smpper0/smpper0.c sbl6_patch/segasmp/per/smpper0/smpper0.c
*** sbl6/segasmp/per/smpper0/smpper0.c	1996-02-08 05:30:36.000000000 -0500
--- sbl6_patch/segasmp/per/smpper0/smpper0.c	2023-01-02 18:17:46.000000000 -0500
***************
*** 111,117 ****
   ******************************************************************************
   */
  
! void main(void)
  {
      Uint8 set_tim_data[7];
      Uint32 back_v_blank_out_cnt;
--- 111,117 ----
   ******************************************************************************
   */
  
! int main(void)
  {
      Uint8 set_tim_data[7];
      Uint32 back_v_blank_out_cnt;
***************
*** 169,174 ****
--- 169,176 ----
  
  	/* ここに来る事ってあんの？	*/
      for(;;);
+     
+     return 0;
  }
  /******************************************************************************
   *
***************
*** 216,219 ****
               per_work,      /* WORK */
               0);            /* V_BLANK SKIP */
  }
! 
\ No newline at end of file
--- 218,221 ----
               per_work,      /* WORK */
               0);            /* V_BLANK SKIP */
  }
! 
diff -crBN --binary sbl6/segasmp/per/smpper1/smpper1.c sbl6_patch/segasmp/per/smpper1/smpper1.c
*** sbl6/segasmp/per/smpper1/smpper1.c	1996-02-08 05:30:40.000000000 -0500
--- sbl6_patch/segasmp/per/smpper1/smpper1.c	2023-01-02 18:18:36.000000000 -0500
***************
*** 102,108 ****
   ******************************************************************************
   */
  
! void main(void)
  {
      Uint8 ireg[32];
  #if	0
--- 102,108 ----
   ******************************************************************************
   */
  
! int main(void)
  {
      Uint8 ireg[32];
  #if	0
***************
*** 175,179 ****
      while(1)
      {
      }
  }
! 
\ No newline at end of file
--- 175,181 ----
      while(1)
      {
      }
+     
+     return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/per/smpper12/test.c sbl6_patch/segasmp/per/smpper12/test.c
*** sbl6/segasmp/per/smpper12/test.c	1996-02-08 05:30:44.000000000 -0500
--- sbl6_patch/segasmp/per/smpper12/test.c	2023-01-07 14:03:52.000000000 -0500
***************
*** 3,15 ****
  *	1995.10.11	c.yoshida												*
  ************************************************************************/
  
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"..\..\v_blank\v_blank.h"
! #include	"..\..\scl\graphic\cosmo2u.cha"
! #include	"..\..\scl\graphic\cosmo2u.col"
! #include	"..\..\scl\graphic\cosmo2u.map"
  
  /*********** 関数プロトタイプ *************/
  void scl_main(void);
--- 3,16 ----
  *	1995.10.11	c.yoshida												*
  ************************************************************************/
  
+ #include	<string.h>
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"../../v_blank/v_blank.h"
! #include	"../../scl/graphic/cosmo2u.cha"
! #include	"../../scl/graphic/cosmo2u.col"
! #include	"../../scl/graphic/cosmo2u.map"
  
  /*********** 関数プロトタイプ *************/
  void scl_main(void);
***************
*** 86,89 ****
  	start.red = start.green = start.blue = 0;
  	end.red = end.green = end.blue = - 255;
  }
! 
\ No newline at end of file
--- 87,90 ----
  	start.red = start.green = start.blue = 0;
  	end.red = end.green = end.blue = - 255;
  }
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl00/sblsgl00.c sbl6_patch/segasmp/sblsgl/sblsgl00/sblsgl00.c
*** sbl6/segasmp/sblsgl/sblsgl00/sblsgl00.c	1996-02-08 05:31:22.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl00/sblsgl00.c	2022-09-27 07:44:16.000000000 -0400
***************
*** 7,22 ****
   *------------------------------------------------------------------------
   */
  #include    <sgl.h> 				/* use SGL  */
! extern PDATA PD_PLANE1;
  
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"..\..\v_blank\v_blank.h"
  
! #include	"..\graphic\cosmo2u.cha"
! #include	"..\graphic\cosmo2u.col"
! #include	"..\graphic\cosmo2u.map"
  
  
  extern	void	Work_Set(void);
--- 7,23 ----
   *------------------------------------------------------------------------
   */
  #include    <sgl.h> 				/* use SGL  */
! extern PDATA PD_PLANE1;
  
  #include	<machine.h>
+ #include	<string.h>
  #include	<sega_scl.h> 
  
! #include	"../../v_blank/v_blank.h"
  
! #include	"../graphic/cosmo2u.cha"
! #include	"../graphic/cosmo2u.col"
! #include	"../graphic/cosmo2u.map"
  
  
  extern	void	Work_Set(void);
***************
*** 45,54 ****
  
  
  /* メインルーチン */
! void main()
  {
! 	static 	ANGLE	ang[XYZ];
! 	static 	FIXED	pos[XYZ];
  
  	SclConfig	scfg;
  	SclRgb		start,end;
--- 46,55 ----
  
  
  /* メインルーチン */
! int main(void)
  {
! 	static 	ANGLE	ang[XYZ];
! 	static 	FIXED	pos[XYZ];
  
  	SclConfig	scfg;
  	SclRgb		start,end;
***************
*** 56,62 ****
  	Uint8   	*VramWorkP;
  
  	/* ワークエリアのユーザー定義	*/
! 	Work_Set();
  
  	slInitSystem(TV_320x224,NULL,1);
  
--- 57,63 ----
  	Uint8   	*VramWorkP;
  
  	/* ワークエリアのユーザー定義	*/
! 	//Work_Set();
  
  	slInitSystem(TV_320x224,NULL,1);
  
***************
*** 156,161 ****
  			slSynch();
  	}
  
  }
  
! 
\ No newline at end of file
--- 157,163 ----
  			slSynch();
  	}
  
+    return 0;
  }
  
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl00/work.c sbl6_patch/segasmp/sblsgl/sblsgl00/work.c
*** sbl6/segasmp/sblsgl/sblsgl00/work.c	1996-02-08 05:31:22.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl00/work.c	2022-09-27 07:43:46.000000000 -0400
***************
*** 9,25 ****
  
  #include    <sgl.h>
  
! 	extern Uint32	MaxVertices ;
! 	extern Uint32	MaxPolygon ;
! 	extern void*	SortList ;	
! 	extern void*	TransList ;
! 	extern void*	Zbuffer ;	
! 	extern void*	SlSpriteBuf ;	
! 	extern void*	MsSpriteBuf ;	
! 	extern Uint32	SpriteBufSize ;
! 	extern void*	Pbuffer ;	
! 	extern void*	CLOfstBuf ;	
! 	extern void*	CommandBuf ;	
  
  /*
  #define		MAX_VERTICES	2440
--- 9,26 ----
  
  #include    <sgl.h>
  
! 	extern Uint32	MaxVertices ;
! 	Uint32	MaxPolygon ; // PATCH !
! 	//extern Uint32	MaxPolygon ;
! 	extern void*	SortList ;	
! 	extern void*	TransList ;
! 	extern void*	Zbuffer ;	
! 	//extern void*	SlSpriteBuf ;	
! 	//extern void*	MsSpriteBuf ;	
! 	extern Uint32	SpriteBufSize ;
! 	extern void*	Pbuffer ;	
! 	extern void*	CLOfstBuf ;	
! 	extern void*	CommandBuf ;	
  
  /*
  #define		MAX_VERTICES	2440
***************
*** 49,56 ****
  	SortList    = (void*)(SORTLIST) ;
  	TransList   = (void*)(TRANSLIST) ;
  	Zbuffer     = (void*)(ZBUFFER) ;
! 	SlSpriteBuf = (void*)(SLSPRBUF) ;
! 	MsSpriteBuf = (void*)(MSSPRBUF) ;
  	SpriteBufSize = (MAX_POLYGON+5)*36 ;
  	Pbuffer     = (void*)(PBUFFER) ;
  	CLOfstBuf   = (void*)(CLOFSTBUF) ;
--- 50,57 ----
  	SortList    = (void*)(SORTLIST) ;
  	TransList   = (void*)(TRANSLIST) ;
  	Zbuffer     = (void*)(ZBUFFER) ;
! 	//SlSpriteBuf = (void*)(SLSPRBUF) ;
! 	//MsSpriteBuf = (void*)(MSSPRBUF) ;
  	SpriteBufSize = (MAX_POLYGON+5)*36 ;
  	Pbuffer     = (void*)(PBUFFER) ;
  	CLOfstBuf   = (void*)(CLOFSTBUF) ;
***************
*** 71,74 ****
  */
  
  }
! 
\ No newline at end of file
--- 72,75 ----
  */
  
  }
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl01/sblsgl01.c sbl6_patch/segasmp/sblsgl/sblsgl01/sblsgl01.c
*** sbl6/segasmp/sblsgl/sblsgl01/sblsgl01.c	1996-02-08 05:31:26.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl01/sblsgl01.c	2024-08-02 20:45:16.000000000 -0400
***************
*** 2,22 ****
   *  FILE:	sblsgl01.c
   *
   *  PURPOSE:
!  *		ＳＧＬモードのテストサンプル
!  * 
   *------------------------------------------------------------------------
   */
  #include    <sgl.h> 				/* use SGL  */
! extern PDATA PD_PLANE1, PD_PLANE2, PD_PLANE3;
  
  #include	<machine.h>
! #include	<sega_scl.h> 
  
! #include	"..\..\v_blank\v_blank.h"
  
! #include	"..\graphic\cosmo2u.cha"
! #include	"..\graphic\cosmo2u.col"
! #include	"..\graphic\cosmo2u.map"
  
  /*----------------------------
  SCROLL NBG0 Cycle Table
--- 2,25 ----
   *  FILE:	sblsgl01.c
   *
   *  PURPOSE:
!  *		ｿｽrｿｽfｿｽkｿｽｿｽｿｽ[ｿｽhｿｽﾌテｿｽXｿｽgｿｽTｿｽｿｽｿｽvｿｽｿｽ
!  *
   *------------------------------------------------------------------------
   */
+ 
+ #include <string.h>
+ 
  #include    <sgl.h> 				/* use SGL  */
! extern PDATA PD_PLANE1, PD_PLANE2, PD_PLANE3;
  
  #include	<machine.h>
! #include	<sega_scl.h>
  
! #include	"../../v_blank/v_blank.h"
  
! #include	"../graphic/cosmo2u.cha"
! #include	"../graphic/cosmo2u.col"
! #include	"../graphic/cosmo2u.map"
  
  /*----------------------------
  SCROLL NBG0 Cycle Table
***************
*** 41,47 ****
  }
  
  
! /* メインルーチン */
  void main()
  {
  	SclConfig	scfg;
--- 44,50 ----
  }
  
  
! /* ｿｽｿｽｿｽCｿｽｿｽｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽ */
  void main()
  {
  	SclConfig	scfg;
***************
*** 49,61 ****
  	Uint16  	BackCol,i,PadData1EW;
  	Uint8   	*VramWorkP;
  
! 	static ANGLE ang1[XYZ], ang2[XYZ], ang3[XYZ];
! 	static FIXED pos1[XYZ], pos2[XYZ], pos3[XYZ];
! 	static ANGLE tang, aang;
! 
! 	slInitSystem(TV_320x224,NULL,1);
  
! 	/* Ｖブランクルーチンをユーザー登録する場合	*/
      SetVblank();
  
  	SCL_SetColRamMode(SCL_CRM24_1024);
--- 52,64 ----
  	Uint16  	BackCol,i,PadData1EW;
  	Uint8   	*VramWorkP;
  
! 	static ANGLE ang1[XYZ], ang2[XYZ], ang3[XYZ];
! 	static FIXED pos1[XYZ], pos2[XYZ], pos3[XYZ];
! 	static ANGLE tang, aang;
  
! 	slInitSystem(TV_320x224,NULL,1);
! 
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽUｿｽ[ｿｽoｿｽ^ｿｽｿｽｿｽｿｽｿｽ鼾	*/
      SetVblank();
  
  	SCL_SetColRamMode(SCL_CRM24_1024);
***************
*** 64,76 ****
  	SCL_SetBack(SCL_VDP2_VRAM+0x80000-2,1,&BackCol);
  
  	/******************************************************
! 	*	スクロールのｷｬﾗｸﾀﾊﾟﾀｰﾝの設定(VRAM B1に置く)   *
  	******************************************************/
  	VramWorkP = (Uint8 *)SCL_VDP2_VRAM_B1;
  	memcpy(VramWorkP, cosmo2u_char, sizeof(cosmo2u_char));
  
  	/*******************************************
! 	*	スクロールのﾊﾟﾀｰﾝﾈｰﾑﾃｰﾌﾞﾙの設定        *
  	*******************************************/
  	VramWorkP = (Uint8 *)SCL_VDP2_VRAM_B0;
  	for(i=0;i<28;i++) {
--- 67,79 ----
  	SCL_SetBack(SCL_VDP2_VRAM+0x80000-2,1,&BackCol);
  
  	/******************************************************
! 	*	ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌｷｿｽﾗｸｿｽｿｽｿｽｿｽｿｽﾝの設抵ｿｽ(VRAM B1ｿｽﾉ置ｿｽｿｽ)   *
  	******************************************************/
  	VramWorkP = (Uint8 *)SCL_VDP2_VRAM_B1;
  	memcpy(VramWorkP, cosmo2u_char, sizeof(cosmo2u_char));
  
  	/*******************************************
! 	*	ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈｰｿｽﾃｰｿｽｿｽﾙの設抵ｿｽ        *
  	*******************************************/
  	VramWorkP = (Uint8 *)SCL_VDP2_VRAM_B0;
  	for(i=0;i<28;i++) {
***************
*** 79,85 ****
  	}
  
  	/*******************************************
! 	*	パレットデータの設定                   *
  	*******************************************/
  	SCL_AllocColRam(SCL_NBG0,256,OFF);
  	SCL_SetColRam(SCL_NBG0,0,sizeof(cosmo2u_col),(void*)cosmo2u_col);
--- 82,88 ----
  	}
  
  	/*******************************************
! 	*	ｿｽpｿｽｿｽｿｽbｿｽgｿｽfｿｽ[ｿｽ^ｿｽﾌ設抵ｿｽ                   *
  	*******************************************/
  	SCL_AllocColRam(SCL_NBG0,256,OFF);
  	SCL_SetColRam(SCL_NBG0,0,sizeof(cosmo2u_col),(void*)cosmo2u_col);
***************
*** 95,101 ****
  		scfg.platesize     = SCL_PL_SIZE_2X2;
  		scfg.coltype       = SCL_COL_TYPE_256;
  		scfg.datatype      = SCL_CELL;
! 		scfg.patnamecontrl = 0x000c;	/* VRAM B1 のオフセット */
  		for(i=0;i<4;i++)   scfg.plate_addr[i] = SCL_VDP2_VRAM_B0;
  	SCL_SetConfig(SCL_NBG0, &scfg);
  
--- 98,104 ----
  		scfg.platesize     = SCL_PL_SIZE_2X2;
  		scfg.coltype       = SCL_COL_TYPE_256;
  		scfg.datatype      = SCL_CELL;
! 		scfg.patnamecontrl = 0x000c;	/* VRAM B1 ｿｽﾌオｿｽtｿｽZｿｽbｿｽg */
  		for(i=0;i<4;i++)   scfg.plate_addr[i] = SCL_VDP2_VRAM_B0;
  	SCL_SetConfig(SCL_NBG0, &scfg);
  
***************
*** 106,135 ****
  
  	SCL_SetCycleTable(CycleTb);
  
! 	/* プライオリティのセット */
  	SCL_SetPriority(SCL_NBG0,7);
  
  	start.red = start.green = start.blue = 0;
  	end.red = end.green = end.blue = - 255;
  
! 	ang1[X] = ang1[Y] = ang1[Z] = DEGtoANG(0.0);
! 	ang2[X] = ang2[Y] = ang2[Z] = DEGtoANG(0.0);
! 	ang3[X] = ang3[Y] = ang3[Z] = DEGtoANG(0.0);
! 	pos1[X] = toFIXED(  0.0);
! 	pos1[Y] = toFIXED( 40.0);
! 	pos1[Z] = toFIXED(170.0);
! 	pos2[X] = toFIXED(  0.0);
! 	pos2[Y] = toFIXED(-40.0);
! 	pos2[Z] = toFIXED(  0.0);
! 	pos3[X] = toFIXED(  0.0);
! 	pos3[Y] = toFIXED(-40.0);
! 	pos3[Z] = toFIXED(  0.0);
! 	tang = DEGtoANG(0.0);
! 	aang = DEGtoANG(2.0);
! 
  
! 	/******** メインループ ********/
! 	while(-1) {
  		PadData1EW = PadData1E;
  		PadData1E = 0;
  		if(PadData1EW & PAD_U){
--- 109,138 ----
  
  	SCL_SetCycleTable(CycleTb);
  
! 	/* ｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽﾌセｿｽbｿｽg */
  	SCL_SetPriority(SCL_NBG0,7);
  
  	start.red = start.green = start.blue = 0;
  	end.red = end.green = end.blue = - 255;
  
! 	ang1[X] = ang1[Y] = ang1[Z] = DEGtoANG(0.0);
! 	ang2[X] = ang2[Y] = ang2[Z] = DEGtoANG(0.0);
! 	ang3[X] = ang3[Y] = ang3[Z] = DEGtoANG(0.0);
! 	pos1[X] = toFIXED(  0.0);
! 	pos1[Y] = toFIXED( 40.0);
! 	pos1[Z] = toFIXED(170.0);
! 	pos2[X] = toFIXED(  0.0);
! 	pos2[Y] = toFIXED(-40.0);
! 	pos2[Z] = toFIXED(  0.0);
! 	pos3[X] = toFIXED(  0.0);
! 	pos3[Y] = toFIXED(-40.0);
! 	pos3[Z] = toFIXED(  0.0);
! 	tang = DEGtoANG(0.0);
! 	aang = DEGtoANG(2.0);
! 
  
! 	/******** ｿｽｿｽｿｽCｿｽｿｽｿｽｿｽｿｽ[ｿｽv ********/
! 	while(-1) {
  		PadData1EW = PadData1E;
  		PadData1E = 0;
  		if(PadData1EW & PAD_U){
***************
*** 150,190 ****
  		if((PadData1 & PAD_B)) 	SCL_SetMosaic(SCL_NBG0,14,14);
  		if((PadData1 & PAD_C)) 	SCL_SetMosaic(SCL_NBG0,16,16);
  
! 		slUnitMatrix(CURRENT);
! 		ang1[Z] = ang2[Z] = tang;
! 		tang += aang;
! 		if(tang < DEGtoANG(-90.0)) {
! 			aang = DEGtoANG(2.0);
! 		} else if(tang > DEGtoANG(90.0)) {
! 			aang = -DEGtoANG(2.0);
! 		}
! 
! 		slPushMatrix();
! 		{
! 			set_poly(ang1, pos1);
! 			slPutPolygon(&PD_PLANE1);
! 
! 			slPushMatrix();
! 			{
! 				set_poly(ang2, pos2);
! 				slPutPolygon(&PD_PLANE2);
! 
! 				slPushMatrix();
! 				{
! 					set_poly(ang3, pos3);
! 					ang3[Y] += DEGtoANG(5.0);
! 					slPutPolygon(&PD_PLANE3);
! 				}
! 				slPopMatrix();
! 			}	
! 			slPopMatrix();
! 		}
! 		slPopMatrix();
! 
! 		slSynch();
! 	}
! }
  
  
  
! 
\ No newline at end of file
--- 153,193 ----
  		if((PadData1 & PAD_B)) 	SCL_SetMosaic(SCL_NBG0,14,14);
  		if((PadData1 & PAD_C)) 	SCL_SetMosaic(SCL_NBG0,16,16);
  
! 		slUnitMatrix(CURRENT);
! 		ang1[Z] = ang2[Z] = tang;
! 		tang += aang;
! 		if(tang < DEGtoANG(-90.0)) {
! 			aang = DEGtoANG(2.0);
! 		} else if(tang > DEGtoANG(90.0)) {
! 			aang = -DEGtoANG(2.0);
! 		}
! 
! 		slPushMatrix();
! 		{
! 			set_poly(ang1, pos1);
! 			slPutPolygon(&PD_PLANE1);
! 
! 			slPushMatrix();
! 			{
! 				set_poly(ang2, pos2);
! 				slPutPolygon(&PD_PLANE2);
! 
! 				slPushMatrix();
! 				{
! 					set_poly(ang3, pos3);
! 					ang3[Y] += DEGtoANG(5.0);
! 					slPutPolygon(&PD_PLANE3);
! 				}
! 				slPopMatrix();
! 			}
! 			slPopMatrix();
! 		}
! 		slPopMatrix();
! 
! 		slSynch();
! 	}
! }
  
  
  
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl02/sblsgl02.c sbl6_patch/segasmp/sblsgl/sblsgl02/sblsgl02.c
*** sbl6/segasmp/sblsgl/sblsgl02/sblsgl02.c	1996-02-08 05:31:32.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl02/sblsgl02.c	2024-08-19 12:07:54.000000000 -0400
***************
*** 2,9 ****
   *  FILE:	sblsgl02.c
   *
   *  PURPOSE:
!  *		ＳＧＬモードのテストサンプル
!  * 
   *------------------------------------------------------------------------
   */
  
--- 2,9 ----
   *  FILE:	sblsgl02.c
   *
   *  PURPOSE:
!  *		ｿｽrｿｽfｿｽkｿｽｿｽｿｽ[ｿｽhｿｽﾌテｿｽXｿｽgｿｽTｿｽｿｽｿｽvｿｽｿｽ
!  *
   *------------------------------------------------------------------------
   */
  
***************
*** 12,20 ****
  
  #include	<machine.h>
  #include	<sega_xpt.h>
! #include	<sega_def.h> 
! #include	<sega_mth.h> 
! #include	<sega_scl.h> 
  #include	<sega_dbg.h>
  #include	"botan.h"
  #include	"../../v_blank/v_blank.h"
--- 12,20 ----
  
  #include	<machine.h>
  #include	<sega_xpt.h>
! #include	<sega_def.h>
! #include	<sega_mth.h>
! #include	<sega_scl.h>
  #include	<sega_dbg.h>
  #include	"botan.h"
  #include	"../../v_blank/v_blank.h"
***************
*** 49,74 ****
  void SetAutoLinePara(Uint16 SclNum);
  void ClrLinePara(Uint16 SclNum);
  
! /* extern SetVblank(void);	*/			/*	追加 95.7.11 Chikahiro Yoshida	*/
! extern FirstData(Uint32 sclnum);	/*	追加 95.7.11 Chikahiro Yoshida	*/
! extern SecondData(Uint32 sclnum);	/*	追加 95.7.11 Chikahiro Yoshida	*/
  
  /********************************
!  * ｻｲｸﾙﾊﾟﾀｰﾝﾃｰﾌﾞﾙ               *
   ********************************/
  Uint16	CycleTb[]={
! 	0x01ff,0x4455,	/* VRAM A (VRAM A0)   1:NBG1ﾊﾟﾀｰﾝﾈｰﾑ(ﾏｯﾌﾟ)ﾘｰﾄﾞ */
! 			/*                    0:NBG0ﾊﾟﾀｰﾝﾈｰﾑ(ﾏｯﾌﾟ)ﾘｰﾄﾞ */
! 			/*                    5:NBG1ｷｬﾗｸﾀﾊﾟﾀｰﾝ(ｾﾙ)ﾘｰﾄﾞ */
! 			/*                    4:NBG0ｷｬﾗｸﾀﾊﾟﾀｰﾝ(ｾﾙ)ﾘｰﾄﾞ */
! 			/*                    f:ｱｸｾｽしない             */
! 	0xffff,0xffff,  /*        (VRAM A1)   無効（分割していない）   */
! 	0xffff,0xffff,  /* VRAM B (VRAM B0)   未使用                   */
! 	0xffff,0xffff   /*        (VRAM B1)   無効（分割していない）   */
  };
  
  
! /* メインルーチン */
  void main()
  {
      SclConfig	scfg;
--- 49,74 ----
  void SetAutoLinePara(Uint16 SclNum);
  void ClrLinePara(Uint16 SclNum);
  
! /* extern SetVblank(void);	*/			/*	ｿｽﾇ会ｿｽ 95.7.11 Chikahiro Yoshida	*/
! extern void FirstData(Uint32 sclnum);	/*	ｿｽﾇ会ｿｽ 95.7.11 Chikahiro Yoshida	*/
! extern Uint32 SecondData(Uint32 sclnum);	/*	ｿｽﾇ会ｿｽ 95.7.11 Chikahiro Yoshida	*/
  
  /********************************
!  * ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾃｰｿｽｿｽｿｽ               *
   ********************************/
  Uint16	CycleTb[]={
! 	0x01ff,0x4455,	/* VRAM A (VRAM A0)   1:NBG1ｿｽｿｽｿｽｿｽｿｽﾈｰｿｽ(ﾏｯｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    0:NBG0ｿｽｿｽｿｽｿｽｿｽﾈｰｿｽ(ﾏｯｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    5:NBG1ｿｽｿｽﾗｸｿｽｿｽｿｽｿｽｿｽｿｽ(ｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    4:NBG0ｿｽｿｽﾗｸｿｽｿｽｿｽｿｽｿｽｿｽ(ｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    f:ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ             */
! 	0xffff,0xffff,  /*        (VRAM A1)   ｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽj   */
! 	0xffff,0xffff,  /* VRAM B (VRAM B0)   ｿｽｿｽｿｽgｿｽp                   */
! 	0xffff,0xffff   /*        (VRAM B1)   ｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽj   */
  };
  
  
! /* ｿｽｿｽｿｽCｿｽｿｽｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽ */
  void main()
  {
      SclConfig	scfg;
***************
*** 113,119 ****
  		{ toFIXEDa(-0.09), toFIXED ( 0.0 ), toFIXEDa(-0.24) } ,
  		{ toFIXED ( 0.0 ), toFIXEDa(-0.01), toFIXED ( 0.0 ) } ,
  		{ toFIXEDa(-0.04), toFIXED ( 0.0 ), toFIXEDa( 0.09) } ,
! 		{ toFIXEDa(-0.04), toFIXED ( 0.0 ), toFIXEDa(-0.09) } 
  	};
  
  	static FIXED aki_pos[XYZ] =
--- 113,119 ----
  		{ toFIXEDa(-0.09), toFIXED ( 0.0 ), toFIXEDa(-0.24) } ,
  		{ toFIXED ( 0.0 ), toFIXEDa(-0.01), toFIXED ( 0.0 ) } ,
  		{ toFIXEDa(-0.04), toFIXED ( 0.0 ), toFIXEDa( 0.09) } ,
! 		{ toFIXEDa(-0.04), toFIXED ( 0.0 ), toFIXEDa(-0.09) }
  	};
  
  	static FIXED aki_pos[XYZ] =
***************
*** 125,144 ****
  
  	slInitSystem(TV_320x224,NULL,1);
  
! 	/* Ｖブランクルーチンをユーザー登録する場合	*/
      SetVblank();
  
      SCL_SetColRamMode(SCL_CRM24_1024);
  	slSynch();
  
     /*******************************************
!     *	スクロールデータのセット              *
      *******************************************/
      FirstData(sclnum);
      StartAddr2 = SecondData(sclnum2);
  
     /*******************************************
!     *	ｽｸﾛｰﾙｺﾝﾌｨｸﾞﾚｰｼｮﾝの設定                *
      *******************************************/
      SCL_InitConfigTb(&scfg);
      scfg.dispenbl      = ON;
--- 125,144 ----
  
  	slInitSystem(TV_320x224,NULL,1);
  
! 	/* ｿｽuｿｽuｿｽｿｽｿｽｿｽｿｽNｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽUｿｽ[ｿｽoｿｽ^ｿｽｿｽｿｽｿｽｿｽ鼾	*/
      SetVblank();
  
      SCL_SetColRamMode(SCL_CRM24_1024);
  	slSynch();
  
     /*******************************************
!     *	ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽﾌセｿｽbｿｽg              *
      *******************************************/
      FirstData(sclnum);
      StartAddr2 = SecondData(sclnum2);
  
     /*******************************************
!     *	ｿｽｿｽﾛｰﾙｺｿｽﾌｨｿｽｿｽﾚｰｿｽｿｽﾝの設抵ｿｽ                *
      *******************************************/
      SCL_InitConfigTb(&scfg);
      scfg.dispenbl      = ON;
***************
*** 160,171 ****
      SCL_SetConfig(sclnum2, &scfg);
  
     /*******************************************
!     *	サイクルパターンの設定                *
      *******************************************/
      SCL_SetCycleTable(CycleTb);
  
     /*******************************************
!     *	ﾌﾟﾗｲｵﾘﾃｨを設定(0〜7)                  *
      *******************************************/
      SCL_SetPriority(sclnum2,7);
      SCL_SetPriority(sclnum,6);
--- 160,171 ----
      SCL_SetConfig(sclnum2, &scfg);
  
     /*******************************************
!     *	ｿｽTｿｽCｿｽNｿｽｿｽｿｽpｿｽ^ｿｽ[ｿｽｿｽｿｽﾌ設抵ｿｽ                *
      *******************************************/
      SCL_SetCycleTable(CycleTb);
  
     /*******************************************
!     *	ｿｽｿｽﾗｲｿｽｿｽﾃｨｿｽｿｽｿｽﾝ抵ｿｽ(0ｿｽ`7)                  *
      *******************************************/
      SCL_SetPriority(sclnum2,7);
      SCL_SetPriority(sclnum,6);
***************
*** 204,210 ****
  
  		/* SGL Sprite Controll	*/
  		mcnt = bcnt = 0;
! 		
  		slUnitMatrix(CURRENT);
  		slLookAt(cm_pos, cm_target, cm_ang[Z] );
  
--- 204,210 ----
  
  		/* SGL Sprite Controll	*/
  		mcnt = bcnt = 0;
! 
  		slUnitMatrix(CURRENT);
  		slLookAt(cm_pos, cm_target, cm_ang[Z] );
  
***************
*** 427,433 ****
  
  
  /********************************************************************
!  * ラインパラメータテーブルのダミーを作成する                       *
   ********************************************************************/
  #define X_SIZE		320
  #define Y_SIZE		224
--- 427,433 ----
  
  
  /********************************************************************
!  * ｿｽｿｽｿｽCｿｽｿｽｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌダｿｽ~ｿｽ[ｿｽｿｽｿｽ成ｿｽｿｽｿｽｿｽ                       *
   ********************************************************************/
  #define X_SIZE		320
  #define Y_SIZE		224
***************
*** 462,468 ****
  }
  
  /********************************************************************
!  * ラインパラメータテーブルを無効にする                             *
   ********************************************************************/
  void ClrLinePara(Uint16 SclNum)
  {
--- 462,468 ----
  }
  
  /********************************************************************
!  * ｿｽｿｽｿｽCｿｽｿｽｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽｿｽ無鯉ｿｽｿｽﾉゑｿｽｿｽｿｽ                             *
   ********************************************************************/
  void ClrLinePara(Uint16 SclNum)
  {
***************
*** 476,479 ****
  	slSynch();
  	/* SCL_DisplayFrame();	*/
  }
! 
\ No newline at end of file
--- 476,479 ----
  	slSynch();
  	/* SCL_DisplayFrame();	*/
  }
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl02/scldata.c sbl6_patch/segasmp/sblsgl/sblsgl02/scldata.c
*** sbl6/segasmp/sblsgl/sblsgl02/scldata.c	1996-02-08 05:31:34.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl02/scldata.c	2024-08-19 12:04:52.000000000 -0400
***************
*** 4,15 ****
  #include	<sega_mth.h>
  #include	<sega_scl.h>
  
! #include	"..\graphic\grandu.cha"
! #include	"..\graphic\grandu.col"
! #include	"..\graphic\grandu.map"
! #include	"..\graphic\skyu.cha"
! #include	"..\graphic\skyu.col"
! #include	"..\graphic\skyu.map"
  
  
  void WordCopyforVRAM(void *dest,void *src,Uint32 tcnt);
--- 4,15 ----
  #include	<sega_mth.h>
  #include	<sega_scl.h>
  
! #include	"../graphic/grandu.cha"
! #include	"../graphic/grandu.col"
! #include	"../graphic/grandu.map"
! #include	"../graphic/skyu.cha"
! #include	"../graphic/skyu.col"
! #include	"../graphic/skyu.map"
  
  
  void WordCopyforVRAM(void *dest,void *src,Uint32 tcnt);
***************
*** 127,133 ****
  
  
  /****************************************************************************
!  *  指定されたＶＲＡＭを１つのデータで埋める
   ****************************************************************************/
  void MapCopyforVRAM2(void *dest,Uint32 src,Uint32 Offset,Uint32 tcnt)
  {
--- 127,133 ----
  
  
  /****************************************************************************
!  *  ｿｽwｿｽ閧ｳｿｽ黷ｽｿｽuｿｽqｿｽ`ｿｽlｿｽｿｽｿｽPｿｽﾂのデｿｽ[ｿｽ^ｿｽﾅ厄ｿｽｿｽﾟゑｿｽ
   ****************************************************************************/
  void MapCopyforVRAM2(void *dest,Uint32 src,Uint32 Offset,Uint32 tcnt)
  {
***************
*** 172,175 ****
      }
  }
  
! 
\ No newline at end of file
--- 172,175 ----
      }
  }
  
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl02/ss_akira.h sbl6_patch/segasmp/sblsgl/sblsgl02/ss_akira.h
*** sbl6/segasmp/sblsgl/sblsgl02/ss_akira.h	1996-02-08 05:31:34.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl02/ss_akira.h	2024-08-19 11:54:06.000000000 -0400
***************
*** 31,39 ****
  #define    INITANGY           DEG2ANG(90.0)
  #define    INITANGZ           DEG2ANG(0.0)
  
! extern     void slInitSystem(Uint16 , TEXTURE * , Uint16) ;
  extern     void objectdata(ANGLE * , FIXED *) ;
  extern     void Debuge() ;
  
  extern     Uint16 TotalPolygon , DispPolygons ;
- 
--- 31,38 ----
  #define    INITANGY           DEG2ANG(90.0)
  #define    INITANGZ           DEG2ANG(0.0)
  
! //extern     void slInitSystem(Uint16 , TEXTURE * , Uint16) ;
  extern     void objectdata(ANGLE * , FIXED *) ;
  extern     void Debuge() ;
  
  extern     Uint16 TotalPolygon , DispPolygons ;
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl03/sblsgl03.c sbl6_patch/segasmp/sblsgl/sblsgl03/sblsgl03.c
*** sbl6/segasmp/sblsgl/sblsgl03/sblsgl03.c	1996-02-08 05:31:38.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl03/sblsgl03.c	2024-08-19 13:32:52.000000000 -0400
***************
*** 1,5 ****
  /*------------------------------------------------------------------------
!   取り敢えず自分で作ってみた回転スクロールのサンプル
  
    1995.9.7 c.yoshida
  ------------------------------------------------------------------------*/
--- 1,5 ----
  /*------------------------------------------------------------------------
!   ｿｽｿｽｿｽ闃ｸｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾅ搾ｿｽｿｽｿｽｿｽﾄみゑｿｽｿｽｿｽｿｽ]ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌサｿｽｿｽｿｽvｿｽｿｽ
  
    1995.9.7 c.yoshida
  ------------------------------------------------------------------------*/
***************
*** 7,15 ****
  /************** include file ************************************/
  
  #include	<stdio.h>
  #include	<machine.h>
! #include	<sega_scl.h> 
! #include	"..\..\v_blank\v_blank.h"
  
  #include	<sgl.h>
  #include	<sgl_work.h>		/* use SGL */
--- 7,16 ----
  /************** include file ************************************/
  
  #include	<stdio.h>
+ #include	<string.h>
  #include	<machine.h>
! #include	<sega_scl.h>
! #include	"../../v_blank/v_blank.h"
  
  #include	<sgl.h>
  #include	<sgl_work.h>		/* use SGL */
***************
*** 21,39 ****
  #define		MAP_OFFSET		0x0800
  #define		MAP_NUM			16
  
! /*************** 関数プロトタイプ *******************************/
  
  void	ClrVram(Uint8 *buff);
  
! /*************** 外部参照 ***************************************/
  
- extern	Uint32	BackPalette[];		/* 鉄板風タイルのパレット   */
- extern	Uint8	BackCharPatData[];	/* 鉄板風タイルのデータ本体 */
  
  	Uint16		PadData1EW,PadData2EW;
  	SclConfig	Rbg0Scfg;
  
! /*************** 以下 プログラム本体 ****************************/
  
  int	main( void ){
  	SclVramConfig	tp;
--- 22,44 ----
  #define		MAP_OFFSET		0x0800
  #define		MAP_NUM			16
  
! /*************** ｿｽﾖ撰ｿｽｿｽvｿｽｿｽｿｽgｿｽ^ｿｽCｿｽv *******************************/
  
  void	ClrVram(Uint8 *buff);
  
! /*************** ｿｽOｿｽｿｽｿｽQｿｽｿｽ ***************************************/
! 
! extern	Uint32	BackPalette[];		/* ｿｽSｿｽﾂ包ｿｽｿｽ^ｿｽCｿｽｿｽｿｽﾌパｿｽｿｽｿｽbｿｽg   */
! extern	Uint8	BackCharPatData[];	/* ｿｽSｿｽﾂ包ｿｽｿｽ^ｿｽCｿｽｿｽｿｽﾌデｿｽ[ｿｽ^ｿｽ{ｿｽｿｽ */
! 
! extern void	SCL_SglOn(void);		/*	use SGL	*/
! extern void	SCL_SglOff(void);		/*	use SGL	*/
  
  
  	Uint16		PadData1EW,PadData2EW;
  	SclConfig	Rbg0Scfg;
  
! /*************** ｿｽﾈ会ｿｽ ｿｽvｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽ{ｿｽｿｽ ****************************/
  
  int	main( void ){
  	SclVramConfig	tp;
***************
*** 47,68 ****
  
  
  	SCL_SglOn();
! 						/*	各種初期化処理				*/
  	slInitSystem(TV_320x224,NULL,1);
  
  	SetVblank();
  
  	SCL_SetColRamMode(SCL_CRM24_1024);
  
! 						/*	バック画面の色を黒に設定	*/
  	BackCol = RGB16_COLOR(0,0,0) & 0x7fff;
  	SCL_SetBack(SCL_VDP2_VRAM+0x80000-2,1,&BackCol);
  
! 						/*	回転ﾊﾟﾗﾒｰﾀﾃｰﾌﾞﾙをVRAM中のどこに置くかを指定	*/
  	SCL_InitRotateTable(SCL_VDP2_VRAM_A1+0x1fe00,2,SCL_RBG0,SCL_RBG0);
  	slRparaInitSet(((void *)(SCL_VDP2_VRAM_A1+0x1fe00)));
  
! 						/*	ＶＲＡＭの使用方法の設定	*/
  	SCL_InitVramConfigTb(&tp);
  		tp.ktboffsetA	= 0x0000;
  		tp.ktboffsetB	= 0x0000;
--- 52,73 ----
  
  
  	SCL_SglOn();
! 						/*	ｿｽeｿｽ初ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ				*/
  	slInitSystem(TV_320x224,NULL,1);
  
  	SetVblank();
  
  	SCL_SetColRamMode(SCL_CRM24_1024);
  
! 						/*	ｿｽoｿｽbｿｽNｿｽｿｽｿｽﾊの色ｿｽｿｽｿｽｿｽｿｽﾉ設抵ｿｽ	*/
  	BackCol = RGB16_COLOR(0,0,0) & 0x7fff;
  	SCL_SetBack(SCL_VDP2_VRAM+0x80000-2,1,&BackCol);
  
! 						/*	ｿｽｿｽｿｽ]ｿｽｿｽｿｽﾒｰｿｽﾃｰｿｽｿｽﾙゑｿｽVRAMｿｽｿｽｿｽﾌどゑｿｽｿｽﾉ置ｿｽｿｽｿｽｿｽｿｽｿｽｿｽwｿｽｿｽ	*/
  	SCL_InitRotateTable(SCL_VDP2_VRAM_A1+0x1fe00,2,SCL_RBG0,SCL_RBG0);
  	slRparaInitSet(((void *)(SCL_VDP2_VRAM_A1+0x1fe00)));
  
! 						/*	ｿｽuｿｽqｿｽ`ｿｽlｿｽﾌ使ｿｽpｿｽｿｽｿｽ@ｿｽﾌ設抵ｿｽ	*/
  	SCL_InitVramConfigTb(&tp);
  		tp.ktboffsetA	= 0x0000;
  		tp.ktboffsetB	= 0x0000;
***************
*** 75,81 ****
  		tp.colram		= SCL_NON;
  	SCL_SetVramConfig(&tp);
  
! 						/*	回転面0の設定				*/
  	SCL_InitConfigTb(&Rbg0Scfg);
  	    Rbg0Scfg.dispenbl      = ON;
  	    Rbg0Scfg.charsize      = SCL_CHAR_SIZE_2X2;
--- 80,86 ----
  		tp.colram		= SCL_NON;
  	SCL_SetVramConfig(&tp);
  
! 						/*	ｿｽｿｽｿｽ]ｿｽｿｽ0ｿｽﾌ設抵ｿｽ				*/
  	SCL_InitConfigTb(&Rbg0Scfg);
  	    Rbg0Scfg.dispenbl      = ON;
  	    Rbg0Scfg.charsize      = SCL_CHAR_SIZE_2X2;
***************
*** 96,112 ****
  	slKtableRA((void *)SCL_VDP2_VRAM_A1 , K_FIX | K_DOT | K_2WORD | K_ON);
  	slKtableRB((void *)SCL_VDP2_VRAM_A1 , K_FIX | K_DOT | K_2WORD | K_ON);
  
! 						/*	プライオリティの設定		*/
  	SCL_SetPriority(SCL_RBG0,4);
  
! 						/*	背景のタイルのカラー転送	*/
  	SCL_AllocColRam(SCL_RBG0,256,ON);
  	SCL_SetColRam(SCL_RBG0,1,256,BackPalette);
  
! 						/*	背景タイルのCG転送			*/
  	memcpy((void *)SCL_VDP2_VRAM_B0,(void *)BackCharPatData,1024);
  
! 						/*	背景タイルのPN dataを転送	*/
  	for(i=0;i<16;i++)	for(j=0;j<16;j++) {
  		wp  = (Uint16 *)(SCL_VDP2_VRAM_B1 + i*2*64 + j*2*2);
  		*wp = MAP_OFFSET+0;
--- 101,117 ----
  	slKtableRA((void *)SCL_VDP2_VRAM_A1 , K_FIX | K_DOT | K_2WORD | K_ON);
  	slKtableRB((void *)SCL_VDP2_VRAM_A1 , K_FIX | K_DOT | K_2WORD | K_ON);
  
! 						/*	ｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽﾌ設抵ｿｽ		*/
  	SCL_SetPriority(SCL_RBG0,4);
  
! 						/*	ｿｽwｿｽiｿｽﾌタｿｽCｿｽｿｽｿｽﾌカｿｽｿｽｿｽ[ｿｽ]ｿｽｿｽ	*/
  	SCL_AllocColRam(SCL_RBG0,256,ON);
  	SCL_SetColRam(SCL_RBG0,1,256,BackPalette);
  
! 						/*	ｿｽwｿｽiｿｽ^ｿｽCｿｽｿｽｿｽｿｽCGｿｽ]ｿｽｿｽ			*/
  	memcpy((void *)SCL_VDP2_VRAM_B0,(void *)BackCharPatData,1024);
  
! 						/*	ｿｽwｿｽiｿｽ^ｿｽCｿｽｿｽｿｽｿｽPN dataｿｽｿｽｿｽ]ｿｽｿｽ	*/
  	for(i=0;i<16;i++)	for(j=0;j<16;j++) {
  		wp  = (Uint16 *)(SCL_VDP2_VRAM_B1 + i*2*64 + j*2*2);
  		*wp = MAP_OFFSET+0;
***************
*** 122,134 ****
  	slRparaMode(K_CHANGE);
  	slScrAutoDisp(RBG0ON);
  
! 						/*	main loop  padをつかった画面操作	*/
  	while(1){
  		PadData1EW=PadData1E;
  		PadData1E=0;
  		PadData2EW=PadData2E;
  		PadData2E=0;
! 		
  		if(PadData1 || PadData1EW)	{
  			if( PadData1 & PAD_X )	{
  				x=x+0x0080;
--- 127,139 ----
  	slRparaMode(K_CHANGE);
  	slScrAutoDisp(RBG0ON);
  
! 						/*	main loop  padｿｽｿｽｿｽﾂゑｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾊ托ｿｽｿｽｿｽ	*/
  	while(1){
  		PadData1EW=PadData1E;
  		PadData1E=0;
  		PadData2EW=PadData2E;
  		PadData2E=0;
! 
  		if(PadData1 || PadData1EW)	{
  			if( PadData1 & PAD_X )	{
  				x=x+0x0080;
***************
*** 145,151 ****
  				z=(DEGtoANG(0.0));
  			}
  		}
! 		
  		slCurRpara(RA);
  		slUnitMatrix(CURRENT);
  		slRotX(x);
--- 150,156 ----
  				z=(DEGtoANG(0.0));
  			}
  		}
! 
  		slCurRpara(RA);
  		slUnitMatrix(CURRENT);
  		slRotX(x);
***************
*** 153,167 ****
  		slRotZ(z);
  		slTranslate(toFIXED(0.0) , toFIXED(0.0), toFIXED(170.0));
  		slScrMatSet();
! 		
  		slCurRpara(RB);
  		slUnitMatrix(CURRENT);
  		slTranslate(toFIXED(0.0) , toFIXED(0.0) , toFIXED(170.0));
  		slScrMatSet();
! 		
  		slSynch();
  	}
! 	
  	return	0;
  }
  
--- 158,172 ----
  		slRotZ(z);
  		slTranslate(toFIXED(0.0) , toFIXED(0.0), toFIXED(170.0));
  		slScrMatSet();
! 
  		slCurRpara(RB);
  		slUnitMatrix(CURRENT);
  		slTranslate(toFIXED(0.0) , toFIXED(0.0) , toFIXED(170.0));
  		slScrMatSet();
! 
  		slSynch();
  	}
! 
  	return	0;
  }
  
***************
*** 170,173 ****
  	Uint32	i;
  	for(i=0;i<(X_SIZE * Y_SIZE);i++)	buff[i]=0x00;
  }
! 
\ No newline at end of file
--- 175,178 ----
  	Uint32	i;
  	for(i=0;i<(X_SIZE * Y_SIZE);i++)	buff[i]=0x00;
  }
! 
diff -crBN --binary sbl6/segasmp/sblsgl/sblsgl04/sblsgl04.c sbl6_patch/segasmp/sblsgl/sblsgl04/sblsgl04.c
*** sbl6/segasmp/sblsgl/sblsgl04/sblsgl04.c	1996-02-08 05:31:42.000000000 -0500
--- sbl6_patch/segasmp/sblsgl/sblsgl04/sblsgl04.c	2024-08-19 14:24:46.000000000 -0400
***************
*** 1,5 ****
  /*------------------------------------------------------------------------
!   取り敢えず自分で作ってみた回転スクロールのサンプル
  
    1995.9.7 c.yoshida
  ------------------------------------------------------------------------*/
--- 1,5 ----
  /*------------------------------------------------------------------------
!   ｿｽｿｽｿｽ闃ｸｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾅ搾ｿｽｿｽｿｽｿｽﾄみゑｿｽｿｽｿｽｿｽ]ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽﾌサｿｽｿｽｿｽvｿｽｿｽ
  
    1995.9.7 c.yoshida
  ------------------------------------------------------------------------*/
***************
*** 8,15 ****
  
  #include	<stdio.h>
  #include	<machine.h>
! #include	<sega_scl.h> 
! #include	"..\..\v_blank\v_blank.h"
  
  #include	<sgl.h>
  #include	<sgl_work.h>		/* use SGL */
--- 8,15 ----
  
  #include	<stdio.h>
  #include	<machine.h>
! #include	<sega_scl.h>
! #include	"../../v_blank/v_blank.h"
  
  #include	<sgl.h>
  #include	<sgl_work.h>		/* use SGL */
***************
*** 29,39 ****
  
  #define		MAP_NUM					16
  
! /*************** 関数プロトタイプ *******************************/
  
  void	ClrVramAll(void);
  
! /*************** 外部参照 ***************************************/
  
  extern	Uint8	tuti_cel[];
  extern	Uint16	tuti_map[],tuti_pal[];
--- 29,39 ----
  
  #define		MAP_NUM					16
  
! /*************** ｿｽﾖ撰ｿｽｿｽvｿｽｿｽｿｽgｿｽ^ｿｽCｿｽv *******************************/
  
  void	ClrVramAll(void);
  
! /*************** ｿｽOｿｽｿｽｿｽQｿｽｿｽ ***************************************/
  
  extern	Uint8	tuti_cel[];
  extern	Uint16	tuti_map[],tuti_pal[];
***************
*** 44,55 ****
  extern	void Map2VRAM( Uint16 *Map_Data , void *Map_Adr , Uint16 suuj , Uint16 suui , Uint16 palnum ,Uint32 mapoff);
  extern	void Pal2CRAM( Uint16 *Pal_Data , void *Col_Adr , Uint32 suu );
  
  /*************** *      * ***************************************/
  
  
  	SclConfig	Rbg0Scfg;
  
! /*************** 以下 プログラム本体 ****************************/
  
  void main()	{
  
--- 44,58 ----
  extern	void Map2VRAM( Uint16 *Map_Data , void *Map_Adr , Uint16 suuj , Uint16 suui , Uint16 palnum ,Uint32 mapoff);
  extern	void Pal2CRAM( Uint16 *Pal_Data , void *Col_Adr , Uint32 suu );
  
+ extern void	SCL_SglOn(void);		/*	use SGL	*/
+ extern void	SCL_SglOff(void);		/*	use SGL	*/
+ 
  /*************** *      * ***************************************/
  
  
  	SclConfig	Rbg0Scfg;
  
! /*************** ｿｽﾈ会ｿｽ ｿｽvｿｽｿｽｿｽOｿｽｿｽｿｽｿｽｿｽ{ｿｽｿｽ ****************************/
  
  void main()	{
  
***************
*** 64,70 ****
  
  
  	SCL_SglOn();
! 						/*	各種初期化処理				*/
  	slInitSystem(TV_320x224,NULL,1);
  
  	SetVblank();
--- 67,73 ----
  
  
  	SCL_SglOn();
! 						/*	ｿｽeｿｽ初ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ				*/
  	slInitSystem(TV_320x224,NULL,1);
  
  	SetVblank();
***************
*** 74,88 ****
  
  	ClrVramAll();
  
! 						/*	バック画面の色を黒に設定	*/
  	BackCol = RGB16_COLOR(0,0,0) & 0x7fff;
  	SCL_SetBack(BACK_COL_ADR,1,&BackCol);
  
! 						/*	回転ﾊﾟﾗﾒｰﾀﾃｰﾌﾞﾙをVRAM中のどこに置くかを指定	*/
  	SCL_InitRotateTable(RBG0_PRA_ADR,(Uint16)2 ,SCL_RBG0,SCL_RBG0);
  	slRparaInitSet( (void *)RBG0_PRA_ADR );
  
! 						/*	ＶＲＡＭの使用方法の設定	*/
  	SCL_InitVramConfigTb(&tp);
  		tp.ktboffsetA		= 0x0000;
  		tp.ktboffsetB		= 0x0000;
--- 77,91 ----
  
  	ClrVramAll();
  
! 						/*	ｿｽoｿｽbｿｽNｿｽｿｽｿｽﾊの色ｿｽｿｽｿｽｿｽｿｽﾉ設抵ｿｽ	*/
  	BackCol = RGB16_COLOR(0,0,0) & 0x7fff;
  	SCL_SetBack(BACK_COL_ADR,1,&BackCol);
  
! 						/*	ｿｽｿｽｿｽ]ｿｽｿｽｿｽﾒｰｿｽﾃｰｿｽｿｽﾙゑｿｽVRAMｿｽｿｽｿｽﾌどゑｿｽｿｽﾉ置ｿｽｿｽｿｽｿｽｿｽｿｽｿｽwｿｽｿｽ	*/
  	SCL_InitRotateTable(RBG0_PRA_ADR,(Uint16)2 ,SCL_RBG0,SCL_RBG0);
  	slRparaInitSet( (void *)RBG0_PRA_ADR );
  
! 						/*	ｿｽuｿｽqｿｽ`ｿｽlｿｽﾌ使ｿｽpｿｽｿｽｿｽ@ｿｽﾌ設抵ｿｽ	*/
  	SCL_InitVramConfigTb(&tp);
  		tp.ktboffsetA		= 0x0000;
  		tp.ktboffsetB		= 0x0000;
***************
*** 95,101 ****
  		tp.colram			= SCL_NON;
  	SCL_SetVramConfig(&tp);
  
! 						/*	回転面0の設定				*/
  	SCL_InitConfigTb(&Rbg0Scfg);
  		Rbg0Scfg.dispenbl      = ON;
  		Rbg0Scfg.charsize      = SCL_CHAR_SIZE_1X1;
--- 98,104 ----
  		tp.colram			= SCL_NON;
  	SCL_SetVramConfig(&tp);
  
! 						/*	ｿｽｿｽｿｽ]ｿｽｿｽ0ｿｽﾌ設抵ｿｽ				*/
  	SCL_InitConfigTb(&Rbg0Scfg);
  		Rbg0Scfg.dispenbl      = ON;
  		Rbg0Scfg.charsize      = SCL_CHAR_SIZE_1X1;
***************
*** 143,157 ****
  	slKtableRA((void *)RBG0_KTB_ADR , K_FIX | K_DOT | K_2WORD | K_ON);
  	slKtableRB((void *)RBG0_KTB_ADR , K_FIX | K_DOT | K_2WORD | K_ON);
  
! 						/*	プライオリティの設定		*/
  	SCL_SetPriority(SCL_RBG0,4);
  
! 						/*	地面の土のデータ転送	*/
  	Cel2VRAM(tuti_cel,(void *)RBG0RA_CEL_ADR,65536);
  	Map2VRAM(tuti_map,(void *)RBG0RA_MAP_ADR,64,64,2,884);
  	Pal2CRAM(tuti_pal,(void *)RBG0RA_COL_ADR,160);
  
! 						/*	空のデータ転送	*/
  	Cel2VRAM(sora_cel,(void *)RBG0RB_CEL_ADR,28288);
  	Map2VRAM(sora_map,(void *)RBG0RB_MAP_ADR,64,20,1,0);
  	Pal2CRAM(sora_pal,(void *)RBG0RB_COL_ADR,256);
--- 146,160 ----
  	slKtableRA((void *)RBG0_KTB_ADR , K_FIX | K_DOT | K_2WORD | K_ON);
  	slKtableRB((void *)RBG0_KTB_ADR , K_FIX | K_DOT | K_2WORD | K_ON);
  
! 						/*	ｿｽvｿｽｿｽｿｽCｿｽIｿｽｿｽｿｽeｿｽBｿｽﾌ設抵ｿｽ		*/
  	SCL_SetPriority(SCL_RBG0,4);
  
! 						/*	ｿｽnｿｽﾊの土ｿｽﾌデｿｽ[ｿｽ^ｿｽ]ｿｽｿｽ	*/
  	Cel2VRAM(tuti_cel,(void *)RBG0RA_CEL_ADR,65536);
  	Map2VRAM(tuti_map,(void *)RBG0RA_MAP_ADR,64,64,2,884);
  	Pal2CRAM(tuti_pal,(void *)RBG0RA_COL_ADR,160);
  
! 						/*	ｿｽｿｽｿｽﾌデｿｽ[ｿｽ^ｿｽ]ｿｽｿｽ	*/
  	Cel2VRAM(sora_cel,(void *)RBG0RB_CEL_ADR,28288);
  	Map2VRAM(sora_map,(void *)RBG0RB_MAP_ADR,64,20,1,0);
  	Pal2CRAM(sora_pal,(void *)RBG0RB_COL_ADR,256);
***************
*** 164,170 ****
  
  
  
! 						/*	main loop  画面操作		*/
  	while(1){
  		slCurRpara(RA);
  		slUnitMatrix(CURRENT);
--- 167,173 ----
  
  
  
! 						/*	main loop  ｿｽｿｽｿｽﾊ托ｿｽｿｽｿｽ		*/
  	while(1){
  		slCurRpara(RA);
  		slUnitMatrix(CURRENT);
***************
*** 198,201 ****
  		vr[i]=0x00000000;
  	}
  }
! 
\ No newline at end of file
--- 201,204 ----
  		vr[i]=0x00000000;
  	}
  }
! 
diff -crBN --binary sbl6/segasmp/scl/smpscl1/smpscl1.c sbl6_patch/segasmp/scl/smpscl1/smpscl1.c
*** sbl6/segasmp/scl/smpscl1/smpscl1.c	1996-02-08 05:31:50.000000000 -0500
--- sbl6_patch/segasmp/scl/smpscl1/smpscl1.c	2023-01-08 13:52:34.000000000 -0500
***************
*** 16,29 ****
   * 
   *------------------------------------------------------------------------
   */
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"..\..\v_blank\v_blank.h"
  
! #include	"..\graphic\cosmo2u.cha"
! #include	"..\graphic\cosmo2u.col"
! #include	"..\graphic\cosmo2u.map"
  
  /*----------------------------
  SCROLL NBG0 Cycle Table
--- 16,30 ----
   * 
   *------------------------------------------------------------------------
   */
+ #include	<string.h>
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"../../v_blank/v_blank.h"
  
! #include	"../graphic/cosmo2u.cha"
! #include	"../graphic/cosmo2u.col"
! #include	"../graphic/cosmo2u.map"
  
  /*----------------------------
  SCROLL NBG0 Cycle Table
***************
*** 40,46 ****
  };
  
  
! void main()
  {
  	SclConfig	scfg;
  	SclRgb		start,end;
--- 41,47 ----
  };
  
  
! int main()
  {
  	SclConfig	scfg;
  	SclRgb		start,end;
***************
*** 151,155 ****
  		if((PadData1 & PAD_C)) 	SCL_SetMosaic(SCL_NBG0,16,16);
  		SCL_DisplayFrame();
  	}
  }
! 
\ No newline at end of file
--- 152,157 ----
  		if((PadData1 & PAD_C)) 	SCL_SetMosaic(SCL_NBG0,16,16);
  		SCL_DisplayFrame();
  	}
+ 	return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/scl/smpscl3/scldata.c sbl6_patch/segasmp/scl/smpscl3/scldata.c
*** sbl6/segasmp/scl/smpscl3/scldata.c	1996-02-08 05:31:52.000000000 -0500
--- sbl6_patch/segasmp/scl/smpscl3/scldata.c	2022-02-09 09:08:36.000000000 -0500
***************
*** 4,15 ****
  #include	<sega_mth.h>
  #include	<sega_scl.h>
  
! #include	"..\graphic\grandu.cha"
! #include	"..\graphic\grandu.col"
! #include	"..\graphic\grandu.map"
! #include	"..\graphic\skyu.cha"
! #include	"..\graphic\skyu.col"
! #include	"..\graphic\skyu.map"
  
  
  void WordCopyforVRAM(void *dest,void *src,Uint32 tcnt);
--- 4,15 ----
  #include	<sega_mth.h>
  #include	<sega_scl.h>
  
! #include	"../graphic/grandu.cha"
! #include	"../graphic/grandu.col"
! #include	"../graphic/grandu.map"
! #include	"../graphic/skyu.cha"
! #include	"../graphic/skyu.col"
! #include	"../graphic/skyu.map"
  
  
  void WordCopyforVRAM(void *dest,void *src,Uint32 tcnt);
***************
*** 172,175 ****
      }
  }
  
! 
\ No newline at end of file
--- 172,175 ----
      }
  }
  
! 
diff -crBN --binary sbl6/segasmp/scl/smpscl3/smpscl3.c sbl6_patch/segasmp/scl/smpscl3/smpscl3.c
*** sbl6/segasmp/scl/smpscl3/smpscl3.c	1996-02-08 05:31:52.000000000 -0500
--- sbl6_patch/segasmp/scl/smpscl3/smpscl3.c	2024-08-01 16:36:10.000000000 -0400
***************
*** 1,7 ****
  /*------------------------------------------------------------------------
   *  FILE:	SmpScl3.c
   *
!  *      Copyright (c) by SEGA Enterprises Ltd. 1994. All rights reserved. 
   *
   *  PURPOSE:
   *		VDPII Test Program
--- 1,7 ----
  /*------------------------------------------------------------------------
   *  FILE:	SmpScl3.c
   *
!  *      Copyright (c) by SEGA Enterprises Ltd. 1994. All rights reserved.
   *
   *  PURPOSE:
   *		VDPII Test Program
***************
*** 14,46 ****
   */
  #include	<machine.h>
  #include	<sega_xpt.h>
! #include	<sega_def.h> 
! #include	<sega_mth.h> 
! #include	<sega_scl.h> 
  #include	"botan.h"
  
  void SetAutoLinePara(Uint16 SclNum);
  void ClrLinePara(Uint16 SclNum);
  
! extern SetVblank(void);				/*	追加 95.7.11 Chikahiro Yoshida	*/
! extern FirstData(Uint32 sclnum);	/*	追加 95.7.11 Chikahiro Yoshida	*/
! extern SecondData(Uint32 sclnum);	/*	追加 95.7.11 Chikahiro Yoshida	*/
  
  /********************************
!  * ｻｲｸﾙﾊﾟﾀｰﾝﾃｰﾌﾞﾙ               *
   ********************************/
  Uint16	CycleTb[]={
! 	0x01ff,0x4455,	/* VRAM A (VRAM A0)   1:NBG1ﾊﾟﾀｰﾝﾈｰﾑ(ﾏｯﾌﾟ)ﾘｰﾄﾞ */
! 			/*                    0:NBG0ﾊﾟﾀｰﾝﾈｰﾑ(ﾏｯﾌﾟ)ﾘｰﾄﾞ */
! 			/*                    5:NBG1ｷｬﾗｸﾀﾊﾟﾀｰﾝ(ｾﾙ)ﾘｰﾄﾞ */
! 			/*                    4:NBG0ｷｬﾗｸﾀﾊﾟﾀｰﾝ(ｾﾙ)ﾘｰﾄﾞ */
! 			/*                    f:ｱｸｾｽしない             */
! 	0xffff,0xffff,  /*        (VRAM A1)   無効（分割していない）   */
! 	0xffff,0xffff,  /* VRAM B (VRAM B0)   未使用                   */
! 	0xffff,0xffff   /*        (VRAM B1)   無効（分割していない）   */
  };
  
! void main()
  {
      SclConfig	scfg;
  /*    Uint16	*prnum_addr;	*/
--- 14,46 ----
   */
  #include	<machine.h>
  #include	<sega_xpt.h>
! #include	<sega_def.h>
! #include	<sega_mth.h>
! #include	<sega_scl.h>
  #include	"botan.h"
  
  void SetAutoLinePara(Uint16 SclNum);
  void ClrLinePara(Uint16 SclNum);
  
! extern void SetVblank(void);				/*	ｿｽﾇ会ｿｽ 95.7.11 Chikahiro Yoshida	*/
! extern void FirstData(Uint32 sclnum);	/*	ｿｽﾇ会ｿｽ 95.7.11 Chikahiro Yoshida	*/
! extern Uint32 SecondData(Uint32 sclnum);	/*	ｿｽﾇ会ｿｽ 95.7.11 Chikahiro Yoshida	*/
  
  /********************************
!  * ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾃｰｿｽｿｽｿｽ               *
   ********************************/
  Uint16	CycleTb[]={
! 	0x01ff,0x4455,	/* VRAM A (VRAM A0)   1:NBG1ｿｽｿｽｿｽｿｽｿｽﾈｰｿｽ(ﾏｯｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    0:NBG0ｿｽｿｽｿｽｿｽｿｽﾈｰｿｽ(ﾏｯｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    5:NBG1ｿｽｿｽﾗｸｿｽｿｽｿｽｿｽｿｽｿｽ(ｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    4:NBG0ｿｽｿｽﾗｸｿｽｿｽｿｽｿｽｿｽｿｽ(ｿｽｿｽ)ﾘｰｿｽｿｽ */
! 			/*                    f:ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾈゑｿｽ             */
! 	0xffff,0xffff,  /*        (VRAM A1)   ｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽj   */
! 	0xffff,0xffff,  /* VRAM B (VRAM B0)   ｿｽｿｽｿｽgｿｽp                   */
! 	0xffff,0xffff   /*        (VRAM B1)   ｿｽｿｽｿｽｿｽｿｽiｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾄゑｿｽｿｽﾈゑｿｽｿｽj   */
  };
  
! int main()
  {
      SclConfig	scfg;
  /*    Uint16	*prnum_addr;	*/
***************
*** 57,93 ****
      sclnum2 = SCL_NBG0;
  
     /*******************************************
!     *	ＶＤＰ２ライブラリの初期化            *
      *******************************************/
      SCL_Vdp2Init();
      SCL_SetFrameInterval(1);
  
     /*******************************************
!     *	カラーＲＡＭモードを1600万色に設定    *
      *******************************************/
      SCL_SetColRamMode(SCL_CRM24_1024);
  
     /*******************************
!     *	V_Blankルーチンの登録     *
      *******************************/
      SetVblank();
     /*******************************************
!     *	割り込みマスクを解除                  *
      *******************************************/
      set_imask(0);
      /*******************************************
!     *	カラーモード設定の為Ｖ−ＩＮＴ待ち     *
      ********************************************/
      SCL_DisplayFrame();
  
     /*******************************************
!     *	スクロールデータのセット              *
      *******************************************/
      FirstData(sclnum);
      StartAddr2 = SecondData(sclnum2);
  
     /*******************************************
!     *	ｽｸﾛｰﾙｺﾝﾌｨｸﾞﾚｰｼｮﾝの設定                *
      *******************************************/
      SCL_InitConfigTb(&scfg);
      scfg.dispenbl      = ON;
--- 57,93 ----
      sclnum2 = SCL_NBG0;
  
     /*******************************************
!     *	ｿｽuｿｽcｿｽoｿｽQｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ            *
      *******************************************/
      SCL_Vdp2Init();
      SCL_SetFrameInterval(1);
  
     /*******************************************
!     *	ｿｽJｿｽｿｽｿｽ[ｿｽqｿｽ`ｿｽlｿｽｿｽｿｽ[ｿｽhｿｽｿｽ1600ｿｽｿｽｿｽFｿｽﾉ設抵ｿｽ    *
      *******************************************/
      SCL_SetColRamMode(SCL_CRM24_1024);
  
     /*******************************
!     *	V_Blankｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽﾌ登ｿｽ^     *
      *******************************/
      SetVblank();
     /*******************************************
!     *	ｿｽｿｽｿｽ闕橸ｿｽﾝマｿｽXｿｽNｿｽｿｽｿｽｿｽｿｽｿｽ                  *
      *******************************************/
      set_imask(0);
      /*******************************************
!     *	ｿｽJｿｽｿｽｿｽ[ｿｽｿｽｿｽ[ｿｽhｿｽﾝ抵ｿｽｿｽﾌ為Ｖｿｽ|ｿｽhｿｽmｿｽsｿｽﾒゑｿｽ     *
      ********************************************/
      SCL_DisplayFrame();
  
     /*******************************************
!     *	ｿｽXｿｽNｿｽｿｽｿｽ[ｿｽｿｽｿｽfｿｽ[ｿｽ^ｿｽﾌセｿｽbｿｽg              *
      *******************************************/
      FirstData(sclnum);
      StartAddr2 = SecondData(sclnum2);
  
     /*******************************************
!     *	ｿｽｿｽﾛｰﾙｺｿｽﾌｨｿｽｿｽﾚｰｿｽｿｽﾝの設抵ｿｽ                *
      *******************************************/
      SCL_InitConfigTb(&scfg);
      scfg.dispenbl      = ON;
***************
*** 109,120 ****
      SCL_SetConfig(sclnum2, &scfg);
  
     /*******************************************
!     *	サイクルパターンの設定                *
      *******************************************/
      SCL_SetCycleTable(CycleTb);
  
     /*******************************************
!     *	ﾌﾟﾗｲｵﾘﾃｨを設定(0〜7)                  *
      *******************************************/
      SCL_SetPriority(sclnum2,7);
      SCL_SetPriority(sclnum,6);
--- 109,120 ----
      SCL_SetConfig(sclnum2, &scfg);
  
     /*******************************************
!     *	ｿｽTｿｽCｿｽNｿｽｿｽｿｽpｿｽ^ｿｽ[ｿｽｿｽｿｽﾌ設抵ｿｽ                *
      *******************************************/
      SCL_SetCycleTable(CycleTb);
  
     /*******************************************
!     *	ｿｽｿｽﾗｲｿｽｿｽﾃｨｿｽｿｽｿｽﾝ抵ｿｽ(0ｿｽ`7)                  *
      *******************************************/
      SCL_SetPriority(sclnum2,7);
      SCL_SetPriority(sclnum,6);
***************
*** 203,213 ****
  	}
  	sw++;
      }
  }
  
  
  /********************************************************************
!  * ラインパラメータテーブルのダミーを作成する                       *
   ********************************************************************/
  #define X_SIZE		320
  #define Y_SIZE		224
--- 203,214 ----
  	}
  	sw++;
      }
+     return 0;
  }
  
  
  /********************************************************************
!  * ｿｽｿｽｿｽCｿｽｿｽｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽｿｽﾌダｿｽ~ｿｽ[ｿｽｿｽｿｽ成ｿｽｿｽｿｽｿｽ                       *
   ********************************************************************/
  #define X_SIZE		320
  #define Y_SIZE		224
***************
*** 241,247 ****
  }
  
  /********************************************************************
!  * ラインパラメータテーブルを無効にする                             *
   ********************************************************************/
  void ClrLinePara(Uint16 SclNum)
  {
--- 242,248 ----
  }
  
  /********************************************************************
!  * ｿｽｿｽｿｽCｿｽｿｽｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽeｿｽ[ｿｽuｿｽｿｽｿｽ無鯉ｿｽｿｽﾉゑｿｽｿｽｿｽ                             *
   ********************************************************************/
  void ClrLinePara(Uint16 SclNum)
  {
***************
*** 254,257 ****
      SCL_Close();
      SCL_DisplayFrame();
  }
! 
\ No newline at end of file
--- 255,258 ----
      SCL_Close();
      SCL_DisplayFrame();
  }
! 
diff -crBN --binary sbl6/segasmp/scl/smpscl5/smpscl5.c sbl6_patch/segasmp/scl/smpscl5/smpscl5.c
*** sbl6/segasmp/scl/smpscl5/smpscl5.c	1996-02-08 05:31:56.000000000 -0500
--- sbl6_patch/segasmp/scl/smpscl5/smpscl5.c	2023-01-08 13:47:36.000000000 -0500
***************
*** 16,25 ****
   *------------------------------------------------------------------------
   */
  #include	<stdio.h>
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"..\..\v_blank\v_blank.h"
  
  	Uint16		PadData1EW,PadData2EW;
  	SclConfig	Rbg0Scfg,Rbg1Scfg;
--- 16,26 ----
   *------------------------------------------------------------------------
   */
  #include	<stdio.h>
+ #include	<string.h>
  #include	<machine.h>
  #include	<sega_scl.h> 
  
! #include	"../../v_blank/v_blank.h"
  
  	Uint16		PadData1EW,PadData2EW;
  	SclConfig	Rbg0Scfg,Rbg1Scfg;
***************
*** 49,55 ****
  #define	MAP_OFFSET	0x0800
  #define	MAP_NUM		16
  
! void main()
  {
  	SclVramConfig	tp;
  	Uint32		i,j;
--- 50,56 ----
  #define	MAP_OFFSET	0x0800
  #define	MAP_NUM		16
  
! int main()
  {
  	SclVramConfig	tp;
  	Uint32		i,j;
***************
*** 61,67 ****
  /*	XyInt		xy[2],sp[3];	*/
  							/* delete:no usd 95.7.11 Chikahiro Yoshida */
  	Uint32		Color[16];
! 	Uint8		*Pal32p8,sw,PrSw;
  /*	Uint32		SprColRam;	*/
  							/* delete: no used 95.7.11 Chikahiro Yoshida */
  	Uint32		Surface;
--- 62,68 ----
  /*	XyInt		xy[2],sp[3];	*/
  							/* delete:no usd 95.7.11 Chikahiro Yoshida */
  	Uint32		Color[16];
! 	Uint8		*Pal32p8,PrSw;
  /*	Uint32		SprColRam;	*/
  							/* delete: no used 95.7.11 Chikahiro Yoshida */
  	Uint32		Surface;
***************
*** 233,239 ****
  	*	パッドを使った画面の操作      *
  	**************************************/
  	r = FIXED(2);
- 	sw = 0;
  	PrSw = ON;
  	Surface = SCL_RBG_TB_A;
  	while(1){
--- 234,239 ----
***************
*** 281,286 ****
--- 281,287 ----
  		}
  		SCL_DisplayFrame();
  	}
+ 	return 0;
  }
  
  /*****************************************************************
***************
*** 337,343 ****
   * テクスチャーバッファにアスキーコード文字列を書く              *
   * （X_SIZE を 512に変更すればＶＤＰ２のＶＲＡＭにも使えます。） *
   *****************************************************************/
! void  Print256(Uint8 *vram,Uint8 *str,Uint16 x,Uint16 y,Uint8 col,Uint16 back)
  {
  	Uint32	i;
  	Uint16	wx,wy;
--- 338,344 ----
   * テクスチャーバッファにアスキーコード文字列を書く              *
   * （X_SIZE を 512に変更すればＶＤＰ２のＶＲＡＭにも使えます。） *
   *****************************************************************/
! void  Print256(Uint8 *vram, Uint8 *str, Uint16 x, Uint16 y, Uint8 col, Uint16 back)
  {
  	Uint32	i;
  	Uint16	wx,wy;
***************
*** 345,351 ****
  	wx = x;wy = y;
  
  	/* センタリング */
! 	if(wx > X_SIZE)	wx = X_SIZE/2 - strlen(str)*4;
  
  	i=0;
  	while(str[i]) {
--- 346,352 ----
  	wx = x;wy = y;
  
  	/* センタリング */
! 	if(wx > X_SIZE)	wx = X_SIZE/2 - strlen((const char *)str)*4;
  
  	i=0;
  	while(str[i]) {
***************
*** 387,390 ****
  	/* 文字の本体 */
  	Print256(vram,str,x,y,col,300);
  }
! 
\ No newline at end of file
--- 388,391 ----
  	/* 文字の本体 */
  	Print256(vram,str,x,y,col,300);
  }
! 
diff -crBN --binary sbl6/segasmp/sgl/demo_c/ss_akira.h sbl6_patch/segasmp/sgl/demo_c/ss_akira.h
*** sbl6/segasmp/sgl/demo_c/ss_akira.h	1996-02-08 05:32:10.000000000 -0500
--- sbl6_patch/segasmp/sgl/demo_c/ss_akira.h	2023-01-08 17:13:22.000000000 -0500
***************
*** 31,37 ****
  #define    INITANGY           DEG2ANG(90.0)
  #define    INITANGZ           DEG2ANG(0.0)
  
! extern     void slInitSystem(Uint16 , TEXTURE * , Uint16) ;
  extern     void objectdata(ANGLE * , FIXED *) ;
  extern     void Debuge() ;
  
--- 31,37 ----
  #define    INITANGY           DEG2ANG(90.0)
  #define    INITANGZ           DEG2ANG(0.0)
  
! //extern     void slInitSystem(Uint16 , TEXTURE * , Uint16) ;
  extern     void objectdata(ANGLE * , FIXED *) ;
  extern     void Debuge() ;
  
diff -crBN --binary sbl6/segasmp/sgl/s_7_6/main.c sbl6_patch/segasmp/sgl/s_7_6/main.c
*** sbl6/segasmp/sgl/s_7_6/main.c	1996-02-08 05:32:58.000000000 -0500
--- sbl6_patch/segasmp/sgl/s_7_6/main.c	2023-01-08 18:12:50.000000000 -0500
***************
*** 23,35 ****
  	  GRoffsetTBL(  0,-16,-16) , GRoffsetTBL(  0,-16,-16) } 
  };
  
! void main()
  {
  	static ANGLE	ang[XYZ];
  	static FIXED	pos[XYZ];
  
  	slInitSystem(TV_320x224,NULL,1);
! /*	slPrint("Sample program 7.6" , slLocate(9,2));	*/
  
  	ang[X] = DEGtoANG(30.0);
  	ang[Y] = DEGtoANG( 0.0);
--- 23,35 ----
  	  GRoffsetTBL(  0,-16,-16) , GRoffsetTBL(  0,-16,-16) } 
  };
  
! int main()
  {
  	static ANGLE	ang[XYZ];
  	static FIXED	pos[XYZ];
  
  	slInitSystem(TV_320x224,NULL,1);
! 	slPrint("Sample program 7.6" , slLocate(9,2));	
  
  	ang[X] = DEGtoANG(30.0);
  	ang[Y] = DEGtoANG( 0.0);
***************
*** 55,60 ****
  
  		slSynch();
  	}
  }
  
! 
\ No newline at end of file
--- 55,61 ----
  
  		slSynch();
  	}
+ 	return 0;
  }
  
! 
diff -crBN --binary sbl6/segasmp/snd/smpsnd1/smpsnd1.c sbl6_patch/segasmp/snd/smpsnd1/smpsnd1.c
*** sbl6/segasmp/snd/smpsnd1/smpsnd1.c	1996-02-08 05:33:10.000000000 -0500
--- sbl6_patch/segasmp/snd/smpsnd1/smpsnd1.c	2023-01-08 13:39:38.000000000 -0500
***************
*** 76,82 ****
   ******************************************************************************
   */
  void tubo(void);
! void main(void)
  {
  
      SndIniDt snd_init;                                  /* システム起動データ*/
--- 76,82 ----
   ******************************************************************************
   */
  void tubo(void);
! int main(void)
  {
  
      SndIniDt snd_init;                                  /* システム起動データ*/
***************
*** 139,143 ****
  				 3);
  	SND_StartSeq(1, 0, 2, 1);					/* シーケンス開始			 */
      while(1);
  }
! 
\ No newline at end of file
--- 139,144 ----
  				 3);
  	SND_StartSeq(1, 0, 2, 1);					/* シーケンス開始			 */
      while(1);
+     return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/snd/smpsnd4/smpsnd4.c sbl6_patch/segasmp/snd/smpsnd4/smpsnd4.c
*** sbl6/segasmp/snd/smpsnd4/smpsnd4.c	1996-02-08 05:33:14.000000000 -0500
--- sbl6_patch/segasmp/snd/smpsnd4/smpsnd4.c	2023-01-08 13:45:10.000000000 -0500
***************
*** 145,151 ****
  void PcmIntr(void);
  void r_PcmIntr(void);
  void l_PcmIntr(void);
! void main(void)
  {
  
  #if	0
--- 145,151 ----
  void PcmIntr(void);
  void r_PcmIntr(void);
  void l_PcmIntr(void);
! int main(void)
  {
  
  #if	0
***************
*** 257,262 ****
--- 257,263 ----
              SND_StopPcm(2);
          }
      }
+     return 0;
  }
  /*****************************************************************************/
  /* サウンド割り込み処理 */
***************
*** 295,298 ****
          l_move_bnk = ~l_move_bnk & 1;
          l_move_pcm_adr += 0x1000;
  }
! 
\ No newline at end of file
--- 296,299 ----
          l_move_bnk = ~l_move_bnk & 1;
          l_move_pcm_adr += 0x1000;
  }
! 
diff -crBN --binary sbl6/segasmp/snd/smpsnd5/smpsnd5.c sbl6_patch/segasmp/snd/smpsnd5/smpsnd5.c
*** sbl6/segasmp/snd/smpsnd5/smpsnd5.c	1996-02-08 05:33:18.000000000 -0500
--- sbl6_patch/segasmp/snd/smpsnd5/smpsnd5.c	2023-01-08 10:01:22.000000000 -0500
***************
*** 149,155 ****
  void PcmIntr(void);
  void r_PcmIntr(void);
  void l_PcmIntr(void);
! void main(void)
  {
  
  #if	0
--- 149,155 ----
  void PcmIntr(void);
  void r_PcmIntr(void);
  void l_PcmIntr(void);
! int main(void)
  {
  
  #if	0
***************
*** 276,281 ****
--- 276,282 ----
              break;
          }
      }
+     return 0;
  }
  /*****************************************************************************/
  /* サウンド割り込み処理 */
***************
*** 314,317 ****
          l_move_bnk = ~l_move_bnk & 1;
          l_move_pcm_adr += 0x1000;
  }
! 
\ No newline at end of file
--- 315,318 ----
          l_move_bnk = ~l_move_bnk & 1;
          l_move_pcm_adr += 0x1000;
  }
! 
diff -crBN --binary sbl6/segasmp/snd/smpsnd6/snd_main.c sbl6_patch/segasmp/snd/smpsnd6/snd_main.c
*** sbl6/segasmp/snd/smpsnd6/snd_main.c	1996-02-08 05:33:22.000000000 -0500
--- sbl6_patch/segasmp/snd/smpsnd6/snd_main.c	2024-08-19 15:00:08.000000000 -0400
***************
*** 5,15 ****
   *
   *  PURPOSE:
   *
!  *      サウンドI/Fライブラリソースファイル。
   *
   *  DESCRIPTION:
   *
!  *      サウンドドライバとのインタフェースを実現する。
   *
   *  INTERFACE:
   *
--- 5,15 ----
   *
   *  PURPOSE:
   *
!  *      ｿｽTｿｽEｿｽｿｽｿｽhI/FｿｽｿｽｿｽCｿｽuｿｽｿｽｿｽｿｽｿｽ\ｿｽ[ｿｽXｿｽtｿｽ@ｿｽCｿｽｿｽｿｽB
   *
   *  DESCRIPTION:
   *
!  *      ｿｽTｿｽEｿｽｿｽｿｽhｿｽhｿｽｿｽｿｽCｿｽoｿｽﾆのイｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽB
   *
   *  INTERFACE:
   *
***************
*** 17,23 ****
   *
   *  CAVEATS:
   *
!  *      なし。
   *
   *  AUTHOR(S)
   *
--- 17,23 ----
   *
   *  CAVEATS:
   *
!  *      ｿｽﾈゑｿｽｿｽB
   *
   *  AUTHOR(S)
   *
***************
*** 43,132 ****
  #include "sega_int.h"
  #include "sega_per.h"
  #include "sega_dma.h"
  
  /*
   * USER SUPPLIED INCLUDE FILES
   */
! #include "snd_main.h"
  
  /*
   * GLOBAL DECLARATIONS
   */
! Uint8 *snd_adr_sys_int_work;                 /*ｼｽﾃﾑｲﾝﾀﾌｪｰｽﾜｰｸ先頭ｱﾄﾞﾚｽ格納*/
  Uint32 snd_msk_work_work;                    /* sound priority msk        */
  
  /*
   * LOCAL DEFINES/MACROS
   */
  #if 0
! #define _DMA_SCU                                /* SCU DMA を使用する        */
  #endif
! /* 定数 */
! /**** アドレス ***************************************************************/
  #if	0
  /*
  **1995-11-2
! **	
  */
! #define ADR_SCSP_REG    ((Uint8 *)0x25b00400)   /* SCSP共通制御レジスタ      */
! #define ADR_SND_MEM     ((Uint8 *)0x25a00000)   /* サウンドメモリ先頭アドレス*/
! #define ADR_SND_VECTOR  ((Uint8 *)0x25a00000)   /* サウンドベクタアドレス    */
  #else
! #define ADR_SCSP_REG    ((volatile Uint8 *)0x25b00400)   /* SCSP共通制御レジスタ      */
! #define ADR_SND_MEM     ((volatile Uint8 *)0x25a00000)   /* サウンドメモリ先頭アドレス*/
! #define ADR_SND_VECTOR  ((volatile Uint8 *)0x25a00000)   /* サウンドベクタアドレス    */
! #endif
! #define ADR_SYS_TBL     (ADR_SND_MEM + 0x400)   /* ｼｽﾃﾑｲﾝﾀﾌｪｰｽ領域           */
! 
! /**** システムインタフェーステーブルオフセット *******************************/
! #define ADR_SYS_INFO    (0x00)                  /* ｼｽﾃﾑ情報ﾃｰﾌﾞﾙｱﾄﾞﾚｽ        */
! #define ADR_HOST_INT    (0x04)                  /* ﾎｽﾄｲﾝﾀﾌｪｰｽﾜｰｸｱﾄﾞﾚｽ        */
! #define ADR_ARA_CRNT    (0x08)                /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟCRNTﾜｰｸ先頭ｱﾄﾞﾚｽ*/
! #define ADR_SYS_INT_WORK    (0x12)            /* ｼｽﾃﾑｲﾝﾀﾌｪｰｽﾜｰｸ先頭ｱﾄﾞﾚｽ     */
! #define ADR_HARD_CHK_STAT   (0x18)            /* ﾊｰﾄﾞﾁｪｯｸﾘﾀｰﾝｽﾃｰﾀｽ格納ﾜｰｸ    */
! 
! /**** システム情報テーブルオフセット *****************************************/
! #define ADR_PRG_ADR     (0x00)                  /* 68Kﾌﾟﾛｸﾞﾗﾑ領域先頭ｱﾄﾞﾚｽ   */
! #define ADR_PRG_SIZE    (0x04)                  /* 68Kﾌﾟﾛｸﾞﾗﾑ領域ｻｲｽﾞ        */
! #define ADR_ARA_ADR     (0x08)                  /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟ領域先頭ｱﾄﾞﾚｽ */
! 
! /**** ホストインタフェースワークオフセット ***********************************/
! #define ADR_COM_DATA    (0x00)                  /* コマンド                  */
! #define ADR_PRM_DATA    (0x02)                  /* パラメータ                */
  #define ADR_SONG_STAT   (0x80)                  /* song status               */
  #define ADR_TL_VL       (0x90)                  /* Total volume              */
! #define ADR_TL_HZ_VL    (0x94)                  /* 周波数帯域別Volume        */
  #define ADR_PCM         (0xa0)                  /* PCM                       */
  #define ADR_SEQ         (0xb0)                  /* Sequence                  */
! /**** ホストインタフェースワーク定数 *****************************************/
! #define SIZE_COM_BLOCK      (0x10)              /* ｺﾏﾝﾄﾞﾌﾞﾛｯｸｻｲｽﾞ          */
! #define MAX_NUM_COM_BLOCK   8                   /* ｺﾏﾝﾄﾞﾌﾞﾛｯｸ数              */
! 
! /**** サウンド起動 ***********************************************************/
! #define SCSP_REG_SET    0x0200                  /* SCSPレジスタ設定値        */
! #define MEM_CLR_SIZE    0xb000                  /* ｻｳﾝﾄﾞﾒﾓﾘｸﾘｱｻｲｽﾞ           */
! 
! /**** サウンドエリアマップ情報(ﾛﾝｸﾞﾜｰﾄﾞ単位) *********************************/
! #define ARA_MAP_SIZE        0x2                 /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟｻｲｽﾞ          */
! /******** オフセット値(ﾛﾝｸﾞﾜｰﾄﾞ単位) *****************************************/
! #define ARA_MAP_0           0x0         /* ﾃﾞｰﾀ種別,ﾃﾞｰﾀ番号,ｴﾘｱ開始ｱﾄﾞﾚｽ    */
! #define ARA_MAP_4           0x1         /* 転送済みﾋﾞｯﾄ,ｴﾘｱｻｲｽﾞ              */
! /******** ビット位置 *********************************************************/
! #define B_END_MARK          31                  /* ﾃﾞｰﾀ終了ﾋﾞｯﾄ              */
! #define B_DATA_ID           28                  /* ﾃﾞｰﾀ種別　　　　　　　    */
! #define B_ID_NUM            24                  /* ﾃﾞｰﾀ番号                  */
! #define B_START_ADR         0                   /* ｽﾀｰﾄｱﾄﾞﾚｽ                 */
! #define B_LOAD_MARK         31                  /* 転送済みﾋﾞｯﾄ              */
! #define B_AREA_SIZE         0                   /* ｴﾘｱｻｲｽﾞ                   */
! /******** マスクビット *******************************************************/
! #define M_END_MARK         (0x1  << B_END_MARK) /* ﾃﾞｰﾀ終了ﾋﾞｯﾄ              */
! #define M_DATA_ID          (0x7  << B_DATA_ID)  /* ﾃﾞｰﾀ種別　　　　　　　    */
! #define M_ID_NUM           (0xf  << B_ID_NUM)   /* ﾃﾞｰﾀ番号                  */
! #define M_START_ADR        (0xfffff << B_START_ADR) /* ｽﾀｰﾄｱﾄﾞﾚｽ             */
! #define M_LOAD_MARK        (0x1  << B_LOAD_MARK)/* 転送済みﾋﾞｯﾄ              */
! #define M_AREA_SIZE        (0xfffff << B_AREA_SIZE) /* ｴﾘｱｻｲｽﾞ               */
  
! /**** コマンド ***************************************************************/
  #define COM_START_SEQ      0x01                 /* Sequence Start            */
  #define COM_STOP_SEQ       0x02                 /* Sequence Stop             */
  #define COM_PAUSE_SEQ      0x03                 /* Sequence Pause            */
--- 43,133 ----
  #include "sega_int.h"
  #include "sega_per.h"
  #include "sega_dma.h"
+ #include "sega_snd.h"
  
  /*
   * USER SUPPLIED INCLUDE FILES
   */
! //#include "snd_main.h"
  
  /*
   * GLOBAL DECLARATIONS
   */
! Uint8 *snd_adr_sys_int_work;                 /*ｿｽｿｽｿｽﾑｲｿｽｿｽﾌｪｿｽｿｽﾜｰｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽｿｽiｿｽ[*/
  Uint32 snd_msk_work_work;                    /* sound priority msk        */
  
  /*
   * LOCAL DEFINES/MACROS
   */
  #if 0
! #define _DMA_SCU                                /* SCU DMA ｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽｿｽ        */
  #endif
! /* ｿｽ關 */
! /**** ｿｽAｿｽhｿｽｿｽｿｽX ***************************************************************/
  #if	0
  /*
  **1995-11-2
! **
  */
! #define ADR_SCSP_REG    ((Uint8 *)0x25b00400)   /* SCSPｿｽｿｽｿｽﾊ撰ｿｽｿｽ艫鯉ｿｽWｿｽXｿｽ^      */
! #define ADR_SND_MEM     ((Uint8 *)0x25a00000)   /* ｿｽTｿｽEｿｽｿｽｿｽhｿｽｿｽｿｽｿｽｿｽｿｽｿｽ謫ｪｿｽAｿｽhｿｽｿｽｿｽX*/
! #define ADR_SND_VECTOR  ((Uint8 *)0x25a00000)   /* ｿｽTｿｽEｿｽｿｽｿｽhｿｽxｿｽNｿｽ^ｿｽAｿｽhｿｽｿｽｿｽX    */
  #else
! #define ADR_SCSP_REG    ((volatile Uint8 *)0x25b00400)   /* SCSPｿｽｿｽｿｽﾊ撰ｿｽｿｽ艫鯉ｿｽWｿｽXｿｽ^      */
! #define ADR_SND_MEM     ((volatile Uint8 *)0x25a00000)   /* ｿｽTｿｽEｿｽｿｽｿｽhｿｽｿｽｿｽｿｽｿｽｿｽｿｽ謫ｪｿｽAｿｽhｿｽｿｽｿｽX*/
! #define ADR_SND_VECTOR  ((volatile Uint8 *)0x25a00000)   /* ｿｽTｿｽEｿｽｿｽｿｽhｿｽxｿｽNｿｽ^ｿｽAｿｽhｿｽｿｽｿｽX    */
! #endif
! #define ADR_SYS_TBL     (ADR_SND_MEM + 0x400)   /* ｿｽｿｽｿｽﾑｲｿｽｿｽﾌｪｿｽｿｽｿｽﾌ茨ｿｽ           */
! 
! /**** ｿｽVｿｽXｿｽeｿｽｿｽｿｽCｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽeｿｽ[ｿｽuｿｽｿｽｿｽIｿｽtｿｽZｿｽbｿｽg *******************************/
! #define ADR_SYS_INFO    (0x00)                  /* ｿｽｿｽｿｽﾑ擾ｿｽｿｽｿｽﾃｰｿｽｿｽﾙｱｿｽｿｽﾚｽ        */
! #define ADR_HOST_INT    (0x04)                  /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽﾜｰｿｽｿｽｿｽｿｽﾚｽ        */
! #define ADR_ARA_CRNT    (0x08)                /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽｿｽCRNTﾜｰｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽ*/
! #define ADR_SYS_INT_WORK    (0x12)            /* ｿｽｿｽｿｽﾑｲｿｽｿｽﾌｪｿｽｿｽﾜｰｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽ     */
! #define ADR_HARD_CHK_STAT   (0x18)            /* ﾊｰｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾝｽﾃｰｿｽｿｽｿｽiｿｽ[ﾜｰｿｽ    */
! 
! /**** ｿｽVｿｽXｿｽeｿｽｿｽｿｽｿｽｿｽｿｽｿｽeｿｽ[ｿｽuｿｽｿｽｿｽIｿｽtｿｽZｿｽbｿｽg *****************************************/
! #define ADR_PRG_ADR     (0x00)                  /* 68Kｿｽｿｽﾛｸｿｽｿｽﾑ領茨ｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽ   */
! #define ADR_PRG_SIZE    (0x04)                  /* 68Kｿｽｿｽﾛｸｿｽｿｽﾑ領域ｻｲｿｽｿｽ        */
! #define ADR_ARA_ADR     (0x08)                  /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽﾟ領茨ｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽ */
! 
! /**** ｿｽzｿｽXｿｽgｿｽCｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽｿｽｿｽ[ｿｽNｿｽIｿｽtｿｽZｿｽbｿｽg ***********************************/
! #define ADR_COM_DATA    (0x00)                  /* ｿｽRｿｽ}ｿｽｿｽｿｽh                  */
! #define ADR_PRM_DATA    (0x02)                  /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^                */
  #define ADR_SONG_STAT   (0x80)                  /* song status               */
  #define ADR_TL_VL       (0x90)                  /* Total volume              */
! #define ADR_TL_HZ_VL    (0x94)                  /* ｿｽｿｽｿｽgｿｽｿｽｿｽﾑ茨ｿｽｿｽｿｽVolume        */
  #define ADR_PCM         (0xa0)                  /* PCM                       */
  #define ADR_SEQ         (0xb0)                  /* Sequence                  */
! /**** ｿｽzｿｽXｿｽgｿｽCｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽｿｽｿｽ[ｿｽNｿｽ關 *****************************************/
! #define SIZE_COM_BLOCK      (0x10)              /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾛｯｿｽｿｽｿｽｿｽｿｽ          */
! #define MAX_NUM_COM_BLOCK   8                   /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾛｯｿｽｿｽｿｽ              */
! 
! /**** ｿｽTｿｽEｿｽｿｽｿｽhｿｽNｿｽｿｽ ***********************************************************/
! #define SCSP_REG_SET    0x0200                  /* SCSPｿｽｿｽｿｽWｿｽXｿｽ^ｿｽﾝ抵ｿｽｿｽl        */
! #define MEM_CLR_SIZE    0xb000                  /* ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾘｸﾘｱｿｽｿｽｿｽｿｽ           */
! 
! /**** ｿｽTｿｽEｿｽｿｽｿｽhｿｽGｿｽｿｽｿｽAｿｽ}ｿｽbｿｽvｿｽｿｽｿｽｿｽ(ｿｽﾝｸｿｽﾜｰｿｽﾞ単ｿｽｿｽ) *********************************/
! #define ARA_MAP_SIZE        0x2                 /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽﾟｻｿｽｿｽｿｽ          */
! /******** ｿｽIｿｽtｿｽZｿｽbｿｽgｿｽl(ｿｽﾝｸｿｽﾜｰｿｽﾞ単ｿｽｿｽ) *****************************************/
! #define ARA_MAP_0           0x0         /* ｿｽﾞｰｿｽｿｽｿｽｿｽｿｽ,ｿｽﾞｰｿｽｿｽﾔ搾ｿｽ,ｿｽﾘｱｿｽJｿｽnｿｽｿｽｿｽﾚｽ    */
! #define ARA_MAP_4           0x1         /* ｿｽ]ｿｽｿｽｿｽﾏゑｿｽｿｽﾞｯｿｽ,ｿｽﾘｱｿｽｿｽｿｽｿｽ              */
! /******** ｿｽrｿｽbｿｽgｿｽﾊ置 *********************************************************/
! #define B_END_MARK          31                  /* ｿｽﾞｰｿｽｿｽIｿｽｿｽｿｽﾞｯｿｽ              */
! #define B_DATA_ID           28                  /* ｿｽﾞｰｿｽｿｽｿｽｿｽﾊ　ｿｽ@ｿｽ@ｿｽ@ｿｽ@ｿｽ@ｿｽ@    */
! #define B_ID_NUM            24                  /* ｿｽﾞｰｿｽｿｽﾔ搾ｿｽ                  */
! #define B_START_ADR         0                   /* ｿｽｿｽｿｽﾄｱｿｽｿｽﾚｽ                 */
! #define B_LOAD_MARK         31                  /* ｿｽ]ｿｽｿｽｿｽﾏゑｿｽｿｽﾞｯｿｽ              */
! #define B_AREA_SIZE         0                   /* ｿｽﾘｱｿｽｿｽｿｽｿｽ                   */
! /******** ｿｽ}ｿｽXｿｽNｿｽrｿｽbｿｽg *******************************************************/
! #define M_END_MARK         (0x1  << B_END_MARK) /* ｿｽﾞｰｿｽｿｽIｿｽｿｽｿｽﾞｯｿｽ              */
! #define M_DATA_ID          (0x7  << B_DATA_ID)  /* ｿｽﾞｰｿｽｿｽｿｽｿｽﾊ　ｿｽ@ｿｽ@ｿｽ@ｿｽ@ｿｽ@ｿｽ@    */
! #define M_ID_NUM           (0xf  << B_ID_NUM)   /* ｿｽﾞｰｿｽｿｽﾔ搾ｿｽ                  */
! #define M_START_ADR        (0xfffff << B_START_ADR) /* ｿｽｿｽｿｽﾄｱｿｽｿｽﾚｽ             */
! #define M_LOAD_MARK        (0x1  << B_LOAD_MARK)/* ｿｽ]ｿｽｿｽｿｽﾏゑｿｽｿｽﾞｯｿｽ              */
! #define M_AREA_SIZE        (0xfffff << B_AREA_SIZE) /* ｿｽﾘｱｿｽｿｽｿｽｿｽ               */
  
! /**** ｿｽRｿｽ}ｿｽｿｽｿｽh ***************************************************************/
  #define COM_START_SEQ      0x01                 /* Sequence Start            */
  #define COM_STOP_SEQ       0x02                 /* Sequence Stop             */
  #define COM_PAUSE_SEQ      0x03                 /* Sequence Pause            */
***************
*** 154,183 ****
  #define COM_CHK_HARD       0x89                 /* Hard check                */
  #define COM_CHG_PCM_PRM    0x8a                 /* PCM parameter change      */
  
! /* 処理マクロ */
! /**** メモリライト ***********************************************************/
! #define POKE_B(adr, data)   (*((volatile Uint8 *)(adr)) = ((Uint8)(data)))   /* ﾊﾞｲﾄ  */
! #define POKE_W(adr, data)   (*((volatile Uint16 *)(adr)) = ((Uint16)(data))) /* ﾜｰﾄﾞ  */
! #define POKE_L(adr, data)   (*((volatile Uint32 *)(adr)) = ((Uint32)(data))) /* ﾛﾝｸﾞ  */
! /**** メモリリード ***********************************************************/
! #define PEEK_B(adr)         (*((volatile Uint8 *)(adr)))                     /* ﾊﾞｲﾄ  */
! #define PEEK_W(adr)         (*((volatile Uint16 *)(adr)))                    /* ﾜｰﾄﾞ  */
! #define PEEK_L(adr)         (*((volatile Uint32 *)(adr)))                    /* ﾛﾝｸﾞ  */
! /**** ﾛﾝｸﾞﾜｰﾄﾞﾊﾞｳﾝﾀﾞﾘ変換(Middle SCUの制限回避 *******************************/
  #define CHG_LONG(x)    (((x) * 2) + (0x4 - ( ((x) * 2) % 4) ))
! /**** ホストインタフェースワークマクロ ***************************************/
! #define MAX_ADR_COM_DATA                        /* 最大ｺﾏﾝﾄﾞﾃﾞｰﾀｱﾄﾞﾚｽ     */\
      (adr_host_int_work + ADR_COM_DATA + (SIZE_COM_BLOCK * MAX_NUM_COM_BLOCK))
! #define NOW_ADR_COM_DATA                        /* 現在ｺﾏﾝﾄﾞﾃﾞｰﾀｱﾄﾞﾚｽ     */\
      (adr_com_block + ADR_COM_DATA)
! /**** サウンドドライバコマンドブロック設定関数初期処理マクロ *****************/
  #define HOST_SET_INIT()\
      Uint32 msk;\
      do{\
          msk = get_imask();\
          set_imask(0xf);\
      }while(FALSE)
! /**** サウンドドライバコマンドブロック設定関数リターンマクロ *****************/
  /* 1994/02/24 Start */
  #if 0
  #define HOST_SET_RETURN(ret)\
--- 155,184 ----
  #define COM_CHK_HARD       0x89                 /* Hard check                */
  #define COM_CHG_PCM_PRM    0x8a                 /* PCM parameter change      */
  
! /* ｿｽｿｽｿｽｿｽｿｽ}ｿｽNｿｽｿｽ */
! /**** ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽCｿｽg ***********************************************************/
! #define POKE_B(adr, data)   (*((volatile Uint8 *)(adr)) = ((Uint8)(data)))   /* ｿｽﾞｲｿｽ  */
! #define POKE_W(adr, data)   (*((volatile Uint16 *)(adr)) = ((Uint16)(data))) /* ﾜｰｿｽｿｽ  */
! #define POKE_L(adr, data)   (*((volatile Uint32 *)(adr)) = ((Uint32)(data))) /* ｿｽﾝｸｿｽ  */
! /**** ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽh ***********************************************************/
! #define PEEK_B(adr)         (*((volatile Uint8 *)(adr)))                     /* ｿｽﾞｲｿｽ  */
! #define PEEK_W(adr)         (*((volatile Uint16 *)(adr)))                    /* ﾜｰｿｽｿｽ  */
! #define PEEK_L(adr)         (*((volatile Uint32 *)(adr)))                    /* ｿｽﾝｸｿｽ  */
! /**** ｿｽﾝｸｿｽﾜｰｿｽｿｽｿｽﾞｳｿｽｿｽｿｽﾘ変奇ｿｽ(Middle SCUｿｽﾌ撰ｿｽｿｽｿｽｿｽｿｽｿｽｿｽ *******************************/
  #define CHG_LONG(x)    (((x) * 2) + (0x4 - ( ((x) * 2) % 4) ))
! /**** ｿｽzｿｽXｿｽgｿｽCｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽｿｽｿｽ[ｿｽNｿｽ}ｿｽNｿｽｿｽ ***************************************/
! #define MAX_ADR_COM_DATA                        /* ｿｽﾅ托ｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾞｰｿｽｿｽｿｽｿｽﾚｽ     */\
      (adr_host_int_work + ADR_COM_DATA + (SIZE_COM_BLOCK * MAX_NUM_COM_BLOCK))
! #define NOW_ADR_COM_DATA                        /* ｿｽｿｽｿｽﾝｺｿｽｿｽｿｽｿｽｿｽﾞｰｿｽｿｽｿｽｿｽﾚｽ     */\
      (adr_com_block + ADR_COM_DATA)
! /**** ｿｽTｿｽEｿｽｿｽｿｽhｿｽhｿｽｿｽｿｽCｿｽoｿｽRｿｽ}ｿｽｿｽｿｽhｿｽuｿｽｿｽｿｽbｿｽNｿｽﾝ抵ｿｽｿｽﾖ撰ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ}ｿｽNｿｽｿｽ *****************/
  #define HOST_SET_INIT()\
      Uint32 msk;\
      do{\
          msk = get_imask();\
          set_imask(0xf);\
      }while(FALSE)
! /**** ｿｽTｿｽEｿｽｿｽｿｽhｿｽhｿｽｿｽｿｽCｿｽoｿｽRｿｽ}ｿｽｿｽｿｽhｿｽuｿｽｿｽｿｽbｿｽNｿｽﾝ抵ｿｽｿｽﾖ撰ｿｽｿｽｿｽｿｽ^ｿｽ[ｿｽｿｽｿｽ}ｿｽNｿｽｿｽ *****************/
  /* 1994/02/24 Start */
  #if 0
  #define HOST_SET_RETURN(ret)\
***************
*** 188,194 ****
      }while(FALSE)
  #endif
  
! /* 割り込み使用時の2重呼び出し防止フラグ */
  static Uint32 intrflag;
  #define HOST_SET_RETURN(ret)\
      do{\
--- 189,195 ----
      }while(FALSE)
  #endif
  
! /* ｿｽｿｽｿｽ闕橸ｿｽﾝ使ｿｽpｿｽｿｽｿｽｿｽ2ｿｽdｿｽﾄび出ｿｽｿｽｿｽhｿｽ~ｿｽtｿｽｿｽｿｽO */
  static Uint32 intrflag;
  #define HOST_SET_RETURN(ret)\
      do{\
***************
*** 196,202 ****
          return(ret);\
      }while(FALSE)
  
! /*** サウンドドライバへのアクセスウェートマクロ */
  #define _WAIT_() do{\
  int i,j;for(i=0;i<32;i++) j=*(volatile int *)0;\
  }while(0)
--- 197,203 ----
          return(ret);\
      }while(FALSE)
  
! /*** ｿｽTｿｽEｿｽｿｽｿｽhｿｽhｿｽｿｽｿｽCｿｽoｿｽﾖのアｿｽNｿｽZｿｽXｿｽEｿｽFｿｽ[ｿｽgｿｽ}ｿｽNｿｽｿｽ */
  #define _WAIT_() do{\
  int i,j;for(i=0;i<32;i++) j=*(volatile int *)0;\
  }while(0)
***************
*** 204,299 ****
  
  /******************************************************************************
   *
!  * NAME:    SET_COMMAND()       - コマンドセット
   *
   * PARAMETERS :
!  *      (1) Uint16 set_com      - <i>   コマンド
   *
   * DESCRIPTION:
!  *      コマンドをインタフェース領域にセットします。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      ｺﾏﾝﾄﾞへのWRITEは16bitで行ないます。16bit中の上位8bitへｺﾏﾝﾄﾞをｾｯﾄします
   *
   ******************************************************************************
   */
  
  #define SET_COMMAND(set_com)\
! (POKE_W((adr_com_block + ADR_COM_DATA), (Uint16)(set_com) << 8)) /* コマンドセット   */
  
  /******************************************************************************
   *
!  * NAME:    SET_PRM()           - パラメータセット
   *
   * PARAMETERS :
!  *      (1) Uint32 no           - <i>   パラメータ番号
!  *      (2) Uint8 set_prm       - <i>   パラメータ
   *
   * DESCRIPTION:
!  *      パラメータをインタフェース領域にセットします。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
  
  #define SET_PRM(no, set_prm)\
! (POKE_B(adr_com_block + ADR_PRM_DATA + (no), (set_prm))) /* ﾊﾟﾗﾒｰﾀセット      */
  
  /*
   * STATIC DECLARATIONS
!  */ 
! static volatile Uint8 *adr_sys_info_tbl;                 /* ｼｽﾃﾑ情報ﾃｰﾌﾞﾙｱﾄﾞﾚｽ格納    */
! static volatile Uint8 *adr_host_int_work;                /* ﾎｽﾄｲﾝﾀﾌｪｰｽﾜｰｸ先頭ｱﾄﾞﾚｽ格納*/
! static volatile Uint32 *adr_snd_area_crnt;             /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟCRNTﾜｰｸ先頭ｱﾄﾞﾚｽ*/
  static volatile Uint16 *adr_song_stat;                   /* song status               */
  static volatile Uint16 *adr_tl_vl;                       /* Total volume              */
! static volatile Uint16 *adr_tl_hz_vl;                    /* 周波数帯域別Volume        */
  static volatile Uint16 *adr_pcm;                         /* PCM                       */
  static volatile Uint16 *adr_seq;                         /* Sequence                  */
! static volatile Uint8  *adr_com_block;                   /* 現在書き込みｺﾏﾝﾄﾞﾌﾞﾛｯｸ      */
  
  /*
   * STATIC FUNCTION PROTOTYPE DECLARATIONS
   */
  static void DmaClrZero(void *, Uint32);
  static void GetSndMapInfo(void **, Uint32 **, Uint16, Uint16);
! static Uint16 ChgPan(SndPan);
  static void CopyMem(void *,void *,Uint32);
  static Uint8 GetComBlockAdr(void);
  
  
  /******************************************************************************
   *
!  * NAME:    SND_Init()  - サウンドシステム起動
   *
   * PARAMETERS :
!  *      (1) SndIniDt *sys_ini       - <i>   システム起動用データ
   *
   * DESCRIPTION:
!  *      システム起動用データに従って、サウンドシステムを起動する。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
--- 205,300 ----
  
  /******************************************************************************
   *
!  * NAME:    SET_COMMAND()       - ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg
   *
   * PARAMETERS :
!  *      (1) Uint16 set_com      - <i>   ｿｽRｿｽ}ｿｽｿｽｿｽh
   *
   * DESCRIPTION:
!  *      ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽCｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽﾌ茨ｿｽｿｽﾉセｿｽbｿｽgｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽｿｽｿｽｿｽﾞへゑｿｽWRITEｿｽｿｽ16bitｿｽﾅ行ｿｽﾈゑｿｽｿｽﾜゑｿｽｿｽB16bitｿｽｿｽｿｽﾌ擾ｿｽｿｽｿｽ8bitｿｽﾖｺｿｽｿｽｿｽﾞゑｿｽｿｽｿｽﾄゑｿｽｿｽﾜゑｿｽ
   *
   ******************************************************************************
   */
  
  #define SET_COMMAND(set_com)\
! (POKE_W((adr_com_block + ADR_COM_DATA), (Uint16)(set_com) << 8)) /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg   */
  
  /******************************************************************************
   *
!  * NAME:    SET_PRM()           - ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg
   *
   * PARAMETERS :
!  *      (1) Uint32 no           - <i>   ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽﾔ搾ｿｽ
!  *      (2) Uint8 set_prm       - <i>   ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^
   *
   * DESCRIPTION:
!  *      ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽｿｽｿｽCｿｽｿｽｿｽ^ｿｽtｿｽFｿｽ[ｿｽXｿｽﾌ茨ｿｽｿｽﾉセｿｽbｿｽgｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
  
  #define SET_PRM(no, set_prm)\
! (POKE_B(adr_com_block + ADR_PRM_DATA + (no), (set_prm))) /* ｿｽｿｽｿｽﾒｰｿｽｿｽZｿｽbｿｽg      */
  
  /*
   * STATIC DECLARATIONS
!  */
! static volatile Uint8 *adr_sys_info_tbl;                 /* ｿｽｿｽｿｽﾑ擾ｿｽｿｽｿｽﾃｰｿｽｿｽﾙｱｿｽｿｽﾚｽｿｽiｿｽ[    */
! static volatile Uint8 *adr_host_int_work;                /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽﾜｰｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽｿｽiｿｽ[*/
! static volatile Uint32 *adr_snd_area_crnt;             /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽｿｽCRNTﾜｰｿｽｿｽ謫ｪｿｽｿｽｿｽﾚｽ*/
  static volatile Uint16 *adr_song_stat;                   /* song status               */
  static volatile Uint16 *adr_tl_vl;                       /* Total volume              */
! static volatile Uint16 *adr_tl_hz_vl;                    /* ｿｽｿｽｿｽgｿｽｿｽｿｽﾑ茨ｿｽｿｽｿｽVolume        */
  static volatile Uint16 *adr_pcm;                         /* PCM                       */
  static volatile Uint16 *adr_seq;                         /* Sequence                  */
! static volatile Uint8  *adr_com_block;                   /* ｿｽｿｽｿｽﾝ擾ｿｽｿｽｿｽｿｽｿｽｿｽﾝｺｿｽｿｽｿｽｿｽｿｽｿｽﾛｯｿｽ      */
  
  /*
   * STATIC FUNCTION PROTOTYPE DECLARATIONS
   */
  static void DmaClrZero(void *, Uint32);
  static void GetSndMapInfo(void **, Uint32 **, Uint16, Uint16);
! static Uint16 ChgPan(SndPan pan);
  static void CopyMem(void *,void *,Uint32);
  static Uint8 GetComBlockAdr(void);
  
  
  /******************************************************************************
   *
!  * NAME:    SND_Init()  - ｿｽTｿｽEｿｽｿｽｿｽhｿｽVｿｽXｿｽeｿｽｿｽｿｽNｿｽｿｽ
   *
   * PARAMETERS :
!  *      (1) SndIniDt *sys_ini       - <i>   ｿｽVｿｽXｿｽeｿｽｿｽｿｽNｿｽｿｽｿｽpｿｽfｿｽ[ｿｽ^
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽXｿｽeｿｽｿｽｿｽNｿｽｿｽｿｽpｿｽfｿｽ[ｿｽ^ｿｽﾉ従ｿｽｿｽｿｽﾄ、ｿｽTｿｽEｿｽｿｽｿｽhｿｽVｿｽXｿｽeｿｽｿｽｿｽｿｽｿｽNｿｽｿｽｿｽｿｽｿｽｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
***************
*** 302,334 ****
  {
      /** BEGIN ****************************************************************/
  #ifdef _DMA_SCU
!     DMA_ScuInit();                              /* DMA SCU初期化処理         */
  #endif /* _DMA_SCU */
  
!     PER_SMPC_SND_OFF();                         /* サウンドOFF               */
!     POKE_W(ADR_SCSP_REG, SCSP_REG_SET); 
!                                                 /* SCSP共通ﾚｼﾞｽﾀ設定         */
!     DmaClrZero(ADR_SND_MEM, MEM_CLR_SIZE);      /* DMAメモリゼロクリア       */
      CopyMem(ADR_SND_VECTOR,
                     (void *)(SND_INI_PRG_ADR(*sys_ini)),
!                    SND_INI_PRG_SZ(*sys_ini));   /* 68Kﾌﾟﾛｸﾞﾗﾑ転送            */
  
      adr_sys_info_tbl = (Uint8 *)(ADR_SND_MEM + PEEK_L(ADR_SYS_TBL +
                                   ADR_SYS_INFO));
!                                                 /* ｼｽﾃﾑ情報ﾃｰﾌﾞﾙｱﾄﾞﾚｽ取得    */
      adr_host_int_work = (Uint8 *)(ADR_SND_MEM + PEEK_L(ADR_SYS_TBL +
                                    ADR_HOST_INT));
!                                                 /* ﾎｽﾄｲﾝﾀﾌｪｰｽﾜｰｸｱﾄﾞﾚｽ取得    */
!     snd_adr_sys_int_work = (Uint8 *)(ADR_SND_MEM + 
                   ((Uint32)PEEK_W(ADR_SYS_TBL + ADR_SYS_INT_WORK) << 16
                    | (Uint32)PEEK_W(ADR_SYS_TBL + ADR_SYS_INT_WORK + 2)));
!                                                 /* ｼｽﾃﾑｲﾝﾀﾌｪｰｽﾜｰｸｱﾄﾞﾚｽ取得   */
!                                                 
!     adr_com_block = adr_host_int_work;  /* 現在書き込みｺﾏﾝﾄﾞﾌﾞﾛｯｸｱﾄﾞﾚｽ初期化 */
!                                                 
!     adr_snd_area_crnt = (Uint32 *)(ADR_SND_MEM + 
                                    PEEK_L(ADR_SYS_TBL + ADR_ARA_CRNT));
!                                                 /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟCRNTﾜｰｸ取得   */
      adr_song_stat = (Uint16 *)(adr_host_int_work + ADR_SONG_STAT);
      adr_pcm = (Uint16 *)(adr_host_int_work + ADR_PCM);
      adr_seq = (Uint16 *)(adr_host_int_work + ADR_SEQ);
--- 303,335 ----
  {
      /** BEGIN ****************************************************************/
  #ifdef _DMA_SCU
!     DMA_ScuInit();                              /* DMA SCUｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ         */
  #endif /* _DMA_SCU */
  
!     PER_SMPC_SND_OFF();                         /* ｿｽTｿｽEｿｽｿｽｿｽhOFF               */
!     POKE_W(ADR_SCSP_REG, SCSP_REG_SET);
!                                                 /* SCSPｿｽｿｽｿｽｿｽﾚｼﾞｽｿｽｿｽﾝ抵ｿｽ         */
!     DmaClrZero(ADR_SND_MEM, MEM_CLR_SIZE);      /* DMAｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽNｿｽｿｽｿｽA       */
      CopyMem(ADR_SND_VECTOR,
                     (void *)(SND_INI_PRG_ADR(*sys_ini)),
!                    SND_INI_PRG_SZ(*sys_ini));   /* 68Kｿｽｿｽﾛｸｿｽｿｽﾑ転ｿｽｿｽ            */
  
      adr_sys_info_tbl = (Uint8 *)(ADR_SND_MEM + PEEK_L(ADR_SYS_TBL +
                                   ADR_SYS_INFO));
!                                                 /* ｿｽｿｽｿｽﾑ擾ｿｽｿｽｿｽﾃｰｿｽｿｽﾙｱｿｽｿｽﾚｽｿｽ謫ｾ    */
      adr_host_int_work = (Uint8 *)(ADR_SND_MEM + PEEK_L(ADR_SYS_TBL +
                                    ADR_HOST_INT));
!                                                 /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽﾜｰｿｽｿｽｿｽｿｽﾚｽｿｽ謫ｾ    */
!     snd_adr_sys_int_work = (Uint8 *)(ADR_SND_MEM +
                   ((Uint32)PEEK_W(ADR_SYS_TBL + ADR_SYS_INT_WORK) << 16
                    | (Uint32)PEEK_W(ADR_SYS_TBL + ADR_SYS_INT_WORK + 2)));
!                                                 /* ｿｽｿｽｿｽﾑｲｿｽｿｽﾌｪｿｽｿｽﾜｰｿｽｿｽｿｽｿｽﾚｽｿｽ謫ｾ   */
! 
!     adr_com_block = adr_host_int_work;  /* ｿｽｿｽｿｽﾝ擾ｿｽｿｽｿｽｿｽｿｽｿｽﾝｺｿｽｿｽｿｽｿｽｿｽｿｽﾛｯｿｽｿｽｿｽｿｽﾚｽｿｽｿｽｿｽｿｽｿｽｿｽ */
! 
!     adr_snd_area_crnt = (Uint32 *)(ADR_SND_MEM +
                                    PEEK_L(ADR_SYS_TBL + ADR_ARA_CRNT));
!                                                 /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽｿｽCRNTﾜｰｿｽｿｽ謫ｾ   */
      adr_song_stat = (Uint16 *)(adr_host_int_work + ADR_SONG_STAT);
      adr_pcm = (Uint16 *)(adr_host_int_work + ADR_PCM);
      adr_seq = (Uint16 *)(adr_host_int_work + ADR_SEQ);
***************
*** 338,549 ****
      CopyMem((void *)
                      (PEEK_L(adr_sys_info_tbl + ADR_ARA_ADR) + ADR_SND_MEM),
                     (void *)(SND_INI_ARA_ADR(*sys_ini)),
!                    CHG_LONG(SND_INI_ARA_SZ(*sys_ini))); /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟ転送  */
  /* 1994/02/24 Start*/
!     intrflag = 0;         /* 割り込みフラグの初期化 */
  /* 1994/02/24 End */
  
!     PER_SMPC_SND_ON();                          /* サウンドON                */
  
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_MoveData()  - サウンドデータ転送
   *
   * PARAMETERS :
!  *      (1) Uint16 *source      - <i>   サウンドデータ転送元アドレス
!  *      (2) Uint32 size         - <i>   サウンドデータ転送サイズ
!  *      (3) Uint16 data_kind    - <i>   データ種別
!  *      (4) Uint16 data_no      - <i>   データ番号
   *
   * DESCRIPTION:
!  *      サウンドデータをサウンドメモリへ転送します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
  
  void SND_MoveData(Uint16 *source, Uint32 size,Uint16 data_kind, Uint16 data_no)
  {
!     void *adr;                                  /* 転送先アドレス            */
!     Uint32 *load_mark_adr;                      /* 転送済みビット設定ｱﾄﾞﾚｽ  */
  
      GetSndMapInfo(&adr, &load_mark_adr, data_kind, data_no);
!                                                 /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟ情報取得      */
  
!     CopyMem(adr, (void *)source, size);         /* ｻｳﾝﾄﾞｴﾘｱﾏｯﾌﾟ転送         */
      POKE_L(load_mark_adr, (*load_mark_adr | M_LOAD_MARK));
!                                                 /* 転送済みﾋﾞｯﾄ ｵﾝ            */
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgMap()    - サウンドエリアマップ変更
   *
   * PARAMETERS :
!  *      (1) SndAreaMap area_no  - <i>   サウンドエリアマップ番号
   *
   * DESCRIPTION:
!  *      サウンドエリアマップを変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChgMap(SndAreaMap area_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, area_no);                        /* パラメータセット          */
!     SET_COMMAND(COM_CHG_MAP);                   /* コマンドセット            */
  
      while(PEEK_W(adr_com_block + ADR_COM_DATA)) _WAIT_();
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, area_no);                        /* パラメータセット          */
!     SET_COMMAND(COM_CHG_MAP);                   /* コマンドセット            */
      while(PEEK_W(adr_com_block + ADR_COM_DATA)) _WAIT_();
      HOST_SET_RETURN(SND_RET_SET);
  }
  /******************************************************************************
   *
!  * NAME:    SND_SetTlVl()   - 全体音量設定
   *
   * PARAMETERS :
!  *      (1) SndTlVl vol         - <i>   全体音量
   *
   * DESCRIPTION:
!  *      全体音量を設定します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
  
   SndRet SND_SetTlVl(SndTlVl vol)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, vol);                            /* パラメータセット          */
!     SET_COMMAND(COM_SET_TL_VL);                 /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgEfct()   - エフェクト変更
   *
   * PARAMETERS :
   *      (1) SndEfctBnkNum efct_no <i>   Effect bank number
   *
   * DESCRIPTION:
!  *      エフェクトを変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChgEfct(SndEfctBnkNum efct_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, efct_no);                        /* パラメータセット          */
!     SET_COMMAND(COM_CHG_EFCT);                  /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgMix()    - ミキサ変更
   *
   * PARAMETERS :
!  *      (1) SndToneBnkNum tone_no   <i>   音色 bank number
   *      (2) SndMixBnkNum mix_no     <i>   MIxer bank number
   *
   * DESCRIPTION:
!  *      ミキサを変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChgMix(SndToneBnkNum tone_no, SndMixBnkNum mix_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, tone_no);                        /* パラメータセット          */
!     SET_PRM(1, mix_no);                         /* パラメータセット          */
!     SET_COMMAND(COM_CHG_MIX);                   /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgMixPrm()     - ミキサパラメータ変更
   *
   * PARAMETERS :
   *      (1) SndEfctOut efct_out     <i>   Effect out select
--- 339,550 ----
      CopyMem((void *)
                      (PEEK_L(adr_sys_info_tbl + ADR_ARA_ADR) + ADR_SND_MEM),
                     (void *)(SND_INI_ARA_ADR(*sys_ini)),
!                    CHG_LONG(SND_INI_ARA_SZ(*sys_ini))); /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽﾟ転ｿｽｿｽ  */
  /* 1994/02/24 Start*/
!     intrflag = 0;         /* ｿｽｿｽｿｽ闕橸ｿｽﾝフｿｽｿｽｿｽOｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽ */
  /* 1994/02/24 End */
  
!     PER_SMPC_SND_ON();                          /* ｿｽTｿｽEｿｽｿｽｿｽhON                */
  
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_MoveData()  - ｿｽTｿｽEｿｽｿｽｿｽhｿｽfｿｽ[ｿｽ^ｿｽ]ｿｽｿｽ
   *
   * PARAMETERS :
!  *      (1) Uint16 *source      - <i>   ｿｽTｿｽEｿｽｿｽｿｽhｿｽfｿｽ[ｿｽ^ｿｽ]ｿｽｿｽｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽX
!  *      (2) Uint32 size         - <i>   ｿｽTｿｽEｿｽｿｽｿｽhｿｽfｿｽ[ｿｽ^ｿｽ]ｿｽｿｽｿｽTｿｽCｿｽY
!  *      (3) Uint16 data_kind    - <i>   ｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽｿｽ
!  *      (4) Uint16 data_no      - <i>   ｿｽfｿｽ[ｿｽ^ｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽTｿｽEｿｽｿｽｿｽhｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽTｿｽEｿｽｿｽｿｽhｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾖ転ｿｽｿｽｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
  
  void SND_MoveData(Uint16 *source, Uint32 size,Uint16 data_kind, Uint16 data_no)
  {
!     void *adr;                                  /* ｿｽ]ｿｽｿｽｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽX            */
!     Uint32 *load_mark_adr;                      /* ｿｽ]ｿｽｿｽｿｽﾏみビｿｽbｿｽgｿｽﾝ抵ｿｽｿｽｿｽｿｽﾚｽ  */
  
      GetSndMapInfo(&adr, &load_mark_adr, data_kind, data_no);
!                                                 /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽﾟ擾ｿｽｿｽｿｽｿｽ謫ｾ      */
  
!     CopyMem(adr, (void *)source, size);         /* ｿｽｿｽｿｽｿｽﾞｴﾘｱﾏｯｿｽﾟ転ｿｽｿｽ         */
      POKE_L(load_mark_adr, (*load_mark_adr | M_LOAD_MARK));
!                                                 /* ｿｽ]ｿｽｿｽｿｽﾏゑｿｽｿｽﾞｯｿｽ ｿｽｿｽ            */
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgMap()    - ｿｽTｿｽEｿｽｿｽｿｽhｿｽGｿｽｿｽｿｽAｿｽ}ｿｽbｿｽvｿｽﾏ更
   *
   * PARAMETERS :
!  *      (1) SndAreaMap area_no  - <i>   ｿｽTｿｽEｿｽｿｽｿｽhｿｽGｿｽｿｽｿｽAｿｽ}ｿｽbｿｽvｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽTｿｽEｿｽｿｽｿｽhｿｽGｿｽｿｽｿｽAｿｽ}ｿｽbｿｽvｿｽｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChgMap(SndAreaMap area_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, area_no);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHG_MAP);                   /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
  
      while(PEEK_W(adr_com_block + ADR_COM_DATA)) _WAIT_();
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, area_no);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHG_MAP);                   /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      while(PEEK_W(adr_com_block + ADR_COM_DATA)) _WAIT_();
      HOST_SET_RETURN(SND_RET_SET);
  }
  /******************************************************************************
   *
!  * NAME:    SND_SetTlVl()   - ｿｽSｿｽﾌ会ｿｽｿｽﾊ設抵ｿｽ
   *
   * PARAMETERS :
!  *      (1) SndTlVl vol         - <i>   ｿｽSｿｽﾌ会ｿｽｿｽｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽSｿｽﾌ会ｿｽｿｽﾊゑｿｽｿｽﾝ定しｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
  
   SndRet SND_SetTlVl(SndTlVl vol)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, vol);                            /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_SET_TL_VL);                 /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgEfct()   - ｿｽGｿｽtｿｽFｿｽNｿｽgｿｽﾏ更
   *
   * PARAMETERS :
   *      (1) SndEfctBnkNum efct_no <i>   Effect bank number
   *
   * DESCRIPTION:
!  *      ｿｽGｿｽtｿｽFｿｽNｿｽgｿｽｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChgEfct(SndEfctBnkNum efct_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, efct_no);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHG_EFCT);                  /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgMix()    - ｿｽ~ｿｽLｿｽTｿｽﾏ更
   *
   * PARAMETERS :
!  *      (1) SndToneBnkNum tone_no   <i>   ｿｽｿｽｿｽF bank number
   *      (2) SndMixBnkNum mix_no     <i>   MIxer bank number
   *
   * DESCRIPTION:
!  *      ｿｽ~ｿｽLｿｽTｿｽｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChgMix(SndToneBnkNum tone_no, SndMixBnkNum mix_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, tone_no);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, mix_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHG_MIX);                   /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgMixPrm()     - ｿｽ~ｿｽLｿｽTｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽﾏ更
   *
   * PARAMETERS :
   *      (1) SndEfctOut efct_out     <i>   Effect out select
***************
*** 551,940 ****
   *      (3) SndPan pan              <i>   Effect pan
   *
   * DESCRIPTION:
!  *      ミキサパラメータを変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChgMixPrm(SndEfctOut efct_out, SndLev level, SndPan pan)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, efct_out);                       /* パラメータセット          */
!     SET_PRM(1, ChgPan(pan) | (level << 5));     /* パラメータセット          */
!     SET_COMMAND(COM_CHG_MIX_PRM);               /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChkHard()       - ハードウェアチェック
   *
   * PARAMETERS :
!  *      (1) SndHardStat *stat       <o>   ﾊｰﾄﾞﾁｪｯｸｽﾃｰﾀｽ
!  *      (2) SndHardPrm prm         <i>   ﾊｰﾄﾞﾁｪｯｸﾊﾟﾗﾒｰﾀ
   *
   * DESCRIPTION:
!  *      ハードウェアをチェックします。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChkHard(SndHardStat *stat, SndHardPrm prm)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
      *(Uint16 *)(ADR_SYS_TBL + ADR_HARD_CHK_STAT) = 0;
!     SET_PRM(0, prm);                            /* パラメータセット          */
!     SET_COMMAND(COM_CHK_HARD);                  /* コマンドセット            */
      while((*stat = *(volatile Uint16 *)(ADR_SYS_TBL + ADR_HARD_CHK_STAT)) == 0) _WAIT_();
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopDsp()   - DSP中止
   *
   * PARAMETERS :
!  *      なし。
   *
   * DESCRIPTION:
!  *      DSPを中止します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StopDsp(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_STOP_DSP);                  /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_OffAllSound()       - 全サウンド発音スロット停止
   *
   * PARAMETERS :
!  *      なし。
   *
   * DESCRIPTION:
!  *      全サウンド発音スロットを停止します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_OffAllSound(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_OFF_ALL_SOUND);             /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StartSeq()  - シーケンス開始
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no        -   <i>     発音管理番号
   *      (2) SndSeqBnkNum seq_bk_no  -   <i>     Sequence bank number
   *      (3) SndSeqSongNum song_no   -   <i>     Sequence song number
   *      (4) SndSeqPri pri_lev       -   <i>     Priorty level
   *
   * DESCRIPTION:
!  *      シーケンスを開始します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StartSeq(SndSeqNum seq_no, SndSeqBnkNum seq_bk_no,
                      SndSeqSongNum song_no, SndSeqPri pri_lev)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_PRM(1, seq_bk_no);                      /* パラメータセット          */
!     SET_PRM(2, song_no);                        /* パラメータセット          */
!     SET_PRM(3, pri_lev);                        /* パラメータセット          */
!     SET_COMMAND(COM_START_SEQ);                 /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopSeq()   - シーケンス中止
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   発音管理番号
   *
   * DESCRIPTION:
!  *      シーケンスを中止します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StopSeq(SndSeqNum seq_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_COMMAND(COM_STOP_SEQ);                  /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_PauseSeq()  - シーケンス一時中断
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   発音管理番号
   *
   * DESCRIPTION:
!  *      シーケンスを一時中断します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_PauseSeq(SndSeqNum seq_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_COMMAND(COM_PAUSE_SEQ);                 /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ContSeq()   - シーケンス一時中断解除
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   発音管理番号
   *
   * DESCRIPTION:
!  *      シーケンスの一時中断を解除します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ContSeq(SndSeqNum seq_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_COMMAND(COM_CONT_SEQ);                  /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetSeqVl()      - シーケンス音量設定
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no        -   <i>     発音管理番号
   *      (2) SndSeqVl seq_vl         -   <i>     Sequence Volume
   *      (3) SndFade fade            -   <i>     fade Rate
   *
   * DESCRIPTION:
!  *      シーケンスの音量を設定します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_SetSeqVl(SndSeqNum seq_no, SndSeqVl seq_vl, SndFade fade)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_PRM(1, seq_vl);                         /* パラメータセット          */
!     SET_PRM(2, fade);                           /* パラメータセット          */
!     SET_COMMAND(COM_SET_SEQ_VL);                /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgTempo()  - テンポ変更
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   発音管理番号
   *      (2) SndTempo tempo      - <i>   Tempo
   *
   * DESCRIPTION:
!  *      シーケンスのテンポを変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChgTempo(SndSeqNum seq_no, SndTempo tempo)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_PRM(2, tempo >> 8);                     /* パラメータセット          */
!     SET_PRM(3, tempo);                          /* パラメータセット          */
!     SET_COMMAND(COM_CHG_TEMPO);                 /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_CtrlDirMidi()   -   MIDIダイレクトコントロール
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   発音管理番号
   *      (2) SndSeqPri seq_pri   - <i>   Priorty Level
   *      (3) Uint8 md_com        - <i>   MIDI command
   *      (4) Uint8 ch            - <i>   MIDI channel
--- 552,941 ----
   *      (3) SndPan pan              <i>   Effect pan
   *
   * DESCRIPTION:
!  *      ｿｽ~ｿｽLｿｽTｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChgMixPrm(SndEfctOut efct_out, SndLev level, SndPan pan)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, efct_out);                       /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, ChgPan(pan) | (level << 5));     /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHG_MIX_PRM);               /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChkHard()       - ｿｽnｿｽ[ｿｽhｿｽEｿｽFｿｽAｿｽ`ｿｽFｿｽbｿｽN
   *
   * PARAMETERS :
!  *      (1) SndHardStat *stat       <o>   ﾊｰｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾃｰｿｽｿｽ
!  *      (2) SndHardPrm prm         <i>   ﾊｰｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾒｰｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽnｿｽ[ｿｽhｿｽEｿｽFｿｽAｿｽｿｽｿｽ`ｿｽFｿｽbｿｽNｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChkHard(SndHardStat *stat, SndHardPrm prm)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
      *(Uint16 *)(ADR_SYS_TBL + ADR_HARD_CHK_STAT) = 0;
!     SET_PRM(0, prm);                            /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHK_HARD);                  /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      while((*stat = *(volatile Uint16 *)(ADR_SYS_TBL + ADR_HARD_CHK_STAT)) == 0) _WAIT_();
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopDsp()   - DSPｿｽｿｽｿｽ~
   *
   * PARAMETERS :
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * DESCRIPTION:
!  *      DSPｿｽ中止ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StopDsp(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_STOP_DSP);                  /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_OffAllSound()       - ｿｽSｿｽTｿｽEｿｽｿｽｿｽhｿｽｿｽｿｽｿｽｿｽXｿｽｿｽｿｽbｿｽgｿｽｿｽｿｽ~
   *
   * PARAMETERS :
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * DESCRIPTION:
!  *      ｿｽSｿｽTｿｽEｿｽｿｽｿｽhｿｽｿｽｿｽｿｽｿｽXｿｽｿｽｿｽbｿｽgｿｽｿｽｿｽｿｽｿｽ~ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_OffAllSound(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_OFF_ALL_SOUND);             /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StartSeq()  - ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽJｿｽn
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no        -   <i>     ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *      (2) SndSeqBnkNum seq_bk_no  -   <i>     Sequence bank number
   *      (3) SndSeqSongNum song_no   -   <i>     Sequence song number
   *      (4) SndSeqPri pri_lev       -   <i>     Priorty level
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽｿｽｿｽJｿｽnｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StartSeq(SndSeqNum seq_no, SndSeqBnkNum seq_bk_no,
                      SndSeqSongNum song_no, SndSeqPri pri_lev)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, seq_bk_no);                      /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(2, song_no);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(3, pri_lev);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_START_SEQ);                 /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopSeq()   - ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽｿｽｿｽ~
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽ中止ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StopSeq(SndSeqNum seq_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_STOP_SEQ);                  /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_PauseSeq()  - ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽ齊橸ｿｽｿｽｿｽf
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽｿｽｿｽ齊橸ｿｽｿｽｿｽfｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_PauseSeq(SndSeqNum seq_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_PAUSE_SEQ);                 /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ContSeq()   - ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽ齊橸ｿｽｿｽｿｽfｿｽｿｽｿｽｿｽ
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽﾌ一時ｿｽｿｽｿｽfｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ContSeq(SndSeqNum seq_no)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CONT_SEQ);                  /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetSeqVl()      - ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽｿｽｿｽﾊ設抵ｿｽ
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no        -   <i>     ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *      (2) SndSeqVl seq_vl         -   <i>     Sequence Volume
   *      (3) SndFade fade            -   <i>     fade Rate
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽﾌ会ｿｽｿｽﾊゑｿｽｿｽﾝ定しｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_SetSeqVl(SndSeqNum seq_no, SndSeqVl seq_vl, SndFade fade)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, seq_vl);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(2, fade);                           /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_SET_SEQ_VL);                /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgTempo()  - ｿｽeｿｽｿｽｿｽ|ｿｽﾏ更
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *      (2) SndTempo tempo      - <i>   Tempo
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽﾌテｿｽｿｽｿｽ|ｿｽｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChgTempo(SndSeqNum seq_no, SndTempo tempo)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(2, tempo >> 8);                     /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(3, tempo);                          /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CHG_TEMPO);                 /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_CtrlDirMidi()   -   MIDIｿｽ_ｿｽCｿｽｿｽｿｽNｿｽgｿｽRｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽ
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *      (2) SndSeqPri seq_pri   - <i>   Priorty Level
   *      (3) Uint8 md_com        - <i>   MIDI command
   *      (4) Uint8 ch            - <i>   MIDI channel
***************
*** 942,1048 ****
   *      (6) Uint8 dt2           - <i>   MIDI data2
   *
   * DESCRIPTION:
!  *      MIDIをダイレクトにコントロールします。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_CtrlDirMidi(SndSeqNum seq_no, SndSeqPri seq_pri, Uint8 md_com,
                          Uint8 ch, Uint8 dt1, Uint8 dt2)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, (seq_pri << 3) | md_com);        /* パラメータセット          */
!     SET_PRM(1, (seq_no << 5) | ch);             /* パラメータセット          */
!     SET_PRM(2, dt1);                            /* パラメータセット          */
!     SET_PRM(3, dt2);                            /* パラメータセット          */
!     SET_COMMAND(COM_CTRL_DIR_MIDI);             /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetSeqPan()     -   シーケンスPAN設定
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   発音管理番号
   *      (2) Uint8 ctrl_sw       - <i>   Control ON/OFF
   *      (3) Uint8 md_pan        - <i>   MIDI PAN data
   *
   * DESCRIPTION:
!  *      シーケンスPANを設定します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_SetSeqPan(SndSeqNum seq_no, Uint8 ctrl_sw, Uint8 md_pan)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* パラメータセット          */
!     SET_PRM(1, (ctrl_sw | md_pan));             /* パラメータセット          */
!     SET_COMMAND(COM_SET_SEQ_PAN);             /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StartPcm()  - PCM開始
   *
   * PARAMETERS :
!  *      (1) SndPcmStartPrm *sprm    - <i>   PCM開始パラメータポインタ
!  *      (2) SndPcmChgPrm *cprm      - <i>   PCM変更パラメータポインタ
   *
   * DESCRIPTION:
!  *      PCMデータを再生します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StartPcm(SndPcmStartPrm *sprm, SndPcmChgPrm *cprm)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
--- 943,1049 ----
   *      (6) Uint8 dt2           - <i>   MIDI data2
   *
   * DESCRIPTION:
!  *      MIDIｿｽｿｽｿｽ_ｿｽCｿｽｿｽｿｽNｿｽgｿｽﾉコｿｽｿｽｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_CtrlDirMidi(SndSeqNum seq_no, SndSeqPri seq_pri, Uint8 md_com,
                          Uint8 ch, Uint8 dt1, Uint8 dt2)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, (seq_pri << 3) | md_com);        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, (seq_no << 5) | ch);             /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(2, dt1);                            /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(3, dt2);                            /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_CTRL_DIR_MIDI);             /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetSeqPan()     -   ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXPANｿｽﾝ抵ｿｽ
   *
   * PARAMETERS :
!  *      (1) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *      (2) Uint8 ctrl_sw       - <i>   Control ON/OFF
   *      (3) Uint8 md_pan        - <i>   MIDI PAN data
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXPANｿｽｿｽｿｽﾝ定しｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_SetSeqPan(SndSeqNum seq_no, Uint8 ctrl_sw, Uint8 md_pan)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, seq_no);                         /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, (ctrl_sw | md_pan));             /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_SET_SEQ_PAN);             /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StartPcm()  - PCMｿｽJｿｽn
   *
   * PARAMETERS :
!  *      (1) SndPcmStartPrm *sprm    - <i>   PCMｿｽJｿｽnｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽ|ｿｽCｿｽｿｽｿｽ^
!  *      (2) SndPcmChgPrm *cprm      - <i>   PCMｿｽﾏ更ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽ|ｿｽCｿｽｿｽｿｽ^
   *
   * DESCRIPTION:
!  *      PCMｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽﾄ撰ｿｽｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StartPcm(SndPcmStartPrm *sprm, SndPcmChgPrm *cprm)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
***************
*** 1059,1132 ****
      SET_PRM(8, (SND_R_EFCT_IN(*cprm) << 3) | SND_R_EFCT_LEV(*cprm));
      SET_PRM(9, (SND_L_EFCT_IN(*cprm) << 3) | SND_L_EFCT_LEV(*cprm));
      SET_PRM(11, 0);
!     SET_COMMAND(COM_START_PCM);                 /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopPcm()   - PCM中止
   *
   * PARAMETERS :
!  *      (1) SndPcmNum pcm_num       - <i>   再生停止PCMストリーム再生番号
   *
   * DESCRIPTION:
!  *      PCMを中止します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StopPcm(SndPcmNum pcm_num)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, pcm_num);                        /* パラメータセット          */
!     SET_COMMAND(COM_STOP_PCM);                  /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgPcm()    - PCM変更
   *
   * PARAMETERS :
!  *      (1) SndPcmChgPrm *cprm      - <i>   PCM変更パラメータポインタ
   *
   * DESCRIPTION:
!  *      PCMデータを再生します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_ChgPcm(SndPcmChgPrm *cprm)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
--- 1060,1133 ----
      SET_PRM(8, (SND_R_EFCT_IN(*cprm) << 3) | SND_R_EFCT_LEV(*cprm));
      SET_PRM(9, (SND_L_EFCT_IN(*cprm) << 3) | SND_L_EFCT_LEV(*cprm));
      SET_PRM(11, 0);
!     SET_COMMAND(COM_START_PCM);                 /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopPcm()   - PCMｿｽｿｽｿｽ~
   *
   * PARAMETERS :
!  *      (1) SndPcmNum pcm_num       - <i>   ｿｽﾄ撰ｿｽｿｽｿｽｿｽ~PCMｿｽXｿｽgｿｽｿｽｿｽ[ｿｽｿｽｿｽﾄ撰ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      PCMｿｽ中止ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StopPcm(SndPcmNum pcm_num)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, pcm_num);                        /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_STOP_PCM);                  /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_ChgPcm()    - PCMｿｽﾏ更
   *
   * PARAMETERS :
!  *      (1) SndPcmChgPrm *cprm      - <i>   PCMｿｽﾏ更ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽ|ｿｽCｿｽｿｽｿｽ^
   *
   * DESCRIPTION:
!  *      PCMｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽﾄ撰ｿｽｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_ChgPcm(SndPcmChgPrm *cprm)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
***************
*** 1138,1321 ****
      SET_PRM(3, SND_PRM_PICH(*cprm));
      SET_PRM(4, (SND_R_EFCT_IN(*cprm) << 3) | SND_R_EFCT_LEV(*cprm));
      SET_PRM(5, (SND_L_EFCT_IN(*cprm) << 3) | SND_L_EFCT_LEV(*cprm));
!     SET_COMMAND(COM_CHG_PCM_PRM);               /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StartVlAnl()    - 音量解析開始
   *
   * PARAMETERS :
!  *      なし。
   *
   * DESCRIPTION:
!  *      音量解析を行います。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      周波数帯域別音量解析をする場合は、エフェクト変更にて専用のDSPプログラ
!  *      ムを実行してください。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StartVlAnl(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_START_VL_ANL);              /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopVlAnl()     - 音量解析中止
   *
   * PARAMETERS :
!  *      なし。
   *
   * DESCRIPTION:
!  *      音量解析を中止します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_StopVlAnl(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_STOP_VL_ANL);               /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetCdDaLev()    - CD-DA Level設定
   *
   * PARAMETERS :
!  *      (1) SndLev left         - <i>   左出力の音量
!  *      (2) SndLev right        - <i>   右出力の音量
   *
   * DESCRIPTION:
!  *      現在のステレオ音量を変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_SetCdDaLev(SndLev left, SndLev right)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, (left) * 2 << 4);                /* パラメータセット          */
!     SET_PRM(1, (right) * 2 << 4);               /* パラメータセット          */
!     SET_COMMAND(COM_SET_CD_DA_LEV);             /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetCdDaPan()    - CD-DA Pan設定
   *
   * PARAMETERS :
!  *      (1) SndPan  left        - <i>   左出力のPAN
!  *      (2) SndPan  right       - <i>   右出力のPAN
   *
   * DESCRIPTION:
!  *      現在のステレオPANを変更します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   コマンド実行状態
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   SndRet SND_SetCdDaPan(SndPan left, SndPan right)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲﾝﾀﾌｪｰｽｴﾘｱ設定初期処理 */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, ChgPan(left));                   /* パラメータセット          */
!     SET_PRM(1, ChgPan(right));                  /* パラメータセット          */
!     SET_COMMAND(COM_SET_CD_DA_PAN);             /* コマンドセット            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_GetSeqStat()    - シーケンスステータス取得
   *
   * PARAMETERS :
!  *      (1) SndSeqStat *status  - <o>   シーケンスステータスポインタ
!  *      (2) SndSeqNum seq_no    - <i>   発音管理番号
   *
   * DESCRIPTION:
!  *      シーケンスステータスを取得します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし。
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   void SND_GetSeqStat(SndSeqStat *status, SndSeqNum seq_no)
   {
      SND_SEQ_STAT_MODE(*status) = (PEEK_W(adr_song_stat + seq_no)) & 0xff00;
--- 1139,1322 ----
      SET_PRM(3, SND_PRM_PICH(*cprm));
      SET_PRM(4, (SND_R_EFCT_IN(*cprm) << 3) | SND_R_EFCT_LEV(*cprm));
      SET_PRM(5, (SND_L_EFCT_IN(*cprm) << 3) | SND_L_EFCT_LEV(*cprm));
!     SET_COMMAND(COM_CHG_PCM_PRM);               /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StartVlAnl()    - ｿｽｿｽｿｽﾊ会ｿｽｿｽﾍ開ｿｽn
   *
   * PARAMETERS :
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * DESCRIPTION:
!  *      ｿｽｿｽｿｽﾊ会ｿｽｿｽﾍゑｿｽｿｽsｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽｿｽｿｽgｿｽｿｽｿｽﾑ茨ｿｽｿｽﾊ会ｿｽｿｽﾊ会ｿｽｿｽﾍゑｿｽｿｽｿｽｿｽｿｽｿｽ鼾ｿｽﾍ、ｿｽGｿｽtｿｽFｿｽNｿｽgｿｽﾏ更ｿｽﾉて撰ｿｽｿｽpｿｽｿｽDSPｿｽvｿｽｿｽｿｽOｿｽｿｽ
!  *      ｿｽｿｽｿｽｿｽｿｽｿｽｿｽsｿｽｿｽｿｽﾄゑｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StartVlAnl(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_START_VL_ANL);              /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_StopVlAnl()     - ｿｽｿｽｿｽﾊ会ｿｽｿｽﾍ抵ｿｽｿｽ~
   *
   * PARAMETERS :
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * DESCRIPTION:
!  *      ｿｽｿｽｿｽﾊ会ｿｽｿｽﾍを中止ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_StopVlAnl(void)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_COMMAND(COM_STOP_VL_ANL);               /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetCdDaLev()    - CD-DA Levelｿｽﾝ抵ｿｽ
   *
   * PARAMETERS :
!  *      (1) SndLev left         - <i>   ｿｽｿｽｿｽoｿｽﾍの会ｿｽｿｽｿｽ
!  *      (2) SndLev right        - <i>   ｿｽEｿｽoｿｽﾍの会ｿｽｿｽｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽｿｽｿｽﾝのスｿｽeｿｽｿｽｿｽIｿｽｿｽｿｽﾊゑｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_SetCdDaLev(SndLev left, SndLev right)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, (left) * 2 << 4);                /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, (right) * 2 << 4);               /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_SET_CD_DA_LEV);             /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_SetCdDaPan()    - CD-DA Panｿｽﾝ抵ｿｽ
   *
   * PARAMETERS :
!  *      (1) SndPan  left        - <i>   ｿｽｿｽｿｽoｿｽﾍゑｿｽPAN
!  *      (2) SndPan  right       - <i>   ｿｽEｿｽoｿｽﾍゑｿｽPAN
   *
   * DESCRIPTION:
!  *      ｿｽｿｽｿｽﾝのスｿｽeｿｽｿｽｿｽIPANｿｽｿｽｿｽﾏ更ｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      (1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   SndRet SND_SetCdDaPan(SndPan left, SndPan right)
   {
  /* 1994/02/24 Start */
  #if 0
!     HOST_SET_INIT();                            /* ﾎｽﾄｲｿｽｿｽﾌｪｿｽｿｽｿｽﾘｱｿｽﾝ定初ｿｽｿｽｿｽｿｽｿｽｿｽ */
  #endif
      if(intrflag) return(SND_RET_NSET);
      intrflag = 1;
  /* 1994/02/24 End */
      if(GetComBlockAdr() == OFF) HOST_SET_RETURN(SND_RET_NSET);
!     SET_PRM(0, ChgPan(left));                   /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_PRM(1, ChgPan(right));                  /* ｿｽpｿｽｿｽｿｽｿｽｿｽ[ｿｽ^ｿｽZｿｽbｿｽg          */
!     SET_COMMAND(COM_SET_CD_DA_PAN);             /* ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽZｿｽbｿｽg            */
      HOST_SET_RETURN(SND_RET_SET);
  }
  
  /******************************************************************************
   *
!  * NAME:    SND_GetSeqStat()    - ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽXｿｽeｿｽ[ｿｽ^ｿｽXｿｽ謫ｾ
   *
   * PARAMETERS :
!  *      (1) SndSeqStat *status  - <o>   ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽXｿｽeｿｽ[ｿｽ^ｿｽXｿｽ|ｿｽCｿｽｿｽｿｽ^
!  *      (2) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽVｿｽ[ｿｽPｿｽｿｽｿｽXｿｽXｿｽeｿｽ[ｿｽ^ｿｽXｿｽｿｽｿｽ謫ｾｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   void SND_GetSeqStat(SndSeqStat *status, SndSeqNum seq_no)
   {
      SND_SEQ_STAT_MODE(*status) = (PEEK_W(adr_song_stat + seq_no)) & 0xff00;
***************
*** 1324,1350 ****
  
  /******************************************************************************
   *
!  * NAME:    SND_GetSeqPlayPos() - 発音管理番号再生位置取得
   *
   * PARAMETERS :
!  *      (1) SndSeqPlayPos *pos  - <o>   発音管理番号再生位置
!  *      (2) SndSeqNum seq_no    - <i>   発音管理番号
   *
   * DESCRIPTION:
!  *      発音管理番号再生位置を取得します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし。
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   void SND_GetSeqPlayPos(SndSeqPlayPos *pos, SndSeqNum seq_no)
   {
      *pos = PEEK_W(adr_seq + seq_no);
--- 1325,1351 ----
  
  /******************************************************************************
   *
!  * NAME:    SND_GetSeqPlayPos() - ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽｿｽﾄ撰ｿｽｿｽﾊ置ｿｽ謫ｾ
   *
   * PARAMETERS :
!  *      (1) SndSeqPlayPos *pos  - <o>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽｿｽﾄ撰ｿｽｿｽﾊ置
!  *      (2) SndSeqNum seq_no    - <i>   ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽｿｽｿｽｿｽｿｽﾇ暦ｿｽｿｽﾔ搾ｿｽｿｽﾄ撰ｿｽｿｽﾊ置ｿｽｿｽｿｽ謫ｾｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   void SND_GetSeqPlayPos(SndSeqPlayPos *pos, SndSeqNum seq_no)
   {
      *pos = PEEK_W(adr_seq + seq_no);
***************
*** 1352,1378 ****
  
  /******************************************************************************
   *
!  * NAME:    SND_GetPcmPlayAdr() - PCM実行アドレス取得
   *
   * PARAMETERS :
!  *      (1) SndPcmPlayAdr *pcm_adr  - <o>   PCM実行アドレス
!  *      (2) SndPcmNum num           - <i>   PCM再生番号
   *
   * DESCRIPTION:
!  *      PCM実行アドレスを取得します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし。
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   void SND_GetPcmPlayAdr(SndPcmPlayAdr *pcm_adr, SndPcmNum num)
   {
      SND_PCM_RADR(*pcm_adr) = (Uint8)(PEEK_W(adr_pcm + num) >> 8);
--- 1353,1379 ----
  
  /******************************************************************************
   *
!  * NAME:    SND_GetPcmPlayAdr() - PCMｿｽｿｽｿｽsｿｽAｿｽhｿｽｿｽｿｽXｿｽ謫ｾ
   *
   * PARAMETERS :
!  *      (1) SndPcmPlayAdr *pcm_adr  - <o>   PCMｿｽｿｽｿｽsｿｽAｿｽhｿｽｿｽｿｽX
!  *      (2) SndPcmNum num           - <i>   PCMｿｽﾄ撰ｿｽｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      PCMｿｽｿｽｿｽsｿｽAｿｽhｿｽｿｽｿｽXｿｽｿｽｿｽ謫ｾｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   void SND_GetPcmPlayAdr(SndPcmPlayAdr *pcm_adr, SndPcmNum num)
   {
      SND_PCM_RADR(*pcm_adr) = (Uint8)(PEEK_W(adr_pcm + num) >> 8);
***************
*** 1381,1407 ****
  
  /******************************************************************************
   *
!  * NAME:    SND_GetAnlTlVl()    - 解析全体ステレオ音量取得
   *
   * PARAMETERS :
!  *      (1) SndCdVlAnl *left    - <o>   左出力の全体解析音量
!  *      (2) SndCdVlAnl *right   - <o>   右出力の全体解析音量
   *
   * DESCRIPTION:
!  *      全体ステレオ解析音量を取得します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   void SND_GetAnlTlVl(SndCdVlAnl *left, SndCdVlAnl *right)
   {
      *left = (SndCdVlAnl)PEEK_W(adr_tl_vl);
--- 1382,1408 ----
  
  /******************************************************************************
   *
!  * NAME:    SND_GetAnlTlVl()    - ｿｽｿｽｿｽﾍ全ｿｽﾌスｿｽeｿｽｿｽｿｽIｿｽｿｽｿｽﾊ取得
   *
   * PARAMETERS :
!  *      (1) SndCdVlAnl *left    - <o>   ｿｽｿｽｿｽoｿｽﾍの全ｿｽﾌ会ｿｽｿｽﾍ会ｿｽｿｽｿｽ
!  *      (2) SndCdVlAnl *right   - <o>   ｿｽEｿｽoｿｽﾍの全ｿｽﾌ会ｿｽｿｽﾍ会ｿｽｿｽｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽSｿｽﾌスｿｽeｿｽｿｽｿｽIｿｽｿｽｿｽﾍ会ｿｽｿｽﾊゑｿｽｿｽ謫ｾｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   void SND_GetAnlTlVl(SndCdVlAnl *left, SndCdVlAnl *right)
   {
      *left = (SndCdVlAnl)PEEK_W(adr_tl_vl);
***************
*** 1410,1435 ****
  
  /******************************************************************************
   *
!  * NAME:    SND_GetAnlHzVl()    - 解析周波数帯域別ステレオ音量取得
   *
   * PARAMETERS :
!  *      (1) SndCdHzSrVl *hz_vl - <o>   周波数帯域別ステレオ解析音量
   *
   * DESCRIPTION:
!  *      周波数帯域別ステレオ解析音量を取得します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
!  
   void SND_GetAnlHzVl(SndCdHzSrVl *hz_vl)
   {
      SND_CD_LHIGH(*hz_vl) = (SndCdVlAnl)PEEK_W(adr_tl_hz_vl + 0);
--- 1411,1436 ----
  
  /******************************************************************************
   *
!  * NAME:    SND_GetAnlHzVl()    - ｿｽｿｽｿｽﾍ趣ｿｽｿｽgｿｽｿｽｿｽﾑ茨ｿｽｿｽﾊスｿｽeｿｽｿｽｿｽIｿｽｿｽｿｽﾊ取得
   *
   * PARAMETERS :
!  *      (1) SndCdHzSrVl *hz_vl - <o>   ｿｽｿｽｿｽgｿｽｿｽｿｽﾑ茨ｿｽｿｽﾊスｿｽeｿｽｿｽｿｽIｿｽｿｽｿｽﾍ会ｿｽｿｽｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽｿｽｿｽgｿｽｿｽｿｽﾑ茨ｿｽｿｽﾊスｿｽeｿｽｿｽｿｽIｿｽｿｽｿｽﾍ会ｿｽｿｽﾊゑｿｽｿｽ謫ｾｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
! 
   void SND_GetAnlHzVl(SndCdHzSrVl *hz_vl)
   {
      SND_CD_LHIGH(*hz_vl) = (SndCdVlAnl)PEEK_W(adr_tl_hz_vl + 0);
***************
*** 1441,1467 ****
   }
  
  /*****************************************************************************/
! /**** 内部提供関数 ***********************************************************/
  /*****************************************************************************/
  /******************************************************************************
   *
!  * NAME:    DmaClrZero()    - DMAによるメモリのゼロクリア
   *
   * PARAMETERS :
!  *      (1) void *dst       - <i>   ディスティネーションアドレス
!  *      (2) Uint32 cnt      - <i>   クリアバイト数
   *
   * DESCRIPTION:
!  *      DMAを使用してメモリをゼロクリアします。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
--- 1442,1468 ----
   }
  
  /*****************************************************************************/
! /**** ｿｽｿｽｿｽｿｽｿｽ供関撰ｿｽ ***********************************************************/
  /*****************************************************************************/
  /******************************************************************************
   *
!  * NAME:    DmaClrZero()    - DMAｿｽﾉゑｿｽｿｽ驛ｿｽｿｽｿｽｿｽｿｽﾌゼｿｽｿｽｿｽNｿｽｿｽｿｽA
   *
   * PARAMETERS :
!  *      (1) void *dst       - <i>   ｿｽfｿｽBｿｽXｿｽeｿｽBｿｽlｿｽ[ｿｽVｿｽｿｽｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽX
!  *      (2) Uint32 cnt      - <i>   ｿｽNｿｽｿｽｿｽAｿｽoｿｽCｿｽgｿｽｿｽ
   *
   * DESCRIPTION:
!  *      DMAｿｽｿｽｿｽgｿｽpｿｽｿｽｿｽﾄｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽｿｽｿｽNｿｽｿｽｿｽAｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
***************
*** 1473,1497 ****
  
  /******************************************************************************
   *
!  * NAME:    GetSndMapInfo()     - サウンドエリアマップ情報取得
   *
   * PARAMETERS :
!  *      (1) void **adr          - <o>   転送先アドレス
!  *      (2) Uint32 **ladr        - <o>   転送済みビットアドレス
!  *      (3) Uint16 data_kind    - <i>   データ種別
!  *      (4) Uint16 data_no      - <i>   データ番号
   *
   * DESCRIPTION:
!  *      サウンドエリアマップの情報を取得します。
   *
   * PRECONDITIONS:
!  *      なし。
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
--- 1474,1498 ----
  
  /******************************************************************************
   *
!  * NAME:    GetSndMapInfo()     - ｿｽTｿｽEｿｽｿｽｿｽhｿｽGｿｽｿｽｿｽAｿｽ}ｿｽbｿｽvｿｽｿｽｿｽｿｽｿｽ謫ｾ
   *
   * PARAMETERS :
!  *      (1) void **adr          - <o>   ｿｽ]ｿｽｿｽｿｽｿｽｿｽAｿｽhｿｽｿｽｿｽX
!  *      (2) Uint32 **ladr        - <o>   ｿｽ]ｿｽｿｽｿｽﾏみビｿｽbｿｽgｿｽAｿｽhｿｽｿｽｿｽX
!  *      (3) Uint16 data_kind    - <i>   ｿｽfｿｽ[ｿｽ^ｿｽｿｽｿｽｿｽ
!  *      (4) Uint16 data_no      - <i>   ｿｽfｿｽ[ｿｽ^ｿｽﾔ搾ｿｽ
   *
   * DESCRIPTION:
!  *      ｿｽTｿｽEｿｽｿｽｿｽhｿｽGｿｽｿｽｿｽAｿｽ}ｿｽbｿｽvｿｽﾌ擾ｿｽｿｽｿｽｿｽｿｽｿｽ謫ｾｿｽｿｽｿｽﾜゑｿｽｿｽB
   *
   * PRECONDITIONS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
***************
*** 1518,1539 ****
  }
  /******************************************************************************
   *
!  * NAME:    ChgPan()            - PANデータ変換
   *
   * PARAMETERS :
   *      (1) SndPan pan          - <i>   PAN
   *
   * DESCRIPTION:
!  *      登録用のPANに変換します
   *
   * PRECONDITIONS:
!  *      (1) Uint16              - <o>   変換後PAN
   *
   * POSTCONDITIONS:
!  *      なし
   *
   * CAVEATS:
!  *      なし。
   *
   ******************************************************************************
   */
--- 1519,1540 ----
  }
  /******************************************************************************
   *
!  * NAME:    ChgPan()            - PANｿｽfｿｽ[ｿｽ^ｿｽﾏ奇ｿｽ
   *
   * PARAMETERS :
   *      (1) SndPan pan          - <i>   PAN
   *
   * DESCRIPTION:
!  *      ｿｽoｿｽ^ｿｽpｿｽｿｽPANｿｽﾉ変奇ｿｽｿｽｿｽｿｽﾜゑｿｽ
   *
   * PRECONDITIONS:
!  *      (1) Uint16              - <o>   ｿｽﾏ奇ｿｽｿｽｿｽPAN
   *
   * POSTCONDITIONS:
!  *      ｿｽﾈゑｿｽ
   *
   * CAVEATS:
!  *      ｿｽﾈゑｿｽｿｽB
   *
   ******************************************************************************
   */
***************
*** 1544,1550 ****
  
  /******************************************************************************
   *
!  * NAME:    CopyMem()           - メモリコピ−
   *
   * PARAMETERS :
   *
--- 1545,1551 ----
  
  /******************************************************************************
   *
!  * NAME:    CopyMem()           - ｿｽｿｽｿｽｿｽｿｽｿｽｿｽRｿｽsｿｽ|
   *
   * PARAMETERS :
   *
***************
*** 1572,1578 ****
  
  /******************************************************************************
   *
!  * NAME:    GetComBlockAdr()            - コマンドブロック
   *
   * PARAMETERS :
   *
--- 1573,1579 ----
  
  /******************************************************************************
   *
!  * NAME:    GetComBlockAdr()            - ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽuｿｽｿｽｿｽbｿｽN
   *
   * PARAMETERS :
   *
***************
*** 1581,1587 ****
   * PRECONDITIONS:
   *
   * POSTCONDITIONS:
!  *      (1) Uint8               - <ret> コマンドブロックの空き状態
   *
   * CAVEATS:
   *
--- 1582,1588 ----
   * PRECONDITIONS:
   *
   * POSTCONDITIONS:
!  *      (1) Uint8               - <ret> ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽuｿｽｿｽｿｽbｿｽNｿｽﾌ空き擾ｿｽｿｽｿｽ
   *
   * CAVEATS:
   *
***************
*** 1590,1621 ****
  
  static Uint8 GetComBlockAdr(void)
  {
!     if(*NOW_ADR_COM_DATA){              /* 以前のﾌﾞﾛｯｸが引き取り済みでないか?*/
!         /* 次コマンドブロックアドレス設定処理 ********************************/
          if(NOW_ADR_COM_DATA >= (MAX_ADR_COM_DATA - SIZE_COM_BLOCK)){
!                                                     /* 最大値か?            */
!             return OFF;                             /* ﾌﾞﾛｯｸ空き無し      */
          }else{
!             adr_com_block += SIZE_COM_BLOCK;        /* 現在ｺﾏﾝﾄﾞﾌﾞﾛｯｸｶｳﾝﾄｱｯﾌﾟ*/
              while(NOW_ADR_COM_DATA < (MAX_ADR_COM_DATA - SIZE_COM_BLOCK)){
                  if(*NOW_ADR_COM_DATA){
                      adr_com_block += SIZE_COM_BLOCK;
                  }else{
!                     return ON;                      /* ﾌﾞﾛｯｸ空き有り         */
                  }
              }
!             return OFF;                             /* ﾌﾞﾛｯｸ空き無し         */
          }
      }else{
!         adr_com_block = adr_host_int_work;  /* ﾌﾞﾛｯｸの先頭へ              */
          while(NOW_ADR_COM_DATA < (MAX_ADR_COM_DATA - SIZE_COM_BLOCK)){
              if(*NOW_ADR_COM_DATA){
                  adr_com_block += SIZE_COM_BLOCK;
              }else{
!                 return ON;                          /* ﾌﾞﾛｯｸ空き有り         */
              }
          }
!         return OFF;                                 /* ﾌﾞﾛｯｸ空き無し         */
      }
  }
  
--- 1591,1622 ----
  
  static Uint8 GetComBlockAdr(void)
  {
!     if(*NOW_ADR_COM_DATA){              /* ｿｽﾈ前ｿｽｿｽｿｽｿｽﾛｯｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽﾏみでなゑｿｽｿｽｿｽ?*/
!         /* ｿｽｿｽｿｽRｿｽ}ｿｽｿｽｿｽhｿｽuｿｽｿｽｿｽbｿｽNｿｽAｿｽhｿｽｿｽｿｽXｿｽﾝ定処ｿｽｿｽ ********************************/
          if(NOW_ADR_COM_DATA >= (MAX_ADR_COM_DATA - SIZE_COM_BLOCK)){
!                                                     /* ｿｽﾅ托ｿｽｿｽlｿｽｿｽ?            */
!             return OFF;                             /* ｿｽｿｽﾛｯｿｽｿｽき厄ｿｽｿｽｿｽ      */
          }else{
!             adr_com_block += SIZE_COM_BLOCK;        /* ｿｽｿｽｿｽﾝｺｿｽｿｽｿｽｿｽｿｽｿｽﾛｯｿｽｿｽｿｽｿｽﾄｱｿｽｿｽｿｽ*/
              while(NOW_ADR_COM_DATA < (MAX_ADR_COM_DATA - SIZE_COM_BLOCK)){
                  if(*NOW_ADR_COM_DATA){
                      adr_com_block += SIZE_COM_BLOCK;
                  }else{
!                     return ON;                      /* ｿｽｿｽﾛｯｿｽｿｽき有ｿｽｿｽ         */
                  }
              }
!             return OFF;                             /* ｿｽｿｽﾛｯｿｽｿｽき厄ｿｽｿｽｿｽ         */
          }
      }else{
!         adr_com_block = adr_host_int_work;  /* ｿｽｿｽﾛｯｿｽｿｽﾌ先頭ｿｽｿｽ              */
          while(NOW_ADR_COM_DATA < (MAX_ADR_COM_DATA - SIZE_COM_BLOCK)){
              if(*NOW_ADR_COM_DATA){
                  adr_com_block += SIZE_COM_BLOCK;
              }else{
!                 return ON;                          /* ｿｽｿｽﾛｯｿｽｿｽき有ｿｽｿｽ         */
              }
          }
!         return OFF;                                 /* ｿｽｿｽﾛｯｿｽｿｽき厄ｿｽｿｽｿｽ         */
      }
  }
  
***************
*** 1629,1635 ****
  	PRECONDITIONS:
  		None
  	POSTCONDITIONS:
! 		(1) SndRet              - <o>   コマンド実行状態
  	CAVEATS:
  		None
  ******************************************************************************/
--- 1630,1636 ----
  	PRECONDITIONS:
  		None
  	POSTCONDITIONS:
! 		(1) SndRet              - <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
  	CAVEATS:
  		None
  ******************************************************************************/
***************
*** 1659,1665 ****
  	PRECONDITIONS:
  		None
  	POSTCONDITIONS:
! 		(1) SndRet			- <o>   コマンド実行状態
  	CAVEATS:
  		None
  ******************************************************************************/
--- 1660,1666 ----
  	PRECONDITIONS:
  		None
  	POSTCONDITIONS:
! 		(1) SndRet			- <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
  	CAVEATS:
  		None
  ******************************************************************************/
***************
*** 1688,1694 ****
  	PRECONDITIONS:
  		None
  	POSTCONDITIONS:
! 		(1) SndRet			- <o>   コマンド実行状態
  	CAVEATS:
  		None
  ******************************************************************************/
--- 1689,1695 ----
  	PRECONDITIONS:
  		None
  	POSTCONDITIONS:
! 		(1) SndRet			- <o>   ｿｽRｿｽ}ｿｽｿｽｿｽhｿｽｿｽｿｽsｿｽｿｽｿｽｿｽ
  	CAVEATS:
  		None
  ******************************************************************************/
***************
*** 1705,1708 ****
  	HOST_SET_RETURN(SND_RET_SET);
  }
  
! 
\ No newline at end of file
--- 1706,1709 ----
  	HOST_SET_RETURN(SND_RET_SET);
  }
  
! 
diff -crBN --binary sbl6/segasmp/spr/smpspr2/smpspr20.c sbl6_patch/segasmp/spr/smpspr2/smpspr20.c
*** sbl6/segasmp/spr/smpspr2/smpspr20.c	1996-02-08 05:33:26.000000000 -0500
--- sbl6_patch/segasmp/spr/smpspr2/smpspr20.c	2023-01-08 10:00:00.000000000 -0500
***************
*** 20,29 ****
  
  #include	<stdio.h>
  #include	<stdlib.h>
  
  #define		_SPR2_
  #include        "sega_spr.h"
! #include        "sega_dbg.h"
  #include        "sega_per.h"
  
  #include	<machine.h>
--- 20,30 ----
  
  #include	<stdio.h>
  #include	<stdlib.h>
+ #include	<string.h>
  
  #define		_SPR2_
  #include        "sega_spr.h"
! //#include        "sega_dbg.h"
  #include        "sega_per.h"
  
  #include	<machine.h>
***************
*** 862,871 ****
  };
  
  
! void main()
  {
      Uint8  *VRAM;
      Uint16 *colAddr;
      int    asw;
      
      set_imask(0);
--- 863,873 ----
  };
  
  
! int main(void)
  {
      Uint8  *VRAM;
      Uint16 *colAddr;
+ 
      int    asw;
      
      set_imask(0);
***************
*** 888,893 ****
--- 890,896 ----
      SCL_DisplayFrame();
      SCL_DisplayFrame();
      colAddr = (Uint16*)SCL_AllocColRam(SCL_SPR,32,OFF);
+     (void)colAddr;
      SCL_SetColRam(SCL_SPR,0,32,colorData);
  
      SCL_SetDisplayMode(SCL_NON_INTER,SCL_240LINE,SCL_NORMAL_A);
***************
*** 984,990 ****
          }
          SCL_DisplayFrame();
      }
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 987,995 ----
          }
          SCL_DisplayFrame();
      }
+ 
+     return 0;
  }
  
  /*  end of file */
! 
diff -crBN --binary sbl6/segasmp/spr/smpspr7/smpspr70.c sbl6_patch/segasmp/spr/smpspr7/smpspr70.c
*** sbl6/segasmp/spr/smpspr7/smpspr70.c	2023-01-08 11:45:20.000000000 -0500
--- sbl6_patch/segasmp/spr/smpspr7/smpspr70.c	2023-01-08 11:46:24.000000000 -0500
***************
*** 93,104 ****
  static void initCluster(SprCluster *cluster);
  static void moveCluster(SprCluster *cluster);
  
! void main()		/* 95-7-26  +"void"  */
  {
! /* int     i, n;	95-7-26 unuse */
! XyInt	xy;
! MthXyz  mAngle, mPoint;
! Uint16 *colAddr;
  
  #if(SYSTEM_CLOCK == 28)
          SYS_CHGSYSCK(1);              /* システムクロックを２８Ｍに切替え  */
--- 93,104 ----
  static void initCluster(SprCluster *cluster);
  static void moveCluster(SprCluster *cluster);
  
! int main(void)		/* 95-7-26  +"void"  */
  {
! 	/* int     i, n;	95-7-26 unuse */
! 	XyInt	xy;
! 	MthXyz  mAngle, mPoint;
! 	Uint16 *colAddr;
  
  #if(SYSTEM_CLOCK == 28)
          SYS_CHGSYSCK(1);              /* システムクロックを２８Ｍに切替え  */
***************
*** 128,133 ****
--- 128,134 ----
          SCL_DisplayFrame();
  
          colAddr = (Uint16*)SCL_AllocColRam(SCL_SPR,48,OFF);
+         (void)colAddr;
          SCL_SetColRam(SCL_SPR,0,48,colorData);
  
  	SPR_3Initial(&work3D);		/* ３Ｄスプライト表示初期化 */
***************
*** 203,208 ****
--- 204,210 ----
  	    SCL_DisplayFrame();    /* Ｖ−ＢＬＡＮＫ割り込みを待ち、       */
  				     /* スプライト表示とスクロール動作を行う */
      }
+     return 0;
  }
  
  
diff -crBN --binary sbl6/segasmp/spr/smpspr8/smpspr80.c sbl6_patch/segasmp/spr/smpspr8/smpspr80.c
*** sbl6/segasmp/spr/smpspr8/smpspr80.c	1996-02-08 05:33:40.000000000 -0500
--- sbl6_patch/segasmp/spr/smpspr8/smpspr80.c	2023-01-04 21:05:08.000000000 -0500
***************
*** 258,264 ****
  
  
  /* main()		95-7-26  +"void"	*/
! void main()	 /*	95-7-26				*/
  {
  XyInt	xy;
  /* Uint16  timeCnt1, timeCnt2;	95-7-26 unuse	*/
--- 258,264 ----
  
  
  /* main()		95-7-26  +"void"	*/
! int main()	 /*	95-7-26				*/
  {
  XyInt	xy;
  /* Uint16  timeCnt1, timeCnt2;	95-7-26 unuse	*/
***************
*** 378,383 ****
--- 378,385 ----
  #endif
  
      }
+     
+     return 0;
  }
  
  
***************
*** 472,475 ****
  }
  
  /*  end of file */
! 
\ No newline at end of file
--- 474,477 ----
  }
  
  /*  end of file */
! 
diff -crBN --binary sbl6/segasmp/stm/smpstm1/smpstm1.c sbl6_patch/segasmp/stm/smpstm1/smpstm1.c
*** sbl6/segasmp/stm/smpstm1/smpstm1.c	2023-01-08 11:45:30.000000000 -0500
--- sbl6_patch/segasmp/stm/smpstm1/smpstm1.c	2023-01-08 13:38:38.000000000 -0500
***************
*** 142,151 ****
  void    SMP_ChkBuf(StmGrpHn grp, Sint32 nstm, StmHn stmtbl[], Sint32 rscnt[])
  {
      Sint32      i;
-     Sint32      lpcnt;
      Bool        bful;
  
!     lpcnt = STM_GetLoopCnt(grp);
  
      /* 読み込み領域がいっぱいになったらリセットする     */
      for (i = 0; i < nstm; i++) {
--- 142,150 ----
  void    SMP_ChkBuf(StmGrpHn grp, Sint32 nstm, StmHn stmtbl[], Sint32 rscnt[])
  {
      Sint32      i;
      Bool        bful;
  
!     STM_GetLoopCnt(grp);
  
      /* 読み込み領域がいっぱいになったらリセットする     */
      for (i = 0; i < nstm; i++) {
***************
*** 202,208 ****
  /*-------------------------------
   * メイン
   *-------------------------------*/
! void    main(void)
  {
      Bool        init;
      StmGrpHn    grp;
--- 201,207 ----
  /*-------------------------------
   * メイン
   *-------------------------------*/
! int    main(void)
  {
      Bool        init;
      StmGrpHn    grp;
***************
*** 211,239 ****
      /* 初期化           */
      init = SMP_Init();
      if (init == FALSE) {
!         return;
      }
  
      /* ハンドル取得     */
      grp = STM_OpenGrp();
      if (grp == NULL) {
!         return;
      }
!     stm1 = SMP_Open(grp, SMP_STM_FN1, Fn1_Buf, FN1_UNITNUM);
      if (stm1 == NULL) {
!         return;
      }
!     stm2 = SMP_Open(grp, SMP_STM_FN2, Fn2_Buf, FN2_UNITNUM);
      if (stm2 == NULL) {
!         return;
      }
!     stm3 = SMP_Open(grp, SMP_STM_FN3, Fn3_Buf, FN3_UNITNUM);
      if (stm3 == NULL) {
!         return;
      }
  
      /* 読み込み実行     */
      SMP_Exec(grp);
  }
  
  /* end of file */
--- 210,240 ----
      /* 初期化           */
      init = SMP_Init();
      if (init == FALSE) {
!         return 1;
      }
  
      /* ハンドル取得     */
      grp = STM_OpenGrp();
      if (grp == NULL) {
!         return 1;
      }
!     stm1 = SMP_Open(grp, (Sint8 *)SMP_STM_FN1, Fn1_Buf, FN1_UNITNUM);
      if (stm1 == NULL) {
!         return 1;
      }
!     stm2 = SMP_Open(grp, (Sint8 *)SMP_STM_FN2, Fn2_Buf, FN2_UNITNUM);
      if (stm2 == NULL) {
!         return 1;
      }
!     stm3 = SMP_Open(grp, (Sint8 *)SMP_STM_FN3, Fn3_Buf, FN3_UNITNUM);
      if (stm3 == NULL) {
!         return 1;
      }
  
      /* 読み込み実行     */
      SMP_Exec(grp);
+     
+     return 0;
  }
  
  /* end of file */
diff -crBN --binary sbl6/segasmp/stm/smpstm2/smpstm2.c sbl6_patch/segasmp/stm/smpstm2/smpstm2.c
*** sbl6/segasmp/stm/smpstm2/smpstm2.c	1996-02-08 05:33:48.000000000 -0500
--- sbl6_patch/segasmp/stm/smpstm2/smpstm2.c	2023-01-04 21:00:08.000000000 -0500
***************
*** 205,211 ****
  /*-------------------------------
   * メイン
   *-------------------------------*/
! void    main(void)
  {
      Bool        init;
      StmGrpHn    grp;
--- 205,211 ----
  /*-------------------------------
   * メイン
   *-------------------------------*/
! int    main(void)
  {
      Bool        init;
      StmGrpHn    grp;
***************
*** 213,229 ****
      /* 初期化           */
      init = SMP_Init();
      if (init == FALSE) {
!         return;
      }
  
      /* ハンドル取得     */
      grp = STM_OpenGrp();
      if (grp == NULL) {
!         return;
      }
  
      /* 読み込み実行     */
      SMP_Exec(grp);
  }
  
  
--- 213,231 ----
      /* 初期化           */
      init = SMP_Init();
      if (init == FALSE) {
!         return 1;
      }
  
      /* ハンドル取得     */
      grp = STM_OpenGrp();
      if (grp == NULL) {
!         return 1;
      }
  
      /* 読み込み実行     */
      SMP_Exec(grp);
+ 
+     return 0;
  }
  
  
diff -crBN --binary sbl6/segasmp/sys/smpsys.c sbl6_patch/segasmp/sys/smpsys.c
*** sbl6/segasmp/sys/smpsys.c	1996-02-08 05:33:54.000000000 -0500
--- sbl6_patch/segasmp/sys/smpsys.c	2023-01-04 20:59:40.000000000 -0500
***************
*** 126,132 ****
  #endif
  
  /* メイン処理 */
! void main(void)
  {
  	/* 注意：AUTO 変数をとると、APP_ENTRY のプログラムに */
          /*       制御が移るとき、スタックが若干無駄になる    */
--- 126,132 ----
  #endif
  
  /* メイン処理 */
! int main(void)
  {
  	/* 注意：AUTO 変数をとると、APP_ENTRY のプログラムに */
          /*       制御が移るとき、スタックが若干無駄になる    */
***************
*** 157,162 ****
--- 157,164 ----
  	SYS_SETUINT(VBO_NUM, (void(*)())0 ); /*   再初期化   */
  
  	((void(*)())APP_ENTRY)();    /* 次の実行開始アドレス */
+ 	
+ 	return 0;
  }
  
  #ifndef __GNUC__
***************
*** 344,349 ****
--- 346,352 ----
  	MSH2_DMAC_DMAOR = 0x00000000;
                                          /* ＤＩＶＵ割込みを不許可      */
  	MSH2_DIVU_CONT =  0x00000000;
+ 	(void)dummy;
  }
  
  static void scuDspInit(void)
***************
*** 367,370 ****
  					      /* サウンドＤＳＰ       */
  }					      /* プログラム領域クリア */
  
! 
\ No newline at end of file
--- 370,373 ----
  					      /* サウンドＤＳＰ       */
  }					      /* プログラム領域クリア */
  
! 
diff -crBN --binary sbl6/segasmp/tim/smp0/smptim0.c sbl6_patch/segasmp/tim/smp0/smptim0.c
*** sbl6/segasmp/tim/smp0/smptim0.c	1996-02-08 05:33:58.000000000 -0500
--- sbl6_patch/segasmp/tim/smp0/smptim0.c	2023-01-04 20:39:14.000000000 -0500
***************
*** 81,87 ****
   ******************************************************************************
   */
  
! void main(void)
  {
  
      /** BEGIN ****************************************************************/
--- 81,87 ----
   ******************************************************************************
   */
  
! int main(void)
  {
  
      /** BEGIN ****************************************************************/
***************
*** 98,104 ****
--- 98,107 ----
      TIM_T1_SET_MODE(0x101);
      TIM_T1_ENABLE();
      TIM_T0_ENABLE();
+     
+     return 0;
  }
+ 
  void Time0Int(void)
  {
      static Uint32 time0 = 1;
***************
*** 112,115 ****
      *(Uint32 *)0x6050010 = time1;
      time1 ++;
  }
! 
\ No newline at end of file
--- 115,118 ----
      *(Uint32 *)0x6050010 = time1;
      time1 ++;
  }
! 
diff -crBN --binary sbl6/segasmp/tim/smp1/smptim1.c sbl6_patch/segasmp/tim/smp1/smptim1.c
*** sbl6/segasmp/tim/smp1/smptim1.c	1996-02-08 05:34:00.000000000 -0500
--- sbl6_patch/segasmp/tim/smp1/smptim1.c	2023-01-04 20:46:36.000000000 -0500
***************
*** 79,85 ****
   */
  void Time0Int(void);
  
! void main(void)
  {
  
      Sint8 *buf = (Sint8 *)0x6050010;
--- 79,85 ----
   */
  void Time0Int(void);
  
! int main(void)
  {
  
      Sint8 *buf = (Sint8 *)0x6050010;
***************
*** 102,116 ****
  
      TIM_FRT_DELAY_16(20);
      *(Uint32 *)0x6050000 = TIM_FRT_GET_16();
!     sprintf(buf, "get = %ld",*(Uint32 *)0x6050000);
!     buf += strlen(buf);
      
      *(Float32 *)0x6050004 = TIM_FRT_CNT_TO_MCR(*(Uint32 *)0x6050000);
!     sprintf(buf, "get = %f",*(Float32 *)0x6050004);
!     buf += strlen(buf);
      
      *(Float32 *)0x6050008 = TIM_FRT_MCR_TO_CNT(*(Float32 *)0x6050004);
!     sprintf(buf, "get = %f",*(Float32 *)0x6050008);
!     buf += strlen(buf);
  }
! 
\ No newline at end of file
--- 102,118 ----
  
      TIM_FRT_DELAY_16(20);
      *(Uint32 *)0x6050000 = TIM_FRT_GET_16();
!     sprintf((char *)buf, "get = %ld",*(Uint32 *)0x6050000);
!     buf += strlen((char *)buf);
      
      *(Float32 *)0x6050004 = TIM_FRT_CNT_TO_MCR(*(Uint32 *)0x6050000);
!     sprintf((char *)buf, "get = %f",*(Float32 *)0x6050004);
!     buf += strlen((char *)buf);
      
      *(Float32 *)0x6050008 = TIM_FRT_MCR_TO_CNT(*(Float32 *)0x6050004);
!     sprintf((char *)buf, "get = %f",*(Float32 *)0x6050008);
!     buf += strlen((char *)buf);
!     
!     return 0;
  }
! 
diff -crBN --binary sbl6/segasmp/v_blank/set_vb.c sbl6_patch/segasmp/v_blank/set_vb.c
*** sbl6/segasmp/v_blank/set_vb.c	1996-02-08 05:34:02.000000000 -0500
--- sbl6_patch/segasmp/v_blank/set_vb.c	2021-04-21 19:17:26.000000000 -0400
***************
*** 1,27 ****
! /*----------------------------------------------------------------------------
!  *  Set_VB.c -- V-Blank割り込みルーチンの登録
!  *  Copyright(c) 1994 SEGA
!  *  Written by K.M on 1994-05-16 Ver.0.90
!  *  Updated by K.M on 1994-10-04 Ver.1.02
!  *----------------------------------------------------------------------------
!  */
! 
! #include	<sega_xpt.h>
! #include	<sega_int.h>
! #include	"per_x.h"
! 
! void	UsrVblankIn( void );
! void	UsrVblankOut( void );
! extern SysPort	*__port;
! 
! void	SetVblank( void ){
! 	
! 	__port = PER_OpenPort();
! 	
! 	/* V-Blank割り込みルーチンの登録 */
! 	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
! 	INT_SetScuFunc(INT_SCU_VBLK_IN,UsrVblankIn);
! 	INT_SetScuFunc(INT_SCU_VBLK_OUT,UsrVblankOut);
! 	INT_ChgMsk(INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT,INT_MSK_NULL);
! }
! 
\ No newline at end of file
--- 1,46 ----
! /*----------------------------------------------------------------------------
!  *  Set_VB.c -- V-Blank割り込みルーチンの登録
!  *  Copyright(c) 1994 SEGA
!  *  Written by K.M on 1994-05-16 Ver.0.90
!  *  Updated by K.M on 1994-10-04 Ver.1.02
!  *----------------------------------------------------------------------------
!  */
! 
! #include <sega_xpt.h>
! #include <sega_int.h>
! #include <sega_per.h>
! 
! extern	void  UsrVblankStart(void);
! extern	void  UsrVblankEnd(void);
! 
! extern	Uint32	PadWorkArea[7];
! 
! volatile Sint32	perFlag;
! 
! void   CheckVblankEnd(void);
! 
! void SetVblank(void)
! {
! 	/* V_Blank Out 割り込みを待つ */
! 	
! 	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
! 	INT_SetScuFunc(INT_SCU_VBLK_OUT,CheckVblankEnd);
! 	INT_ChgMsk(INT_MSK_VBLK_OUT,INT_MSK_NULL);
! 
! 	perFlag = 1;
! 	while(perFlag);
!     
! 	PER_Init(PER_KD_PERTIM,2,PER_ID_DGT,PER_SIZE_DGT,PadWorkArea,0);
! 
! 	/* V-Blank割り込みルーチンの登録 */
! 	INT_ChgMsk(INT_MSK_NULL,INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT);
! 	INT_SetScuFunc(INT_SCU_VBLK_IN,UsrVblankStart);
! 	INT_SetScuFunc(INT_SCU_VBLK_OUT,UsrVblankEnd);
! 	INT_ChgMsk(INT_MSK_VBLK_IN | INT_MSK_VBLK_OUT,INT_MSK_NULL);
! }
! 
! 
! void   CheckVblankEnd(void)
! {
! 	perFlag = 0;
! }
diff -crBN --binary sbl6/segasmp/v_blank/v_blank2.c sbl6_patch/segasmp/v_blank/v_blank2.c
*** sbl6/segasmp/v_blank/v_blank2.c	1996-02-08 05:34:02.000000000 -0500
--- sbl6_patch/segasmp/v_blank/v_blank2.c	2024-08-19 13:06:46.000000000 -0400
***************
*** 1,11 ****
  /*----------------------------------------------------------------------------
!  *  V_Blank.c -- V-Blank割り込み処理内ルーチンサンプル
   *  Copyright(c) 1994 SEGA
   *  Written by K.M on 1994-05-16 Ver.1.00
   *  Updated by K.M on 1994-09-21 Ver.1.00
   *
!  *  UsrVblankStart()：V-Blank開始割り込み処理サンプル
!  *  UsrVblankEnd()  ：V-Blank終了割り込み処理サンプル
   *
   *----------------------------------------------------------------------------
   */
--- 1,11 ----
  /*----------------------------------------------------------------------------
!  *  V_Blank.c -- V-Blankｿｽｿｽｿｽ闕橸ｿｽﾝ擾ｿｽｿｽｿｽｿｽｿｽｿｽｿｽｿｽ[ｿｽ`ｿｽｿｽｿｽTｿｽｿｽｿｽvｿｽｿｽ
   *  Copyright(c) 1994 SEGA
   *  Written by K.M on 1994-05-16 Ver.1.00
   *  Updated by K.M on 1994-09-21 Ver.1.00
   *
!  *  UsrVblankStart()ｿｽFV-BlankｿｽJｿｽnｿｽｿｽｿｽ闕橸ｿｽﾝ擾ｿｽｿｽｿｽｿｽTｿｽｿｽｿｽvｿｽｿｽ
!  *  UsrVblankEnd()  ｿｽFV-BlankｿｽIｿｽｿｽｿｽｿｽｿｽ闕橸ｿｽﾝ擾ｿｽｿｽｿｽｿｽTｿｽｿｽｿｽvｿｽｿｽ
   *
   *----------------------------------------------------------------------------
   */
***************
*** 13,19 ****
  #include	<machine.h>
  #include	<sega_spr.h>
  #include	<sega_scl.h>
! #include	<sgl.h> 
  #include	"per_x.h"
  
  volatile trigger_t	PadData1  = 0x0000;
--- 13,19 ----
  #include	<machine.h>
  #include	<sega_spr.h>
  #include	<sega_scl.h>
! #include	<sgl.h>
  #include	"per_x.h"
  
  volatile trigger_t	PadData1  = 0x0000;
***************
*** 28,54 ****
  
  void   UsrVblankOut( void ){
  	BlankOut();
! 	
  	if( __port != NULL ){
  		const SysDevice	*device;
! 		
  		PER_GetPort( __port );
! 		
  		if(( device = PER_GetDeviceR( &__port[0], 0 )) != NULL ){
  			trigger_t	prev = PadData1;
  			trigger_t	current = PER_GetTrigger( device );
! 			
  			PadData1  = current;
  			PadData1E = PER_GetPressEdge( prev, current );
  		}
  		else{
  			PadData1 = PadData1E = 0;
  		}
! 		
  		if(( device = PER_GetDeviceR( &__port[1], 0 )) != NULL ){
  			trigger_t	prev = PadData2;
  			trigger_t	current = PER_GetTrigger( device );
! 			
  			PadData2  = current;
  			PadData2E = PER_GetPressEdge( prev, current );
  		}
--- 28,54 ----
  
  void   UsrVblankOut( void ){
  	BlankOut();
! 
  	if( __port != NULL ){
  		const SysDevice	*device;
! 
  		PER_GetPort( __port );
! 
  		if(( device = PER_GetDeviceR( &__port[0], 0 )) != NULL ){
  			trigger_t	prev = PadData1;
  			trigger_t	current = PER_GetTrigger( device );
! 
  			PadData1  = current;
  			PadData1E = PER_GetPressEdge( prev, current );
  		}
  		else{
  			PadData1 = PadData1E = 0;
  		}
! 
  		if(( device = PER_GetDeviceR( &__port[1], 0 )) != NULL ){
  			trigger_t	prev = PadData2;
  			trigger_t	current = PER_GetTrigger( device );
! 
  			PadData2  = current;
  			PadData2E = PER_GetPressEdge( prev, current );
  		}
***************
*** 57,60 ****
  		}
  	}
  }
! 
\ No newline at end of file
--- 57,60 ----
  		}
  	}
  }
! 
diff -crBN --binary sbl6/segasmp/v_blank/v_blank.c sbl6_patch/segasmp/v_blank/v_blank.c
*** sbl6/segasmp/v_blank/v_blank.c	1996-02-08 05:34:02.000000000 -0500
--- sbl6_patch/segasmp/v_blank/v_blank.c	2022-02-07 14:26:52.000000000 -0500
***************
*** 19,31 ****
  volatile trigger_t	PadData1E = 0x0000;
  volatile trigger_t	PadData2  = 0x0000;
  volatile trigger_t	PadData2E = 0x0000;
! SysPort	*__port = NULL;
  
  void	UsrVblankIn( void ){
  	SCL_VblankStart();
  }
  
! void   UsrVblankOut( void ){
  	SCL_VblankEnd();
  	
  	if( __port != NULL ){
--- 19,60 ----
  volatile trigger_t	PadData1E = 0x0000;
  volatile trigger_t	PadData2  = 0x0000;
  volatile trigger_t	PadData2E = 0x0000;
! //SysPort	*__port = NULL;
! 
! Uint32	PadWorkArea[7];
! 
  
  void	UsrVblankIn( void ){
  	SCL_VblankStart();
  }
  
! void   UsrVblankStart(void)
! {
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
! 	SCL_VblankStart();
! }
! 
! 
! void   UsrVblankEnd(void)
! {
! 	PerDgtInfo	*pad;
! 
! 	/* グラフィックライブラリを使用する為には実行しなければならない */
! 	SCL_VblankEnd();
! 
! 	/* パッドデータ取得 */
! 
! 	PER_GetPer((PerGetPer **)&pad);
! 	if( pad != NULL ){
! 		PadData1   = pad[0].data ^ 0xffff;
! 		PadData1E |= pad[0].push ^ 0xffff;
! 		PadData2   = pad[1].data ^ 0xffff;
! 		PadData2E |= pad[1].push ^ 0xffff;
! 	}
! 
! }
! 
! /*void   UsrVblankOut( void ){
  	SCL_VblankEnd();
  	
  	if( __port != NULL ){
***************
*** 55,59 ****
  			PadData2 = PadData2E = 0;
  		}
  	}
! }
! 
\ No newline at end of file
--- 84,88 ----
  			PadData2 = PadData2E = 0;
  		}
  	}
! }*/
! 
